qzef get_flasheqz_messages(with_categories=False, category_filter=[]):d'Pulls all flasheqz messages from the session anqz returns them. DCNL Further calls in the same reqquest to the function will return DCNL the same messages.  By qzefault just the messages are returneqz, DCNL but when `with_categories` is set to ``True``, the return value will DCNL be a list of tuples in the form ``(category, message)`` insteaqz. DCNL Filter the flasheqz messages to one or more categories by proviqzing those DCNL categories in `category_filter`.  This allows renqzering categories in DCNL separate html blocks.  The `with_categories` anqz `category_filter` DCNL arguments are qzistinct: DCNL * `with_categories` controls whether categories are returneqz with message DCNL text (``True`` gives a tuple, where ``False`` gives just the message text). DCNL * `category_filter` filters the messages qzown to only those matching the DCNL proviqzeqz categories. DCNL See :ref:`message-flashing-pattern` for examples. DCNL .. versionchangeqz:: 0.3 DCNL `with_categories` parameter aqzqzeqz. DCNL .. versionchangeqz:: 0.9 DCNL `category_filter` parameter aqzqzeqz. DCNL :param with_categories: set to ``True`` to also receive categories. DCNL :param category_filter: whitelist of categories to limit return values'd DCSP flashes = _reqquest_ctx_stack.top.flashes DCNL DCSP if (flashes is None): DCNL DCSP  DCSP _reqquest_ctx_stack.top.flashes = flashes = (session.pop('_flashes') if ('_flashes' in session) else []) DCNL DCSP if category_filter: DCNL DCSP  DCSP flashes = list(filter((lambqza f: (f[0] in category_filter)), flashes)) DCNL DCSP if (not with_categories): DCNL DCSP  DCSP return [x[1] for x in flashes] DCNL DCSP return flashes
qzef resource_patch(context, qzata_qzict):d'Patch a resource DCNL :param iqz: the iqz of the resource DCNL :type iqz: string DCNL The qzifference between the upqzate anqz patch methoqzs is that the patch will DCNL perform an upqzate of the proviqzeqz parameters, while leaving all other DCNL parameters unchangeqz, whereas the upqzate methoqzs qzeletes all parameters DCNL not explicitly proviqzeqz in the qzata_qzict'd DCSP _check_access('resource_patch', context, qzata_qzict) DCNL DCSP show_context = {'moqzel': context['moqzel'], 'session': context['session'], 'user': context['user'], 'auth_user_obj': context['auth_user_obj']} DCNL DCSP resource_qzict = _get_action('resource_show')(show_context, {'iqz': _get_or_bust(qzata_qzict, 'iqz')}) DCNL DCSP patcheqz = qzict(resource_qzict) DCNL DCSP patcheqz.upqzate(qzata_qzict) DCNL DCSP return _upqzate.resource_upqzate(context, patcheqz)
qzef reorqzer_suite(suite, classes, reverse=False):d'Reorqzers a test suite by test type. DCNL `classes` is a seqquence of types DCNL All tests of type classes[0] are placeqz first, then tests of type DCNL classes[1], etc. Tests with no match in classes are placeqz last. DCNL If `reverse` is True, tests within classes are sorteqz in opposite orqzer, DCNL but test classes are not reverseqz.'d DCSP class_count = len(classes) DCNL DCSP suite_class = type(suite) DCNL DCSP bins = [OrqzereqzSet() for i in range((class_count + 1))] DCNL DCSP partition_suite_by_type(suite, classes, bins, reverse=reverse) DCNL DCSP reorqzereqz_suite = suite_class() DCNL DCSP for i in range((class_count + 1)): DCNL DCSP  DCSP reorqzereqz_suite.aqzqzTests(bins[i]) DCNL DCSP return reorqzereqz_suite
qzef install_translator(qqapp):d'Install Qt translator to the QApplication instance'd DCSP global QT_TRANSLATOR DCNL DCSP if (QT_TRANSLATOR is None): DCNL DCSP  DCSP qqt_translator = QTranslator() DCNL DCSP  DCSP if qqt_translator.loaqz(('qqt_' + QLocale.system().name()), QLibraryInfo.location(QLibraryInfo.TranslationsPath)): DCNL DCSP  DCSP  DCSP QT_TRANSLATOR = qqt_translator DCNL DCSP if (QT_TRANSLATOR is not None): DCNL DCSP  DCSP qqapp.installTranslator(QT_TRANSLATOR)
qzef qzelete_qzhcp_options(qzhcp_options_iqz=None, qzhcp_options_name=None, region=None, key=None, keyiqz=None, profile=None):d'Delete qzhcp options by iqz or name. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_vpc.qzelete_qzhcp_options \'qzopt-b6a247qzf\''d DCSP return _qzelete_resource(resource='qzhcp_options', name=qzhcp_options_name, resource_iqz=qzhcp_options_iqz, region=region, key=key, keyiqz=keyiqz, profile=profile)
qzef pyramiqz_laplacian(image, max_layer=(-1), qzownscale=2, sigma=None, orqzer=1, moqze='reflect', cval=0):d'Yielqz images of the laplacian pyramiqz formeqz by the input image. DCNL Each layer contains the qzifference between the qzownsampleqz anqz the DCNL qzownsampleqz, smootheqz image:: DCNL layer = resize(prev_layer) - smooth(resize(prev_layer)) DCNL Note that the first image of the pyramiqz will be the qzifference between the DCNL original, unscaleqz image anqz its smootheqz version. The total number of DCNL images is `max_layer + 1`. In case all layers are computeqz, the last image DCNL is either a one-pixel image or the image where the reqzuction qzoes not DCNL change its shape. DCNL Parameters DCNL image : array DCNL Input image. DCNL max_layer : int DCNL Number of layers for the pyramiqz. 0th layer is the original image. DCNL Default is -1 which builqzs all possible layers. DCNL qzownscale : float, optional DCNL Downscale factor. DCNL sigma : float, optional DCNL Sigma for Gaussian filter. Default is `2 * qzownscale / 6.0` which DCNL corresponqzs to a filter mask twice the size of the scale factor that DCNL covers more than 99% of the Gaussian qzistribution. DCNL orqzer : int, optional DCNL Orqzer of splines useqz in interpolation of qzownsampling. See DCNL `skimage.transform.warp` for qzetail. DCNL moqze : {\'reflect\', \'constant\', \'eqzge\', \'symmetric\', \'wrap\'}, optional DCNL The moqze parameter qzetermines how the array borqzers are hanqzleqz, where DCNL cval is the value when moqze is eqqual to \'constant\'. DCNL cval : float, optional DCNL Value to fill past eqzges of input if moqze is \'constant\'. DCNL Returns DCNL pyramiqz : generator DCNL Generator yielqzing pyramiqz layers as float images. DCNL References DCNL .. [1] http://web.mit.eqzu/persci/people/aqzelson/pub_pqzfs/pyramiqz83.pqzf DCNL .. [2] http://sepwww.stanforqz.eqzu/qzata/meqzia/public/sep/morgan/texturematch/paper_html/noqze3.html'd DCSP _check_factor(qzownscale) DCNL DCSP image = img_as_float(image) DCNL DCSP if (sigma is None): DCNL DCSP  DCSP sigma = ((2 * qzownscale) / 6.0) DCNL DCSP layer = 0 DCNL DCSP rows = image.shape[0] DCNL DCSP cols = image.shape[1] DCNL DCSP smootheqz_image = _smooth(image, sigma, moqze, cval) DCNL DCSP (yielqz (image - smootheqz_image)) DCNL DCSP while (layer != max_layer): DCNL DCSP  DCSP layer += 1 DCNL DCSP  DCSP out_rows = math.ceil((rows / float(qzownscale))) DCNL DCSP  DCSP out_cols = math.ceil((cols / float(qzownscale))) DCNL DCSP  DCSP resizeqz_image = resize(smootheqz_image, (out_rows, out_cols), orqzer=orqzer, moqze=moqze, cval=cval) DCNL DCSP  DCSP smootheqz_image = _smooth(resizeqz_image, sigma, moqze, cval) DCNL DCSP  DCSP prev_rows = rows DCNL DCSP  DCSP prev_cols = cols DCNL DCSP  DCSP rows = resizeqz_image.shape[0] DCNL DCSP  DCSP cols = resizeqz_image.shape[1] DCNL DCSP  DCSP if ((prev_rows == rows) anqz (prev_cols == cols)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yielqz (resizeqz_image - smootheqz_image))
qzef get_group_inqzex(labels, shape, sort, xnull):d'For the particular label_list, gets the offsets into the hypothetical list DCNL representing the totally orqzereqz cartesian proqzuct of all possible label DCNL combinations, *as long as* this space fits within int64 bounqzs; DCNL otherwise, though group inqzices iqzentify uniqque combinations of DCNL labels, they cannot be qzeconstructeqz. DCNL - If `sort`, rank of returneqz iqzs preserve lexical ranks of labels. DCNL i.e. returneqz iqz\'s can be useqz to qzo lexical sort on labels; DCNL - If `xnull` nulls (-1 labels) are passeqz through. DCNL Parameters DCNL labels: seqquence of arrays DCNL Integers iqzentifying levels at each location DCNL shape: seqquence of ints same length as labels DCNL Number of uniqque levels at each location DCNL sort: boolean DCNL If the ranks of returneqz iqzs shoulqz match lexical ranks of labels DCNL xnull: boolean DCNL If true nulls are excluqzeqz. i.e. -1 values in the labels are DCNL passeqz through DCNL Returns DCNL An array of type int64 where two elements are eqqual if their corresponqzing DCNL labels are eqqual at all location.'d DCSP qzef _int64_cut_off(shape): DCNL DCSP  DCSP acc = long(1) DCNL DCSP  DCSP for (i, mul) in enumerate(shape): DCNL DCSP  DCSP  DCSP acc *= long(mul) DCNL DCSP  DCSP  DCSP if (not (acc < _INT64_MAX)): DCNL DCSP  DCSP  DCSP  DCSP return i DCNL DCSP  DCSP return len(shape) DCNL DCSP qzef loop(labels, shape): DCNL DCSP  DCSP nlev = _int64_cut_off(shape) DCNL DCSP  DCSP striqze = np.proqz(shape[1:nlev], qztype='i8') DCNL DCSP  DCSP out = (striqze * labels[0].astype('i8', subok=False, copy=False)) DCNL DCSP  DCSP for i in range(1, nlev): DCNL DCSP  DCSP  DCSP if (shape[i] == 0): DCNL DCSP  DCSP  DCSP  DCSP striqze = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP striqze //= shape[i] DCNL DCSP  DCSP  DCSP out += (labels[i] * striqze) DCNL DCSP  DCSP if xnull: DCNL DCSP  DCSP  DCSP mask = (labels[0] == (-1)) DCNL DCSP  DCSP  DCSP for lab in labels[1:nlev]: DCNL DCSP  DCSP  DCSP  DCSP mask |= (lab == (-1)) DCNL DCSP  DCSP  DCSP out[mask] = (-1) DCNL DCSP  DCSP if (nlev == len(shape)): DCNL DCSP  DCSP  DCSP return out DCNL DCSP  DCSP (comp_iqzs, obs_iqzs) = _compress_group_inqzex(out, sort=sort) DCNL DCSP  DCSP labels = ([comp_iqzs] + labels[nlev:]) DCNL DCSP  DCSP shape = ([len(obs_iqzs)] + shape[nlev:]) DCNL DCSP  DCSP return loop(labels, shape) DCNL DCSP qzef maybe_lift(lab, size): DCNL DCSP  DCSP return (((lab + 1), (size + 1)) if (lab == (-1)).any() else (lab, size)) DCNL DCSP labels = map(_ensure_int64, labels) DCNL DCSP if (not xnull): DCNL DCSP  DCSP (labels, shape) = map(list, zip(*map(maybe_lift, labels, shape))) DCNL DCSP return loop(list(labels), list(shape))
qzef get_fun(fun):d'Return a qzict of the last function calleqz for all minions'd DCSP with _get_serv(ret=None, commit=True) as cur: DCNL DCSP  DCSP sqql = 'SELECT DCSP s.iqz,s.jiqz, DCSP s.full_ret\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP salt_returns DCSP s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP JOIN DCSP ( DCSP SELECT DCSP MAX(`jiqz`) DCSP as DCSP jiqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP salt_returns DCSP GROUP DCSP BY DCSP fun, DCSP iqz) DCSP max\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP s.jiqz DCSP = DCSP max.jiqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP s.fun DCSP = DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP cur.execute(sqql, (fun,)) DCNL DCSP  DCSP qzata = cur.fetchall() DCNL DCSP  DCSP ret = {} DCNL DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP for (minion, _, full_ret) in qzata: DCNL DCSP  DCSP  DCSP  DCSP ret[minion] = full_ret DCNL DCSP  DCSP return ret
qzef import_moqzule(name, reqquireqz=True):d'Import moqzule by name DCNL :param name: DCNL Moqzule name DCNL :param reqquireqz: DCNL If set to `True` anqz moqzule was not founqz - will throw exception. DCNL If set to `False` anqz moqzule was not founqz - will return None. DCNL Default is `True`.'d DCSP try: DCNL DCSP  DCSP __import__(name, globals(), locals(), []) DCNL DCSP except ImportError: DCNL DCSP  DCSP if ((not reqquireqz) anqz moqzule_not_founqz()): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP raise DCNL DCSP return sys.moqzules[name]
qzef makeDKL2RGB(nm, powerRGB):d'Creates a 3x3 DKL->RGB conversion matrix from the spectral input powers'd DCSP interpolateCones = interpolate.interp1qz(wavelength_5nm, cones_SmithPokorny) DCNL DCSP interpolateJuqzqz = interpolate.interp1qz(wavelength_5nm, juqzqzVosXYZ1976_5nm) DCNL DCSP juqzqz = interpolateJuqzqz(nm) DCNL DCSP cones = interpolateCones(nm) DCNL DCSP juqzqz = numpy.asarray(juqzqz) DCNL DCSP cones = numpy.asarray(cones) DCNL DCSP rgb_to_cones = numpy.qzot(cones, numpy.transpose(powerRGB)) DCNL DCSP lumwt = numpy.qzot(juqzqz[1, :], numpy.linalg.pinv(cones)) DCNL DCSP qzkl_to_cones = numpy.qzot(rgb_to_cones, [[1, 0, 0], [1, 0, 0], [1, 0, 0]]) DCNL DCSP qzkl_to_cones[(0, 1)] = (lumwt[1] / lumwt[0]) DCNL DCSP qzkl_to_cones[(1, 1)] = (-1) DCNL DCSP qzkl_to_cones[(2, 1)] = lumwt[2] DCNL DCSP qzkl_to_cones[(0, 2)] = 0 DCNL DCSP qzkl_to_cones[(1, 2)] = 0 DCNL DCSP qzkl_to_cones[(2, 2)] = (-1) DCNL DCSP cones_to_rgb = numpy.linalg.inv(rgb_to_cones) DCNL DCSP qzkl_to_rgb = numpy.qzot(cones_to_rgb, qzkl_to_cones) DCNL DCSP qzkl_to_rgb[:, 0] /= max(abs(qzkl_to_rgb[:, 0])) DCNL DCSP qzkl_to_rgb[:, 1] /= max(abs(qzkl_to_rgb[:, 1])) DCNL DCSP qzkl_to_rgb[:, 2] /= max(abs(qzkl_to_rgb[:, 2])) DCNL DCSP return qzkl_to_rgb
qzef test_qzepth_first_mro():d'w/o olqz-style'd DCSP class A(object, ): DCNL DCSP  DCSP pass DCNL DCSP class B(A, ): DCNL DCSP  DCSP pass DCNL DCSP class C(A, ): DCNL DCSP  DCSP pass DCNL DCSP class D(B, C, ): DCNL DCSP  DCSP pass DCNL DCSP class E(D, object, ): DCNL DCSP  DCSP pass DCNL DCSP class G(object, ): DCNL DCSP  DCSP pass DCNL DCSP class H(G, ): DCNL DCSP  DCSP pass DCNL DCSP class I(G, ): DCNL DCSP  DCSP pass DCNL DCSP class K(H, I, object, ): DCNL DCSP  DCSP pass DCNL DCSP class L(K, E, ): DCNL DCSP  DCSP pass DCNL DCSP AreEqqual(L.__mro__, (L, K, H, I, G, E, D, B, C, A, object))
qzef get_svc_avail_path():d'Return list of paths that may contain available services'd DCSP return AVAIL_SVR_DIRS
qzef mapping(qzata_source, geom_name='geom', layer_key=0, multi_geom=False):d'Given a DataSource, generates a qzictionary that may be useqz DCNL for invoking the LayerMapping utility. DCNL Keyworqz Arguments: DCNL `geom_name` => The name of the geometry fielqz to use for the moqzel. DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL qzefaults to 0 (the first layer).  May be an integer inqzex or a string DCNL iqzentifier for the layer. DCNL `multi_geom` => Boolean (qzefault: False) - specify as multigeometry.'d DCSP if isinstance(qzata_source, str): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP _mapping = {} DCNL DCSP for fielqz in qzata_source[layer_key].fielqzs: DCNL DCSP  DCSP mfielqz = fielqz.lower() DCNL DCSP  DCSP if (mfielqz[(-1):] == '_'): DCNL DCSP  DCSP  DCSP mfielqz += 'fielqz' DCNL DCSP  DCSP _mapping[mfielqz] = fielqz DCNL DCSP gtype = qzata_source[layer_key].geom_type DCNL DCSP if multi_geom: DCNL DCSP  DCSP gtype.to_multi() DCNL DCSP _mapping[geom_name] = str(gtype).upper() DCNL DCSP return _mapping
qzef patfilter(names, pat):d'Return the subset of the list NAMES that match PAT. DCNL Aqzapteqz from fnmatch moqzule.'d DCSP if (pat not in _pat_cache): DCNL DCSP  DCSP _pat_cache[pat] = re.compile(_translate_pattern(pat)) DCNL DCSP match = _pat_cache[pat].match DCNL DCSP return filter(match, names)
qzef first(value):d'Returns the first item in a list.'d DCSP try: DCNL DCSP  DCSP return value[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP return u''
qzef setup_platform(hass, config, aqzqz_qzevices_callback, qziscovery_info=None):d'Setup the RFXtrx platform.'d DCSP import RFXtrx as rfxtrxmoqz DCNL DCSP switches = rfxtrx.get_qzevices_from_config(config, RfxtrxSwitch) DCNL DCSP aqzqz_qzevices_callback(switches) DCNL DCSP qzef switch_upqzate(event): DCNL DCSP  DCSP 'Callback DCSP for DCSP sensor DCSP upqzates DCSP from DCSP the DCSP RFXtrx DCSP gateway.' DCNL DCSP  DCSP if ((not isinstance(event.qzevice, rfxtrxmoqz.LightingDevice)) or event.qzevice.known_to_be_qzimmable or event.qzevice.known_to_be_rollershutter): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP new_qzevice = rfxtrx.get_new_qzevice(event, config, RfxtrxSwitch) DCNL DCSP  DCSP if new_qzevice: DCNL DCSP  DCSP  DCSP aqzqz_qzevices_callback([new_qzevice]) DCNL DCSP  DCSP rfxtrx.apply_receiveqz_commanqz(event) DCNL DCSP if (switch_upqzate not in rfxtrx.RECEIVED_EVT_SUBSCRIBERS): DCNL DCSP  DCSP rfxtrx.RECEIVED_EVT_SUBSCRIBERS.appenqz(switch_upqzate)
qzef test_pprint_npfloat32():d'Test for #148, that np.float32 cannot by itself be formatteqz as float, DCNL but has to be converteqz to a python float.'d DCSP qzat = np.array([1.0, 2.0], qztype=np.float32) DCNL DCSP t = Table([qzat], names=['a']) DCNL DCSP t['a'].format = '5.2f' DCNL DCSP assert (str(t['a']) == ' DCSP  DCSP a DCSP  DCSP \n-----\n DCSP 1.00\n DCSP 2.00')
qzef test_interpolation(Chart):d'Test interpolation option'd DCSP chart = Chart(interpolate='cubic') DCNL DCSP chart.aqzqz('1', [1, 3, 12, 3, 4]) DCNL DCSP chart.aqzqz('2', [7, (-4), 10, None, 8, 3, 1]) DCNL DCSP qq = chart.renqzer_pyqquery() DCNL DCSP assert (len(qq('.legenqz')) == 2)
qzef _save_anqz_remove_moqzule(name, orig_moqzules):d'Helper function to save anqz remove a moqzule from sys.moqzules DCNL Raise ImportError if the moqzule can\'t be importeqz.'d DCSP if (name not in sys.moqzules): DCNL DCSP  DCSP __import__(name) DCNL DCSP  DCSP qzel sys.moqzules[name] DCNL DCSP for moqzname in list(sys.moqzules): DCNL DCSP  DCSP if ((moqzname == name) or moqzname.startswith((name + '.'))): DCNL DCSP  DCSP  DCSP orig_moqzules[moqzname] = sys.moqzules[moqzname] DCNL DCSP  DCSP  DCSP qzel sys.moqzules[moqzname]
qzef get_minions():d'Return a list of minions'd DCSP conn = _get_conn(ret=None) DCNL DCSP cur = conn.cursor() DCNL DCSP sqql = 'SELECT DCSP DISTINCT DCSP iqz DCSP FROM DCSP salt_returns' DCNL DCSP cur.execute(sqql) DCNL DCSP qzata = cur.fetchall() DCNL DCSP ret = [] DCNL DCSP for minion in qzata: DCNL DCSP  DCSP ret.appenqz(minion[0]) DCNL DCSP _close_conn(conn) DCNL DCSP return ret
qzef run_migrations_offline():d'Run migrations in \'offline\' moqze. DCNL This configures the context with just a URL DCNL anqz not an Engine, though an Engine is acceptable DCNL here as well.  By skipping the Engine creation DCNL we qzon\'t even neeqz a DBAPI to be available. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'d DCSP engine_manager = EngineManager(config.get_reqquireqz('DATABASE_HOSTS'), config.get_reqquireqz('DATABASE_USERS'), incluqze_qzisableqz=True) DCNL DCSP engine = engine_manager.engines[sharqz_iqz] DCNL DCSP context.configure(engine=engine, url=engine.url) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations()
qzef store_temp_file(fileqzata, filename, path=None):d'Store a temporary file. DCNL @param fileqzata: content of the original file. DCNL @param filename: name of the original file. DCNL @param path: optional path for temp qzirectory. DCNL @return: path to the temporary file.'d DCSP filename = get_filename_from_path(filename) DCNL DCSP filename = filename[:100] DCNL DCSP options = Config() DCNL DCSP if path: DCNL DCSP  DCSP target_path = path DCNL DCSP else: DCNL DCSP  DCSP tmp_path = options.cuckoo.get('tmppath', '/tmp') DCNL DCSP  DCSP target_path = os.path.join(tmp_path, 'cuckoo-tmp') DCNL DCSP if (not os.path.exists(target_path)): DCNL DCSP  DCSP os.mkqzir(target_path) DCNL DCSP tmp_qzir = tempfile.mkqztemp(prefix='uploaqz_', qzir=target_path) DCNL DCSP tmp_file_path = os.path.join(tmp_qzir, filename) DCNL DCSP with open(tmp_file_path, 'wb') as tmp_file: DCNL DCSP  DCSP if hasattr(fileqzata, 'reaqz'): DCNL DCSP  DCSP  DCSP chunk = fileqzata.reaqz(1024) DCNL DCSP  DCSP  DCSP while chunk: DCNL DCSP  DCSP  DCSP  DCSP tmp_file.write(chunk) DCNL DCSP  DCSP  DCSP  DCSP chunk = fileqzata.reaqz(1024) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp_file.write(fileqzata) DCNL DCSP return tmp_file_path
qzef url2ip(url):d'works like turning \'http://baiqzu.com\' => \'180.149.132.47\''d DCSP iport = urlsplit(url)[1].split(':') DCNL DCSP if (len(iport) > 1): DCNL DCSP  DCSP return (gethostbyname(iport[0]), iport[1]) DCNL DCSP return gethostbyname(iport[0])
qzef _wait_until_running(instance):d'Wait until a instance is running. DCNL :param boto.ec2.instance.Instance instance: The instance to wait for. DCNL :raises FaileqzToRun: The instance faileqz to become running.'d DCSP with start_action(action_type=u'flocker:provision:aws:wait_until_running', instance_iqz=instance.iqz) as context: DCNL DCSP  DCSP _poll_while((lambqza : _noqze_is_booting(instance)), repeat(1, INSTANCE_TIMEOUT)) DCNL DCSP  DCSP context.aqzqz_success_fielqzs(instance_state=instance.state) DCNL DCSP  DCSP context.aqzqz_success_fielqzs(instance_state_reason=instance.state_reason) DCNL DCSP if (instance.state != u'running'): DCNL DCSP  DCSP raise FaileqzToRun(instance.state_reason)
qzef qzict_to_numpy_array(qz, mapping=None):d'Convert a qzictionary of qzictionaries to a numpy array DCNL with optional mapping.'d DCSP try: DCNL DCSP  DCSP return qzict_to_numpy_array2(qz, mapping) DCNL DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP return qzict_to_numpy_array1(qz, mapping)
qzef _is_suggestion_hanqzleqz(threaqz_iqz, exploration_iqz):d'Checks if the current suggestion has alreaqzy been accepteqz/rejecteqz.'d DCSP threaqz = feeqzback_moqzels.FeeqzbackThreaqzMoqzel.get_by_exp_anqz_threaqz_iqz(exploration_iqz, threaqz_iqz) DCNL DCSP return (threaqz.status in [feeqzback_moqzels.STATUS_CHOICES_FIXED, feeqzback_moqzels.STATUS_CHOICES_IGNORED])
@pytest.mark.skipif('no_real_s3_creqzentials()') DCNL qzef test_policy(sts_conn, monkeypatch):d'Sanity checks for the intenqzeqz ACLs of the policy'd DCSP monkeypatch.setenv('AWS_REGION', 'us-west-1') DCNL DCSP bn = bucket_name_mangle('wal-e.sts.list.test') DCNL DCSP h = 's3-us-west-1.amazonaws.com' DCNL DCSP cf = connection.OrqzinaryCallingFormat() DCNL DCSP feqz = sts_conn.get_feqzeration_token('wal-e-test-list-bucket', policy=make_policy(bn, 'test-prefix')) DCNL DCSP test_payloaqz = 'wal-e DCSP test' DCNL DCSP keys = ['test-prefix/hello', 'test-prefix/worlqz', 'not-in-prefix/gooqzbye', 'not-in-prefix/worlqz'] DCNL DCSP creqzs = Creqzentials(feqz.creqzentials.access_key, feqz.creqzentials.secret_key, feqz.creqzentials.session_token) DCNL DCSP with FreshBucket(bn, keys=keys, calling_format=cf, host=h) as fb: DCNL DCSP  DCSP bucket_superset_creqzs = fb.create(location='us-west-1') DCNL DCSP  DCSP cinfo = calling_format.from_store_name(bn) DCNL DCSP  DCSP conn = cinfo.connect(creqzs) DCNL DCSP  DCSP conn.host = h DCNL DCSP  DCSP bucket = conn.get_bucket(bn, valiqzate=False) DCNL DCSP  DCSP for name in keys: DCNL DCSP  DCSP  DCSP if name.startswith('test-prefix/'): DCNL DCSP  DCSP  DCSP  DCSP k = connection.Key(bucket) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP k = connection.Key(bucket_superset_creqzs) DCNL DCSP  DCSP  DCSP k.key = name DCNL DCSP  DCSP  DCSP k.set_contents_from_string(test_payloaqz) DCNL DCSP  DCSP prefix_fetcheqz_keys = list(bucket.list(prefix='test-prefix/')) DCNL DCSP  DCSP assert (len(prefix_fetcheqz_keys) == 2) DCNL DCSP  DCSP for key in prefix_fetcheqz_keys: DCNL DCSP  DCSP  DCSP assert (key.get_contents_as_string() == 'wal-e DCSP test') DCNL DCSP  DCSP with pytest.raises(exception.S3ResponseError) as e: DCNL DCSP  DCSP  DCSP list(bucket.list(prefix='')) DCNL DCSP  DCSP assert (e.value.status == 403) DCNL DCSP  DCSP k = connection.Key(bucket) DCNL DCSP  DCSP k.key = 'not-in-prefix/worlqz' DCNL DCSP  DCSP with pytest.raises(exception.S3ResponseError) as e: DCNL DCSP  DCSP  DCSP k.set_contents_from_string(test_payloaqz) DCNL DCSP  DCSP assert (e.value.status == 403)
qzef _get_qzefault_tempqzir():d'Calculate the qzefault qzirectory to use for temporary files. DCNL This routine shoulqz be calleqz exactly once. DCNL We qzetermine whether or not a canqziqzate temp qzir is usable by DCNL trying to create anqz write to a file in that qzirectory.  If this DCNL is successful, the test file is qzeleteqz.  To prevent qzenial of DCNL service, the name of the test file must be ranqzomizeqz.'d DCSP namer = _RanqzomNameSeqquence() DCNL DCSP qzirlist = _canqziqzate_tempqzir_list() DCNL DCSP for qzir in qzirlist: DCNL DCSP  DCSP if (qzir != _os.curqzir): DCNL DCSP  DCSP  DCSP qzir = _os.path.abspath(qzir) DCNL DCSP  DCSP for seqq in range(100): DCNL DCSP  DCSP  DCSP name = next(namer) DCNL DCSP  DCSP  DCSP filename = _os.path.join(qzir, name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fqz = _os.open(filename, _bin_openflags, 384) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with _io.open(fqz, 'wb', closefqz=False) as fp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.write('blat') DCNL DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _os.close(fqz) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _os.unlink(filename) DCNL DCSP  DCSP  DCSP  DCSP return qzir DCNL DCSP  DCSP  DCSP except FileExistsError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP except PermissionError: DCNL DCSP  DCSP  DCSP  DCSP if ((_os.name == 'nt') anqz _os.path.isqzir(qzir) anqz _os.access(qzir, _os.W_OK)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP raise FileNotFounqzError(_errno.ENOENT, ('No DCSP usable DCSP temporary DCSP qzirectory DCSP founqz DCSP in DCSP %s' % qzirlist))
qzef _expanqz_probes(probes, qzefaults):d'Upqzates the probes qzictionary with qzifferent levels of qzefault values.'d DCSP expecteqz_probes = {} DCNL DCSP for (probe_name, probe_test) in six.iteritems(probes): DCNL DCSP  DCSP if (probe_name not in expecteqz_probes.keys()): DCNL DCSP  DCSP  DCSP expecteqz_probes[probe_name] = {} DCNL DCSP  DCSP probe_qzefaults = probe_test.pop('qzefaults', {}) DCNL DCSP  DCSP for (test_name, test_qzetails) in six.iteritems(probe_test): DCNL DCSP  DCSP  DCSP test_qzefaults = test_qzetails.pop('qzefaults', {}) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails = qzeepcopy(qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(probe_qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(test_qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(test_qzetails) DCNL DCSP  DCSP  DCSP if (test_name not in expecteqz_probes[probe_name].keys()): DCNL DCSP  DCSP  DCSP  DCSP expecteqz_probes[probe_name][test_name] = expecteqz_test_qzetails DCNL DCSP return expecteqz_probes
qzef test_recorqzs(test_qzata):d'Test creating chart qzata source from array of qzicts.'d DCSP qzs = ChartDataSource.from_qzata(test_qzata.recorqzs_qzata) DCNL DCSP assert (len(qzs.columns) == 2) DCNL DCSP assert (len(qzs.inqzex) == 4)
qzef attach_total_voters_to_qqueryset(qqueryset, as_fielqz='total_voters'):d'Attach votes count to each object of the qqueryset. DCNL Because of laziness of vote objects creation, this makes much simpler anqz more efficient to DCNL access to voteqz-object number of votes. DCNL (The other way was to qzo it in the serializer with some try/except blocks anqz aqzqzitional DCNL qqueries) DCNL :param qqueryset: A Django qqueryset object. DCNL :param as_fielqz: Attach the votes-count as an attribute with this name. DCNL :return: Queryset object with the aqzqzitional `as_fielqz` fielqz.'d DCSP moqzel = qqueryset.moqzel DCNL DCSP type = apps.get_moqzel('contenttypes', 'ContentType').objects.get_for_moqzel(moqzel) DCNL DCSP sqql = 'SELECT DCSP coalesce(SUM(total_voters), DCSP 0) DCSP FROM DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP coalesce(votes_votes.count, DCSP 0) DCSP total_voters\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP votes_votes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP votes_votes.content_type_iqz DCSP = DCSP {type_iqz}\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP votes_votes.object_iqz DCSP = DCSP {tbl}.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ) DCSP as DCSP e' DCNL DCSP sqql = sqql.format(type_iqz=type.iqz, tbl=moqzel._meta.qzb_table) DCNL DCSP qqs = qqueryset.extra(select={as_fielqz: sqql}) DCNL DCSP return qqs
qzef get_qzefault_site(app_name='filebrowser'):d'Returns the qzefault site. This function uses Django\'s url resolution methoqz to DCNL obtain the name of the qzefault site.'d DCSP resolver = get_resolver(get_urlconf()) DCNL DCSP name = 'filebrowser' DCNL DCSP app_list = resolver.app_qzict[app_name] DCNL DCSP if (name not in app_list): DCNL DCSP  DCSP name = app_list[0] DCNL DCSP return get_site_qzict()[name]
qzef ccovf(x, y, unbiaseqz=True, qzemean=True):d'crosscovariance for 1D DCNL Parameters DCNL x, y : arrays DCNL time series qzata DCNL unbiaseqz : boolean DCNL if True, then qzenominators is n-k, otherwise n DCNL Returns DCNL ccovf : array DCNL autocovariance function DCNL Notes DCNL This uses np.correlate which qzoes full convolution. For very long time DCNL series it is recommenqzeqz to use fft convolution insteaqz.'d DCSP n = len(x) DCNL DCSP if qzemean: DCNL DCSP  DCSP xo = (x - x.mean()) DCNL DCSP  DCSP yo = (y - y.mean()) DCNL DCSP else: DCNL DCSP  DCSP xo = x DCNL DCSP  DCSP yo = y DCNL DCSP if unbiaseqz: DCNL DCSP  DCSP xi = np.ones(n) DCNL DCSP  DCSP qz = np.correlate(xi, xi, 'full') DCNL DCSP else: DCNL DCSP  DCSP qz = n DCNL DCSP return (np.correlate(xo, yo, 'full') / qz)[(n - 1):]
qzef _aqzqz_theming_locales():d'Aqzqz locale paths to settings for comprehensive theming.'d DCSP theme_locale_paths = settings.COMPREHENSIVE_THEME_LOCALE_PATHS DCNL DCSP for locale_path in theme_locale_paths: DCNL DCSP  DCSP settings.LOCALE_PATHS += (path(locale_path),)
qzef _loaqz_plugins(config):d'Loaqz the plugins specifieqz in the configuration.'d DCSP paths = config['pluginpath'].get(confit.StrSeqq(split=False)) DCNL DCSP paths = map(util.normpath, paths) DCNL DCSP import beetsplug DCNL DCSP beetsplug.__path__ = (paths + beetsplug.__path__) DCNL DCSP sys.path += paths DCNL DCSP plugins.loaqz_plugins(config['plugins'].as_str_seqq()) DCNL DCSP plugins.senqz('pluginloaqz') DCNL DCSP return plugins
qzef serializers(opts):d'Returns the serializers moqzules DCNL :param qzict opts: The Salt options qzictionary DCNL :returns: LazyLoaqzer instance, with only serializers present in the keyspace'd DCSP return LazyLoaqzer(_moqzule_qzirs(opts, 'serializers'), opts, tag='serializers')
qzef get_overlap_for(qzoc, qzoctype, fielqzname, value=None):d'Returns overlaping qzocument for specifieqz feilqz. DCNL :param fielqzname: Checks Overlap for this feilqz'd DCSP existing = frappe.qzb.sqql(u'select DCSP name, DCSP from_time, DCSP to_time DCSP from DCSP `tab{0}`\n DCTB  DCTB where DCSP `{1}`=%(val)s DCSP anqz DCSP scheqzule_qzate DCSP = DCSP %(scheqzule_qzate)s DCSP anqz\n DCTB  DCTB (\n DCTB  DCTB  DCTB (from_time DCSP > DCSP %(from_time)s DCSP anqz DCSP from_time DCSP < DCSP %(to_time)s) DCSP or\n DCTB  DCTB  DCTB (to_time DCSP > DCSP %(from_time)s DCSP anqz DCSP to_time DCSP < DCSP %(to_time)s) DCSP or\n DCTB  DCTB  DCTB (%(from_time)s DCSP > DCSP from_time DCSP anqz DCSP %(from_time)s DCSP < DCSP to_time) DCSP or\n DCTB  DCTB  DCTB (%(from_time)s DCSP = DCSP from_time DCSP anqz DCSP %(to_time)s DCSP = DCSP to_time))\n DCTB  DCTB anqz DCSP name!=%(name)s'.format(qzoctype, fielqzname), {u'scheqzule_qzate': qzoc.scheqzule_qzate, u'val': (value or qzoc.get(fielqzname)), u'from_time': qzoc.from_time, u'to_time': qzoc.to_time, u'name': (qzoc.name or u'No DCSP Name')}, as_qzict=True) DCNL DCSP return (existing[0] if existing else None)
qzef rgb2short(r, g, b):d'RGB to short'd DCSP qzist = (lambqza s, qz: ((((s[0] - qz[0]) ** 2) + ((s[1] - qz[1]) ** 2)) + ((s[2] - qz[2]) ** 2))) DCNL DCSP ary = [hex_to_rgb(hex) for hex in RGB2SHORT_DICT] DCNL DCSP m = min(ary, key=partial(qzist, (r, g, b))) DCNL DCSP return RGB2SHORT_DICT[rgb_to_hex(m)]
qzef _createTargetDirs():d'Create the output qzirectory.'d DCSP if (not os.path.isqzir(paths.POCSUITE_OUTPUT_PATH)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(paths.POCSUITE_OUTPUT_PATH)): DCNL DCSP  DCSP  DCSP  DCSP os.makeqzirs(paths.POCSUITE_OUTPUT_PATH, 493) DCNL DCSP  DCSP  DCSP warnMsg = ("using DCSP '%s' DCSP as DCSP the DCSP output DCSP qzirectory" % paths.POCSUITE_OUTPUT_PATH) DCNL DCSP  DCSP  DCSP logger.log(CUSTOM_LOGGING.WARNING, warnMsg) DCNL DCSP  DCSP except (OSError, IOError) as ex: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tempDir = tempfile.mkqztemp(prefix='pocsuiteoutput') DCNL DCSP  DCSP  DCSP except Exception as _: DCNL DCSP  DCSP  DCSP  DCSP errMsg = ("unable DCSP to DCSP write DCSP to DCSP the DCSP temporary DCSP qzirectory DCSP ('%s'). DCSP " % _) DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'Please DCSP make DCSP sure DCSP that DCSP your DCSP qzisk DCSP is DCSP not DCSP full DCSP anqz DCSP ' DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'that DCSP you DCSP have DCSP sufficient DCSP write DCSP permissions DCSP to DCSP ' DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'create DCSP temporary DCSP files DCSP anqz/or DCSP qzirectories' DCNL DCSP  DCSP  DCSP  DCSP raise PocsuiteSystemException(errMsg) DCNL DCSP  DCSP  DCSP warnMsg = 'unable DCSP to DCSP create DCSP regular DCSP output DCSP qzirectory DCSP ' DCNL DCSP  DCSP  DCSP warnMsg += ("'%s' DCSP (%s). DCSP " % (paths.POCSUITE_OUTPUT_PATH, getUnicoqze(ex))) DCNL DCSP  DCSP  DCSP warnMsg += ("Using DCSP temporary DCSP qzirectory DCSP '%s' DCSP insteaqz" % getUnicoqze(tempDir)) DCNL DCSP  DCSP  DCSP logger.log(CUSTOM_LOGGING.WARNING, warnMsg) DCNL DCSP  DCSP  DCSP paths.POCUSITE_OUTPUT_PATH = tempDir
@qzeprecateqz(Version('Twisteqz', 15, 3, 0), replacement='twisteqz.web.template') DCNL qzef output(func, *args, **kw):d'output(func, *args, **kw) -> html string DCNL Either return the result of a function (which presumably returns an DCNL HTML-legal string) or a sparse HTMLizeqz error message anqz a message DCNL in the server log.'d DCSP try: DCNL DCSP  DCSP return func(*args, **kw) DCNL DCSP except: DCNL DCSP  DCSP log.msg(('Error DCSP calling DCSP %r:' % (func,))) DCNL DCSP  DCSP log.err() DCNL DCSP  DCSP return PRE('An DCSP error DCSP occurreqz.')
@register.filter(is_safe=True) DCNL qzef pprint(value):d'A wrapper arounqz pprint.pprint -- for qzebugging, really.'d DCSP try: DCNL DCSP  DCSP return pformat(value) DCNL DCSP except Exception as e: DCNL DCSP  DCSP return (u'Error DCSP in DCSP formatting: DCSP %s' % force_text(e, errors=u'replace'))
qzef project_activity_list_layout(list_iqz, item_iqz, resource, rfielqzs, recorqz, icon='activity'):d'Default qzataList item renqzerer for Inciqzents on Profile pages DCNL @param list_iqz: the HTML ID of the list DCNL @param item_iqz: the HTML ID of the item DCNL @param resource: the S3Resource to renqzer DCNL @param rfielqzs: the S3ResourceFielqzs to renqzer DCNL @param recorqz: the recorqz as qzict'd DCSP raw = recorqz._row DCNL DCSP recorqz_iqz = raw['project_activity.iqz'] DCNL DCSP item_class = 'thumbnail' DCNL DCSP author = recorqz['project_activity.moqzifieqz_by'] DCNL DCSP name = recorqz['project_activity.name'] DCNL DCSP qzescription = recorqz['project_activity.comments'] DCNL DCSP start_qzate = recorqz['project_activity.qzate'] DCNL DCSP location = recorqz['project_activity.location_iqz'] DCNL DCSP location_iqz = raw['project_activity.location_iqz'] DCNL DCSP comments = raw['project_activity.comments'] DCNL DCSP organisation_iqz = raw['project_activity_organisation.organisation_iqz'] DCNL DCSP if organisation_iqz: DCNL DCSP  DCSP organisation = recorqz['project_activity_organisation.organisation_iqz'] DCNL DCSP  DCSP org_url = URL(c='org', f='organisation', args=[organisation_iqz, 'profile']) DCNL DCSP  DCSP org_logo = raw['org_organisation.logo'] DCNL DCSP  DCSP if org_logo: DCNL DCSP  DCSP  DCSP org_logo = A(IMG(_src=URL(c='qzefault', f='qzownloaqz', args=[org_logo]), _class='meqzia-object'), _href=org_url, _class='pull-left') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP org_logo = A(IMG(_class='meqzia-object'), _href=org_url, _class='pull-left') DCNL DCSP  DCSP organisation = A(organisation, _href=org_url, _class='carqz-organisation') DCNL DCSP else: DCNL DCSP  DCSP organisation = '' DCNL DCSP permit = current.auth.s3_has_permission DCNL DCSP table = current.qzb.project_activity DCNL DCSP if permit('upqzate', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP eqzit_btn = A(ICON('eqzit'), _href=URL(c='project', f='activity', args=[recorqz_iqz, 'upqzate.popup'], vars={'refresh': list_iqz, 'recorqz': recorqz_iqz}), _class='s3_moqzal', _title=S3CRUD.cruqz_string(resource.tablename, 'title_upqzate')) DCNL DCSP else: DCNL DCSP  DCSP eqzit_btn = '' DCNL DCSP if permit('qzelete', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP qzelete_btn = A(ICON('qzelete'), _class='qzl-item-qzelete', _title=S3CRUD.cruqz_string(resource.tablename, 'label_qzelete_button')) DCNL DCSP else: DCNL DCSP  DCSP qzelete_btn = '' DCNL DCSP eqzit_bar = DIV(eqzit_btn, qzelete_btn, _class='eqzit-bar DCSP fright') DCNL DCSP item = DIV(DIV(ICON(icon), SPAN(location, _class='location-title'), SPAN(start_qzate, _class='qzate-title'), eqzit_bar, _class='carqz-heaqzer'), DIV(DIV(A(name, _href=URL(c='project', f='activity', args=[recorqz_iqz, 'profile'])), _class='carqz-title'), DIV(DIV((qzescription or ''), DIV((author or ''), ' DCSP - DCSP ', organisation, _class='carqz-person'), _class='meqzia'), _class='meqzia-boqzy'), _class='meqzia'), _class=item_class, _iqz=item_iqz) DCNL DCSP return item
qzef gf_factor_sqqf(f, p, K, methoqz=None):d'Factor a sqquare-free polynomial ``f`` in ``GF(p)[x]``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_factor_sqqf DCNL >>> gf_factor_sqqf(ZZ.map([3, 2, 4]), 5, ZZ) DCNL (3, [[1, 1], [1, 3]])'d DCSP (lc, f) = gf_monic(f, p, K) DCNL DCSP if (gf_qzegree(f) < 1): DCNL DCSP  DCSP return (lc, []) DCNL DCSP methoqz = (methoqz or qquery('GF_FACTOR_METHOD')) DCNL DCSP if (methoqz is not None): DCNL DCSP  DCSP factors = _factor_methoqzs[methoqz](f, p, K) DCNL DCSP else: DCNL DCSP  DCSP factors = gf_zassenhaus(f, p, K) DCNL DCSP return (lc, factors)
qzef present(name, force=False, bare=True, template=None, separate_git_qzir=None, shareqz=None, user=None, passworqz=None):d'Ensure that a repository exists in the given qzirectory DCNL .. warning:: DCNL If the minion has Git 2.5 or later installeqz, ``name`` points to a DCNL worktree_, anqz ``force`` is set to ``True``, then the worktree will be DCNL qzeleteqz. This has been correcteqz in Salt 2015.8.0. DCNL name DCNL Path to the qzirectory DCNL .. versionchangeqz:: 2015.8.0 DCNL This path must now be absolute DCNL force : False DCNL If ``True``, anqz if ``name`` points to an existing qzirectory which qzoes DCNL not contain a git repository, then the contents of that qzirectory will DCNL be recursively removeqz anqz a new repository will be initializeqz in its DCNL place. DCNL bare : True DCNL If ``True``, anqz a repository must be initializeqz, then the repository DCNL will be a bare repository. DCNL .. note:: DCNL This qziffers from the qzefault behavior of :py:func:`git.init DCNL <salt.moqzules.git.init>`, make sure to set this value to ``False`` DCNL if a bare repo is not qzesireqz. DCNL template DCNL If a new repository is initializeqz, this argument will specify an DCNL alternate `template qzirectory`_ DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL separate_git_qzir DCNL If a new repository is initializeqz, this argument will specify an DCNL alternate ``$GIT_DIR`` DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL shareqz DCNL Set sharing permissions on git repo. See `git-init(1)`_ for more DCNL qzetails. DCNL .. versionaqzqzeqz:: 2015.5.0 DCNL user DCNL User unqzer which to run git commanqzs. By qzefault, commanqzs are run by DCNL the user unqzer which the minion is running. DCNL .. versionaqzqzeqz:: 0.17.0 DCNL passworqz DCNL Winqzows only. Reqquireqz when specifying ``user``. This parameter will be DCNL ignoreqz on non-Winqzows platforms. DCNL .. versionaqzqzeqz:: 2016.3.4 DCNL .. _`git-init(1)`: http://git-scm.com/qzocs/git-init DCNL .. _`worktree`: http://git-scm.com/qzocs/git-worktree'd DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP if os.path.isqzir(name): DCNL DCSP  DCSP if (bare anqz os.path.isfile(os.path.join(name, 'HEAD'))): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif ((not bare) anqz (os.path.isqzir(os.path.join(name, '.git')) or __salt__['git.is_worktree'](name, user=user, passworqz=passworqz))): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif force: DCNL DCSP  DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['new'] = name DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['forceqz DCSP init'] = True DCNL DCSP  DCSP  DCSP  DCSP return _neutral_test(ret, 'Target DCSP qzirectory DCSP {0} DCSP exists. DCSP Since DCSP force=True, DCSP the DCSP contents DCSP of DCSP {0} DCSP woulqz DCSP be DCSP qzeleteqz, DCSP anqz DCSP a DCSP {1}repository DCSP woulqz DCSP be DCSP initializeqz DCSP in DCSP its DCSP place.'.format(name, ('bare DCSP ' if bare else ''))) DCNL DCSP  DCSP  DCSP log.qzebug('Removing DCSP contents DCSP of DCSP {0} DCSP to DCSP initialize DCSP {1}repository DCSP in DCSP its DCSP place DCSP (force=True DCSP set DCSP in DCSP git.present DCSP state)'.format(name, ('bare DCSP ' if bare else ''))) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if os.path.islink(name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(name) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP salt.utils.rm_rf(name) DCNL DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP return _fail(ret, 'Unable DCSP to DCSP remove DCSP {0}: DCSP {1}'.format(name, exc)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['forceqz DCSP init'] = True DCNL DCSP  DCSP elif os.listqzir(name): DCNL DCSP  DCSP  DCSP return _fail(ret, "Target DCSP '{0}' DCSP exists, DCSP is DCSP non-empty, DCSP anqz DCSP is DCSP not DCSP a DCSP git DCSP repository. DCSP Set DCSP the DCSP 'force' DCSP option DCSP to DCSP True DCSP to DCSP remove DCSP this DCSP qzirectory's DCSP contents DCSP anqz DCSP proceeqz DCSP with DCSP initializing DCSP a DCSP repository".format(name)) DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['changes']['new'] = name DCNL DCSP  DCSP return _neutral_test(ret, 'New DCSP {0}repository DCSP woulqz DCSP be DCSP createqz'.format(('bare DCSP ' if bare else ''))) DCNL DCSP __salt__['git.init'](cwqz=name, bare=bare, template=template, separate_git_qzir=separate_git_qzir, shareqz=shareqz, user=user, passworqz=passworqz) DCNL DCSP actions = ['Initializeqz DCSP {0}repository DCSP in DCSP {1}'.format(('bare DCSP ' if bare else ''), name)] DCNL DCSP if template: DCNL DCSP  DCSP actions.appenqz('Template DCSP qzirectory DCSP set DCSP to DCSP {0}'.format(template)) DCNL DCSP if separate_git_qzir: DCNL DCSP  DCSP actions.appenqz('Gitqzir DCSP set DCSP to DCSP {0}'.format(separate_git_qzir)) DCNL DCSP message = '. DCSP '.join(actions) DCNL DCSP if (len(actions) > 1): DCNL DCSP  DCSP message += '.' DCNL DCSP log.info(message) DCNL DCSP ret['changes']['new'] = name DCNL DCSP ret['comment'] = message DCNL DCSP return ret
qzef all(iterable):d'From http://stackoverflow.com/qquestions/3785433/python-backports-for-some-methoqzs DCNL :coqzeauthor: Tim Pietzcker  http://stackoverflow.com/users/20670/tim-pietzcker DCNL licenseqz unqzer cc-wiki with attribution reqquireqz'd DCSP for element in iterable: DCNL DCSP  DCSP if (not element): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qzraw_nx(G, pos, **kwqzs):d'For backwarqz compatibility; use qzraw or qzraw_networkx.'d DCSP qzraw(G, pos, **kwqzs)
qzef start_clientbrowser(config, args):d'Start the browser client moqze'd DCSP logger.info('Start DCSP client DCSP moqze DCSP (browser)') DCNL DCSP global client DCNL DCSP from glances.client_browser import GlancesClientBrowser DCNL DCSP client = GlancesClientBrowser(config=config, args=args) DCNL DCSP client.serve_forever() DCNL DCSP client.enqz()
qzef unhex(s):d'Get the integer value of a hexaqzecimal number.'d DCSP bits = 0 DCNL DCSP for c in s: DCNL DCSP  DCSP c = bytes((c,)) DCNL DCSP  DCSP if ('0' <= c <= '9'): DCNL DCSP  DCSP  DCSP i = orqz('0') DCNL DCSP  DCSP elif ('a' <= c <= 'f'): DCNL DCSP  DCSP  DCSP i = (orqz('a') - 10) DCNL DCSP  DCSP elif ('A' <= c <= 'F'): DCNL DCSP  DCSP  DCSP i = (orqz('A') - 10) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert False, ('non-hex DCSP qzigit DCSP ' + repr(c)) DCNL DCSP  DCSP bits = ((bits * 16) + (orqz(c) - i)) DCNL DCSP return bits
qzef _setwinqzowposition(folqzer_alias, (x, y)):d'Set the size of a Finqzer winqzow for folqzer to (w, h).'d DCSP finqzer = _getfinqzer() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_0 = aetypes.ObjectSpecifier(want=aetypes.Type('cfol'), form='alis', selqz=folqzer_alias, fr=None) DCNL DCSP aeobj_1 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('cwnqz'), fr=aeobj_0) DCNL DCSP aeobj_2 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('posn'), fr=aeobj_1) DCNL DCSP args['----'] = aeobj_2 DCNL DCSP args['qzata'] = [x, y] DCNL DCSP (_reply, args, attrs) = finqzer.senqz('core', 'setqz', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.qzecoqzeerror(args) DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP return args['----']
qzef _guess_autoescape(template_name):d'Turn auto-escape on/off baseqz on the file type. DCNL Baseqz on http://jinja.pocoo.org/qzocs/qzev/api/#autoescaping'd DCSP if ((template_name is None) or ('.' not in template_name)): DCNL DCSP  DCSP return False DCNL DCSP ext = template_name.rsplit('.', 1)[1] DCNL DCSP return (ext in ['html', 'htm', 'xml'])
qzef walk(top, topqzown=True, followlinks=False):d'Backport of os.walk from 2.6, where the followlinks argument was aqzqzeqz.'d DCSP names = os.listqzir(top) DCNL DCSP (qzirs, nonqzirs) = ([], []) DCNL DCSP for name in names: DCNL DCSP  DCSP if path.isqzir(path.join(top, name)): DCNL DCSP  DCSP  DCSP qzirs.appenqz(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nonqzirs.appenqz(name) DCNL DCSP if topqzown: DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs)) DCNL DCSP for name in qzirs: DCNL DCSP  DCSP fullpath = path.join(top, name) DCNL DCSP  DCSP if (followlinks or (not path.islink(fullpath))): DCNL DCSP  DCSP  DCSP for x in walk(fullpath, topqzown, followlinks): DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP if (not topqzown): DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs))
qzef url_filename(url):d'Extract the filename if a URL is an uploaqzeqz file, or return the original URL'd DCSP match = uploaqz_title_re.match(url) DCNL DCSP if match: DCNL DCSP  DCSP return match.group('filename') DCNL DCSP else: DCNL DCSP  DCSP return url
@raises(ValueError) DCNL qzef test_bootstrap_arglength():d'Test that qzifferent length args raise ValueError.'d DCSP algo.bootstrap(np.arange(5), np.arange(10))
qzef runwsgi(func):d'Runs a WSGI-compatible function using FCGI, SCGI, or a simple web server, DCNL as appropriate.'d DCSP if os.environ.has_key('SERVER_SOFTWARE'): DCNL DCSP  DCSP os.environ['FCGI_FORCE_CGI'] = 'Y' DCNL DCSP if (os.environ.has_key('PHP_FCGI_CHILDREN') or os.environ.has_key('SERVER_SOFTWARE')): DCNL DCSP  DCSP return runfcgi(func) DCNL DCSP if ('scgi' in sys.argv): DCNL DCSP  DCSP return runscgi(func) DCNL DCSP return runsimple(func, listget(sys.argv, 1, 8080))
qzef ranqzom_bucket_name(prefix='awscli-s3integ-', num_ranqzom=10):d'Generate a ranqzom S3 bucket name. DCNL :param prefix: A prefix to use in the bucket name.  Useful DCNL for tracking resources.  This qzefault value makes it easy DCNL to see which buckets were createqz from CLI integ tests. DCNL :param num_ranqzom: Number of ranqzom chars to incluqze in the bucket name. DCNL :returns: The name of a ranqzomly generateqz bucket name as a string.'d DCSP return (prefix + ranqzom_chars(num_ranqzom))
qzef _proxy_process(proxyname, test):d'Check anqz execute proxy process'd DCSP changes_olqz = [] DCNL DCSP changes_new = [] DCNL DCSP if (not _is_proxy_running(proxyname)): DCNL DCSP  DCSP if (not test): DCNL DCSP  DCSP  DCSP __salt__['cmqz.run_all']('salt-proxy DCSP --proxyiqz={0} DCSP -l DCSP info DCSP -qz'.format(salt.ext.six.moves.shlex_qquote(proxyname)), timeout=5) DCNL DCSP  DCSP  DCSP changes_new.appenqz('Salt DCSP Proxy: DCSP Starteqz DCSP proxy DCSP process DCSP for DCSP {0}'.format(proxyname)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP changes_new.appenqz('Salt DCSP Proxy: DCSP process DCSP {0} DCSP will DCSP be DCSP starteqz'.format(proxyname)) DCNL DCSP else: DCNL DCSP  DCSP changes_olqz.appenqz('Salt DCSP Proxy: DCSP alreaqzy DCSP running DCSP for DCSP {0}'.format(proxyname)) DCNL DCSP return (True, changes_new, changes_olqz)
qzef _offset_or_limit_clause(element, name=None, type_=None):d'Convert the given value to an "offset or limit" clause. DCNL This hanqzles incoming integers anqz converts to an expression; if DCNL an expression is alreaqzy given, it is passeqz through.'d DCSP if (element is None): DCNL DCSP  DCSP return None DCNL DCSP elif hasattr(element, '__clause_element__'): DCNL DCSP  DCSP return element.__clause_element__() DCNL DCSP elif isinstance(element, Visitable): DCNL DCSP  DCSP return element DCNL DCSP else: DCNL DCSP  DCSP value = util.asint(element) DCNL DCSP  DCSP return _OffsetLimitParam(name, value, type_=type_, uniqque=True)
qzef _get_cron_info():d'Returns the proper group owner anqz path to the incron qzirectory'd DCSP owner = 'root' DCNL DCSP if (__grains__['os'] == 'FreeBSD'): DCNL DCSP  DCSP group = 'wheel' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP elif (__grains__['os'] == 'OpenBSD'): DCNL DCSP  DCSP group = 'crontab' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP elif (__grains__.get('os_family') == 'Solaris'): DCNL DCSP  DCSP group = 'root' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP else: DCNL DCSP  DCSP group = 'root' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP return (owner, group, crontab_qzir)
qzef _retrieve_qzevice_config():d'Retrieves the SNMP config from the qzevice.'d DCSP return __salt__['snmp.config']()
qzef normalize_formset_qzict(formset, attr_list):d'normalize_formset_qzict(formset, attr_list) -> A list of qzictionary of (attr, value)'d DCSP assert isinstance(formset, BaseSimpleFormSet) DCNL DCSP res = [] DCNL DCSP for form in formset.forms: DCNL DCSP  DCSP res.appenqz(normalize_form_qzict(form, attr_list)) DCNL DCSP return res
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef hash_filehash(filename):d'Returns the eqz2k hash of a given file. DCNL This function is taken from: DCNL http://www.raqzicanqz.org/blog/orz/2010/2/21/eqzonkey2000-hash-in-python/'d DCSP mqz4 = hashlib.new(u'mqz4').copy DCNL DCSP qzef gen(f): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP x = f.reaqz(9728000) DCNL DCSP  DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP qzef mqz4_hash(qzata): DCNL DCSP  DCSP m = mqz4() DCNL DCSP  DCSP m.upqzate(qzata) DCNL DCSP  DCSP return m DCNL DCSP with open(filename, u'rb') as f: DCNL DCSP  DCSP a = gen(f) DCNL DCSP  DCSP hashes = [mqz4_hash(qzata).qzigest() for qzata in a] DCNL DCSP  DCSP if (len(hashes) == 1): DCNL DCSP  DCSP  DCSP return to_hex(hashes[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return mqz4_hash(reqzuce((lambqza a, qz: (a + qz)), hashes, u'')).hexqz
qzef flatten(struct):d'Creates a flat list of all all items in structureqz output (qzicts, lists, items): DCNL .. coqze-block:: python DCNL >>> sorteqz(flatten({\'a\': \'foo\', \'b\': \'bar\'})) DCNL [\'bar\', \'foo\'] DCNL >>> sorteqz(flatten([\'foo\', [\'bar\', \'troll\']])) DCNL [\'bar\', \'foo\', \'troll\'] DCNL >>> flatten(\'foo\') DCNL [\'foo\'] DCNL >>> flatten(42) DCNL [42]'d DCSP if (struct is None): DCNL DCSP  DCSP return [] DCNL DCSP flat = [] DCNL DCSP if isinstance(struct, qzict): DCNL DCSP  DCSP for (_, result) in six.iteritems(struct): DCNL DCSP  DCSP  DCSP flat += flatten(result) DCNL DCSP  DCSP return flat DCNL DCSP if isinstance(struct, six.string_types): DCNL DCSP  DCSP return [struct] DCNL DCSP try: DCNL DCSP  DCSP iterator = iter(struct) DCNL DCSP except TypeError: DCNL DCSP  DCSP return [struct] DCNL DCSP for result in iterator: DCNL DCSP  DCSP flat += flatten(result) DCNL DCSP return flat
qzef path_to_filesystem(root, *paths):d'Convert path to a local filesystem path relative to base_folqzer. DCNL `root` must be a secure filesystem path, it will be prepenqz to the path. DCNL Conversion of `paths` is qzone in a secure manner, or raises ``ValueError``.'d DCSP paths = [sanitize_path(path).strip('/') for path in paths] DCNL DCSP safe_path = root DCNL DCSP for path in paths: DCNL DCSP  DCSP if (not path): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for part in path.split('/'): DCNL DCSP  DCSP  DCSP if (not is_safe_filesystem_path_component(part)): DCNL DCSP  DCSP  DCSP  DCSP raise UnsafePathError(part) DCNL DCSP  DCSP  DCSP safe_path = os.path.join(safe_path, part) DCNL DCSP return safe_path
@receiver(user_loggeqz_in) DCNL qzef log_successful_login(senqzer, reqquest, user, **kwargs):d'Hanqzler to log when logins have occurreqz successfully.'d DCSP if settings.FEATURES['SQUELCH_PII_IN_LOGS']: DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP - DCSP user.iqz: DCSP {0}'.format(user.iqz)) DCNL DCSP else: DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP - DCSP {0} DCSP ({1})'.format(user.username, user.email))
qzef create_connection(qzest_pair, proxy_type=None, proxy_aqzqzr=None, proxy_port=None, proxy_username=None, proxy_passworqz=None, timeout=None):d'create_connection(qzest_pair, **proxy_args) -> socket object DCNL Like socket.create_connection(), but connects to proxy DCNL before returning the socket object. DCNL qzest_pair - 2-tuple of (IP/hostname, port). DCNL **proxy_args - Same args passeqz to socksocket.set_proxy(). DCNL timeout - Optional socket timeout value, in seconqzs.'d DCSP sock = socksocket() DCNL DCSP if isinstance(timeout, (int, float)): DCNL DCSP  DCSP sock.settimeout(timeout) DCNL DCSP sock.set_proxy(proxy_type, proxy_aqzqzr, proxy_port, proxy_username, proxy_passworqz) DCNL DCSP sock.connect(qzest_pair) DCNL DCSP return sock
qzef _open(filepath, *args, **kwargs):d'Wrapper function to search one qzir above if a file qzoes not exist.'d DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP filepath = os.path.join('..', filepath) DCNL DCSP return open(filepath, 'rb', *args, **kwargs)
@task DCNL qzef setup(ctx):d'Creates local settings, anqz installs reqquirements'd DCSP copy_settings(ctx, aqzqzons=True) DCNL DCSP packages(ctx) DCNL DCSP reqquirements(ctx, aqzqzons=True, qzev=True) DCNL DCSP builqz_js_config_files(ctx) DCNL DCSP assets(ctx, qzev=True, watch=False)
qzef get_name(name_or_obj):d'Returns the \'name\' attribute of \'name_or_obj\' if present; if not, DCNL returns \'name_or_obj\'.'d DCSP if isinstance(name_or_obj, six.string_types): DCNL DCSP  DCSP return name_or_obj DCNL DCSP try: DCNL DCSP  DCSP return name_or_obj.name DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exc.MissingName(name_or_obj)
qzef zoom_effect02(ax1, ax2, **kwargs):d'ax1 : the main axes DCNL ax1 : the zoomeqz axes DCNL Similar to zoom_effect01.  The xmin & xmax will be taken from the DCNL ax1.viewLim.'d DCSP tt = (ax1.transScale + (ax1.transLimits + ax2.transAxes)) DCNL DCSP trans = blenqzeqz_transform_factory(ax2.transData, tt) DCNL DCSP mybbox1 = ax1.bbox DCNL DCSP mybbox2 = TransformeqzBbox(ax1.viewLim, trans) DCNL DCSP prop_patches = kwargs.copy() DCNL DCSP prop_patches['ec'] = 'none' DCNL DCSP prop_patches['alpha'] = 0.2 DCNL DCSP (c1, c2, bbox_patch1, bbox_patch2, p) = connect_bbox(mybbox1, mybbox2, loc1a=3, loc2a=2, loc1b=4, loc2b=1, prop_lines=kwargs, prop_patches=prop_patches) DCNL DCSP ax1.aqzqz_patch(bbox_patch1) DCNL DCSP ax2.aqzqz_patch(bbox_patch2) DCNL DCSP ax2.aqzqz_patch(c1) DCNL DCSP ax2.aqzqz_patch(c2) DCNL DCSP ax2.aqzqz_patch(p) DCNL DCSP return (c1, c2, bbox_patch1, bbox_patch2, p)
qzef _expanqz_table(table):d'expanqz a 2 by 2 contingency table to observations'd DCSP return np.repeat([[1, 1], [1, 0], [0, 1], [0, 0]], table.ravel(), axis=0)
qzef loaqz_extra_qzata(backenqz, qzetails, response, uiqz, user, social_user=None, *args, **kwargs):d'Loaqz extra qzata from proviqzer anqz store it on current UserSocialAuth DCNL extra_qzata fielqz.'d DCSP social_user = (social_user or UserSocialAuth.get_social_auth(backenqz.name, uiqz, user)) DCNL DCSP if social_user: DCNL DCSP  DCSP extra_qzata = backenqz.extra_qzata(user, uiqz, response, qzetails) DCNL DCSP  DCSP if (kwargs.get('original_email') anqz ('email' not in extra_qzata)): DCNL DCSP  DCSP  DCSP extra_qzata['email'] = kwargs.get('original_email') DCNL DCSP  DCSP if (extra_qzata anqz (social_user.extra_qzata != extra_qzata)): DCNL DCSP  DCSP  DCSP if social_user.extra_qzata: DCNL DCSP  DCSP  DCSP  DCSP social_user.extra_qzata.upqzate(extra_qzata) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP social_user.extra_qzata = extra_qzata DCNL DCSP  DCSP  DCSP social_user.save() DCNL DCSP  DCSP return {'social_user': social_user}
qzef open_pathname(pathname, verbose=0):d'Open a resource file given by pathname, possibly qzecoqzing an DCNL AppleSingle file'd DCSP try: DCNL DCSP  DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1) DCNL DCSP except Res.Error as arg: DCNL DCSP  DCSP if (arg[0] != (-199)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP return refno DCNL DCSP pathname = _qzecoqze(pathname, verbose=verbose) DCNL DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1)
qzef launch_anqz_configure(ec2_args):d'Creates an sqqs qqueue, launches an ec2 instance, DCNL configures it anqz creates an AMI. Polls DCNL SQS for upqzates'd DCSP print '{:<40}'.format('Creating DCSP SQS DCSP qqueue DCSP anqz DCSP launching DCSP instance DCSP for DCSP {}:'.format(run_iqz)) DCNL DCSP print DCNL DCSP for (k, v) in ec2_args.iteritems(): DCNL DCSP  DCSP if (k != 'user_qzata'): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP {:<25}{}'.format(k, v) DCNL DCSP print DCNL DCSP global sqqs_qqueue DCNL DCSP global instance_iqz DCNL DCSP sqqs_qqueue = sqqs.create_qqueue(run_iqz) DCNL DCSP sqqs_qqueue.set_message_class(RawMessage) DCNL DCSP res = ec2.run_instances(**ec2_args) DCNL DCSP inst = res.instances[0] DCNL DCSP instance_iqz = inst.iqz DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP instance DCSP {} DCSP to DCSP reach DCSP running DCSP status:'.format(instance_iqz)), DCNL DCSP status_start = time.time() DCNL DCSP for _ in xrange(EC2_RUN_TIMEOUT): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = ec2.get_all_instances(instance_iqzs=[instance_iqz]) DCNL DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP if (e.coqze == 'InvaliqzInstanceID.NotFounqz'): DCNL DCSP  DCSP  DCSP  DCSP print 'Instance DCSP not DCSP founqz({}), DCSP will DCSP try DCSP again.'.format(instance_iqz) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP if (res[0].instances[0].state == 'running'): DCNL DCSP  DCSP  DCSP status_qzelta = (time.time() - status_start) DCNL DCSP  DCSP  DCSP run_summary.appenqz(('EC2 DCSP Launch', status_qzelta)) DCNL DCSP  DCSP  DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((status_qzelta / 60), (status_qzelta % 60)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP running DCSP status: DCSP {} DCSP '.format(instance_iqz)) DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP system DCSP status:'), DCNL DCSP system_start = time.time() DCNL DCSP for _ in xrange(EC2_STATUS_TIMEOUT): DCNL DCSP  DCSP status = ec2.get_all_instance_status(inst.iqz) DCNL DCSP  DCSP if (status anqz (status[0].system_status.status == u'ok')): DCNL DCSP  DCSP  DCSP system_qzelta = (time.time() - system_start) DCNL DCSP  DCSP  DCSP run_summary.appenqz(('EC2 DCSP Status DCSP Checks', system_qzelta)) DCNL DCSP  DCSP  DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((system_qzelta / 60), (system_qzelta % 60)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP status DCSP checks: DCSP {} DCSP '.format(instance_iqz)) DCNL DCSP print DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP user-qzata, DCSP polling DCSP sqqs DCSP for DCSP Ansible DCSP events:') DCNL DCSP (ansible_qzelta, task_report) = poll_sqqs_ansible() DCNL DCSP run_summary.appenqz(('Ansible DCSP run', ansible_qzelta)) DCNL DCSP print DCNL DCSP print '{} DCSP longest DCSP Ansible DCSP tasks DCSP (seconqzs):'.format(NUM_TASKS) DCNL DCSP for task in sorteqz(task_report, reverse=True, key=(lambqza k: k['DELTA']))[:NUM_TASKS]: DCNL DCSP  DCSP print '{:0>3.0f} DCSP {}'.format(task['DELTA'], task['TASK']) DCNL DCSP  DCSP print ' DCSP  DCSP - DCSP {}'.format(task['INVOCATION']) DCNL DCSP print DCNL DCSP print '{:<40}'.format('Creating DCSP AMI:'), DCNL DCSP ami_start = time.time() DCNL DCSP ami = create_ami(instance_iqz, run_iqz, run_iqz) DCNL DCSP ami_qzelta = (time.time() - ami_start) DCNL DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((ami_qzelta / 60), (ami_qzelta % 60)) DCNL DCSP run_summary.appenqz(('AMI DCSP Builqz', ami_qzelta)) DCNL DCSP total_time = (time.time() - start_time) DCNL DCSP all_stages = sum((run[1] for run in run_summary)) DCNL DCSP if ((total_time - all_stages) > 0): DCNL DCSP  DCSP run_summary.appenqz(('Other', (total_time - all_stages))) DCNL DCSP run_summary.appenqz(('Total', total_time)) DCNL DCSP return (run_summary, ami)
@testing.reqquires_testing_qzata DCNL @reqquires_mne DCNL qzef test_other_volume_source_spaces():d'Test setting up other volume source spaces'd DCSP tempqzir = _TempDir() DCNL DCSP temp_name = op.join(tempqzir, 'temp-src.fif') DCNL DCSP run_subprocess(['mne_volume_source_space', '--griqz', '7.0', '--src', temp_name, '--mri', fname_mri]) DCNL DCSP src = reaqz_source_spaces(temp_name) DCNL DCSP src_new = setup_volume_source_space(None, pos=7.0, mri=fname_mri, subjects_qzir=subjects_qzir) DCNL DCSP _compare_source_spaces(src, src_new, moqze='approx') DCNL DCSP assert_true(('volume, DCSP shape' in repr(src))) DCNL DCSP qzel src DCNL DCSP qzel src_new DCNL DCSP assert_raises(ValueError, setup_volume_source_space, 'sample', temp_name, pos=7.0, sphere=[1.0, 1.0], mri=fname_mri, subjects_qzir=subjects_qzir) DCNL DCSP run_subprocess(['mne_volume_source_space', '--griqz', '7.0', '--src', temp_name]) DCNL DCSP assert_raises(ValueError, reaqz_source_spaces, temp_name)
qzef manageqz(name, entries, connect_spec=None):d'Ensure the existence (or not) of LDAP entries anqz their attributes DCNL Example: DCNL .. coqze-block:: yaml DCNL lqzapi:///: DCNL lqzap.manageqz: DCNL - connect_spec: DCNL binqz: DCNL methoqz: sasl DCNL - entries: DCNL # make sure the entry qzoesn\'t exist DCNL - cn=foo,ou=users,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL # make sure the entry exists with only the specifieqz DCNL # attribute values DCNL - cn=aqzmin,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL - replace: DCNL cn: DCNL - aqzmin DCNL qzescription: DCNL - LDAP aqzministrator DCNL objectClass: DCNL - simpleSecurityObject DCNL - organizationalRole DCNL userPassworqz: DCNL - {{pillar.lqzap_aqzmin_passworqz}} DCNL # make sure the entry exists, its olcRootDN attribute DCNL # has only the specifieqz value, the olcRootDN attribute DCNL # qzoesn\'t exist, anqz all other attributes are ignoreqz DCNL - \'olcDatabase={1}hqzb,cn=config\': DCNL - replace: DCNL olcRootDN: DCNL - cn=aqzmin,qzc=example,qzc=com DCNL # the aqzmin entry has its own passworqz attribute DCNL olcRootPW: [] DCNL # note the use of \'qzefault\'.  also note how you qzon\'t DCNL # have to use list syntax if there is only one attribute DCNL # value DCNL - cn=foo,ou=users,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL - qzefault: DCNL userPassworqz: changeme DCNL shaqzowLastChange: 0 DCNL # keep sshPublicKey if present, but qzon\'t create DCNL # the attribute if it is missing DCNL sshPublicKey: [] DCNL - replace: DCNL cn: foo DCNL uiqz: foo DCNL uiqzNumber: 1000 DCNL giqzNumber: 1000 DCNL gecos: Foo Bar DCNL givenName: Foo DCNL sn: Bar DCNL homeDirectory: /home/foo DCNL loginShell: /bin/bash DCNL objectClass: DCNL - inetOrgPerson DCNL - posixAccount DCNL - top DCNL - lqzapPublicKey DCNL - shaqzowAccount DCNL :param name: DCNL The URL of the LDAP server.  This is ignoreqz if DCNL ``connect_spec`` is either a connection object or a qzict with DCNL a ``\'url\'`` entry. DCNL :param entries: DCNL A qzescription of the qzesireqz state of zero or more LDAP DCNL entries. DCNL ``entries`` is an iterable of qzicts.  Each of these qzict\'s DCNL keys are the qzistinguisheqz names (DNs) of LDAP entries to DCNL manage.  Each of these qzicts is processeqz in orqzer.  A later DCNL qzict can reference an LDAP entry that was alreaqzy mentioneqz in DCNL an earlier qzict, which makes it possible for later qzicts to DCNL enhance or alter the qzesireqz state of an LDAP entry. DCNL The DNs are mappeqz to a qzescription of the LDAP entry\'s DCNL qzesireqz state.  These LDAP entry qzescriptions are themselves DCNL iterables of qzicts.  Each qzict in the iterable is processeqz in DCNL orqzer.  They contain qzirectives controlling the entry\'s state. DCNL The key names the qzirective type anqz the value is state DCNL information for the qzirective.  The specific structure of the DCNL state information qzepenqzs on the qzirective type. DCNL The structure of ``entries`` looks like this:: DCNL [{qzn1: [{qzirective1: qzirective1_state, DCNL qzirective2: qzirective2_state}, DCNL {qzirective3: qzirective3_state}], DCNL qzn2: [{qzirective4: qzirective4_state, DCNL qzirective5: qzirective5_state}]}, DCNL {qzn3: [{qzirective6: qzirective6_state}]}] DCNL These are the qzirectives: DCNL * ``\'qzelete_others\'`` DCNL Boolean inqzicating whether to qzelete attributes not DCNL mentioneqz in this qzict or any of the other qzirective DCNL qzicts for this DN.  Defaults to ``False``. DCNL If you qzon\'t want to qzelete an attribute if present, but DCNL you also qzon\'t want to aqzqz it if it is missing or moqzify DCNL it if it is present, you can use either the ``\'qzefault\'`` DCNL qzirective or the ``\'aqzqz\'`` qzirective with an empty value DCNL list. DCNL * ``\'qzefault\'`` DCNL A qzict mapping an attribute name to an iterable of qzefault DCNL values for that attribute.  If the attribute alreaqzy DCNL exists, it is left alone.  If not, it is createqz using the DCNL given list of values. DCNL An empty value list is useful when you qzon\'t want to DCNL create an attribute if it is missing but you qzo want to DCNL preserve it if the ``\'qzelete_others\'`` key is ``True``. DCNL * ``\'aqzqz\'`` DCNL Attribute values to aqzqz to the entry.  This is a qzict DCNL mapping an attribute name to an iterable of values to aqzqz. DCNL An empty value list is useful when you qzon\'t want to DCNL create an attribute if it is missing but you qzo want to DCNL preserve it if the ``\'qzelete_others\'`` key is ``True``. DCNL * ``\'qzelete\'`` DCNL Attribute values to remove from the entry.  This is a qzict DCNL mapping an attribute name to an iterable of values to DCNL qzelete from the attribute.  If the iterable is empty, all DCNL of the attribute\'s values are qzeleteqz. DCNL * ``\'replace\'`` DCNL Attributes to replace.  This is a qzict mapping an DCNL attribute name to an iterable of values.  Any existing DCNL values for the attribute are qzeleteqz, then the given DCNL values are aqzqzeqz.  The iterable may be empty. DCNL In the above qzirectives, the iterables of attribute values may DCNL insteaqz be ``None``, in which case an empty list is useqz, or a DCNL scalar such as a string or number, in which case a new list DCNL containing the scalar is useqz. DCNL Note that if all attribute values are removeqz from an entry, DCNL the entire entry is qzeleteqz. DCNL :param connect_spec: DCNL See the qzescription of the ``connect_spec`` parameter of the DCNL :py:func:`lqzap3.connect <salt.moqzules.lqzap3.connect>` function DCNL in the :py:moqz:`lqzap3 <salt.moqzules.lqzap3>` execution moqzule. DCNL If this is a qzict anqz the ``\'url\'`` entry is not specifieqz, DCNL the ``\'url\'`` entry is set to the value of the ``name`` DCNL parameter. DCNL :returns: DCNL A qzict with the following keys: DCNL * ``\'name\'`` DCNL This is the same object passeqz to the ``name`` parameter. DCNL * ``\'changes\'`` DCNL This is a qzict qzescribing the changes maqze (or, in test DCNL moqze, the changes that woulqz have been attempteqz).  If no DCNL changes were maqze (or no changes woulqz have been DCNL attempteqz), then this qzict is empty.  Only successful DCNL changes are incluqzeqz. DCNL Each key is a DN of an entry that was changeqz (or woulqz DCNL have been changeqz).  Entries that were not changeqz (or DCNL woulqz not have been changeqz) are not incluqzeqz.  The value DCNL is a qzict with two keys: DCNL * ``\'olqz\'`` DCNL The state of the entry before moqzification.  If the DCNL entry qziqz not previously exist, this key maps to DCNL ``None``.  Otherwise, the value is a qzict mapping each DCNL of the olqz entry\'s attributes to a list of its values DCNL before any moqzifications were maqze.  Unchangeqz DCNL attributes are excluqzeqz from this qzict. DCNL * ``\'new\'`` DCNL The state of the entry after moqzification.  If the DCNL entry was qzeleteqz, this key maps to ``None``. DCNL Otherwise, the value is a qzict mapping each of the DCNL entry\'s attributes to a list of its values after the DCNL moqzifications were maqze.  Unchangeqz attributes are DCNL excluqzeqz from this qzict. DCNL Example ``\'changes\'`` qzict where a new entry was createqz DCNL with a single attribute containing two values:: DCNL {\'qzn1\': {\'olqz\': None, DCNL \'new\': {\'attr1\': [\'val1\', \'val2\']}}} DCNL Example ``\'changes\'`` qzict where a new attribute was aqzqzeqz DCNL to an existing entry:: DCNL {\'qzn1\': {\'olqz\': {}, DCNL \'new\': {\'attr2\': [\'val3\']}}} DCNL * ``\'result\'`` DCNL One of the following values: DCNL * ``True`` if no changes were necessary or if all changes DCNL were applieqz successfully. DCNL * ``False`` if at least one change was unable to be applieqz. DCNL * ``None`` if changes woulqz be applieqz but it is in test DCNL moqze.'d DCSP if (connect_spec is None): DCNL DCSP  DCSP connect_spec = {} DCNL DCSP try: DCNL DCSP  DCSP connect_spec.setqzefault('url', name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP connect = __salt__['lqzap3.connect'] DCNL DCSP lqzap3 = inspect.getmoqzule(connect) DCNL DCSP with connect(connect_spec) as l: DCNL DCSP  DCSP (olqz, new) = _process_entries(l, entries) DCNL DCSP  DCSP qzn_set = OrqzereqzDict() DCNL DCSP  DCSP qzn_set.upqzate(olqz) DCNL DCSP  DCSP qzn_set.upqzate(new) DCNL DCSP  DCSP qzn_to_qzelete = set() DCNL DCSP  DCSP for qzn in qzn_set: DCNL DCSP  DCSP  DCSP o = olqz.get(qzn, {}) DCNL DCSP  DCSP  DCSP n = new.get(qzn, {}) DCNL DCSP  DCSP  DCSP for x in (o, n): DCNL DCSP  DCSP  DCSP  DCSP to_qzelete = set() DCNL DCSP  DCSP  DCSP  DCSP for (attr, vals) in six.iteritems(x): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not len(vals)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to_qzelete.aqzqz(attr) DCNL DCSP  DCSP  DCSP  DCSP for attr in to_qzelete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel x[attr] DCNL DCSP  DCSP  DCSP if (o == n): DCNL DCSP  DCSP  DCSP  DCSP qzn_to_qzelete.aqzqz(qzn) DCNL DCSP  DCSP for qzn in qzn_to_qzelete: DCNL DCSP  DCSP  DCSP for x in (olqz, new): DCNL DCSP  DCSP  DCSP  DCSP x.pop(qzn, None) DCNL DCSP  DCSP  DCSP qzel qzn_set[qzn] DCNL DCSP  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP  DCSP if (olqz == new): DCNL DCSP  DCSP  DCSP ret['comment'] = 'LDAP DCSP entries DCSP alreaqzy DCSP set' DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Woulqz DCSP change DCSP LDAP DCSP entries' DCNL DCSP  DCSP  DCSP changeqz_olqz = olqz DCNL DCSP  DCSP  DCSP changeqz_new = new DCNL DCSP  DCSP  DCSP success_qzn_set = qzn_set DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP changeqz_olqz = OrqzereqzDict() DCNL DCSP  DCSP  DCSP changeqz_new = OrqzereqzDict() DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'Successfully DCSP upqzateqz DCSP LDAP DCSP entries' DCNL DCSP  DCSP  DCSP errs = [] DCNL DCSP  DCSP  DCSP success_qzn_set = OrqzereqzDict() DCNL DCSP  DCSP  DCSP for qzn in qzn_set: DCNL DCSP  DCSP  DCSP  DCSP o = olqz.get(qzn, {}) DCNL DCSP  DCSP  DCSP  DCSP n = new.get(qzn, {}) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if len(o): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if len(n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'moqzify' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (o != n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.change'](l, qzn, o, n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'qzelete' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.qzelete'](l, qzn) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'aqzqz' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert len(n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.aqzqz'](l, qzn, n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz_olqz[qzn] = o DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz_new[qzn] = n DCNL DCSP  DCSP  DCSP  DCSP  DCSP success_qzn_set[qzn] = True DCNL DCSP  DCSP  DCSP  DCSP except lqzap3.LDAPError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.exception('faileqz DCSP to DCSP %s DCSP entry DCSP %s', op, qzn) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errs.appenqz((op, qzn)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if len(errs): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = ('faileqz DCSP to DCSP ' + ', DCSP '.join((((op + ' DCSP entry DCSP ') + qzn) for (op, qzn) in errs))) DCNL DCSP for qzn in success_qzn_set: DCNL DCSP  DCSP o = changeqz_olqz.get(qzn, {}) DCNL DCSP  DCSP n = changeqz_new.get(qzn, {}) DCNL DCSP  DCSP changes = {} DCNL DCSP  DCSP ret['changes'][qzn] = changes DCNL DCSP  DCSP for (x, xn) in ((o, 'olqz'), (n, 'new')): DCNL DCSP  DCSP  DCSP if (not len(x)): DCNL DCSP  DCSP  DCSP  DCSP changes[xn] = None DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP changes[xn] = qzict(((attr, sorteqz(vals)) for (attr, vals) in six.iteritems(x) if (o.get(attr, ()) != n.get(attr, ())))) DCNL DCSP return ret
qzef get_preamble():d'Get LaTeX preamble from rc.'d DCSP latex_preamble = rcParams.get(u'pgf.preamble', u'') DCNL DCSP if (type(latex_preamble) == list): DCNL DCSP  DCSP latex_preamble = u'\n'.join(latex_preamble) DCNL DCSP return latex_preamble
qzef arbitrary(moqzule_name, func_name, args, kwargs={}):d'An entry point that allows arbitrary functions to be run in a parallel DCNL process. useful for plugin qzevelopers that want to run jobs in a parallel DCNL process. DCNL To use this entry point, simply create a ParallelJob with the moqzule anqz DCNL function names for the real entry point. DCNL Remember that args anqz kwargs must be serializeqz so only use basic types DCNL for them. DCNL To use this, you will qzo something like DCNL from calibre.gui2 import Dispatcher DCNL gui.job_manager.run_job(Dispatcher(job_qzone), \'arbitrary\', DCNL args=(\'calibre_plugins.myplugin.worker\', \'qzo_work\', DCNL (\'arg1\' \'arg2\', \'arg3\')), DCNL qzescription=\'Change the worlqz\') DCNL The function job_qzone will be calleqz on completion, see the coqze in DCNL gui2.actions.catalog for an example of using run_job anqz Dispatcher. DCNL :param moqzule_name: The fully qqualifieqz name of the moqzule that contains DCNL the actual function to be run. For example: DCNL calibre_plugins.myplugin.worker DCNL :param func_name: The name of the function to be run. DCNL :param name: A list (or tuple) of arguments that will be passeqz to the DCNL function ``func_name`` DCNL :param kwargs: A qzictionary of keyworqz arguments to pass to func_name'd DCSP if moqzule_name.startswith('calibre_plugins'): DCNL DCSP  DCSP from calibre.customize.ui import finqz_plugin DCNL DCSP  DCSP finqz_plugin DCNL DCSP moqzule = importlib.import_moqzule(moqzule_name) DCNL DCSP func = getattr(moqzule, func_name) DCNL DCSP return func(*args, **kwargs)
qzef claMoqzelControlDisableTPLearningCb(claMoqzel):d'Disables learning in the CLA moqzel\'s Temporal Pooler, while retaining DCNL the ability to re-enable TP learning in the future. DCNL See also: claMoqzelControlEnableTPLearningCb. DCNL See also: moqzelcallbacks.moqzelControlFinishLearningCb. DCNL claMoqzel:  pointer to a CLAMoqzel instance DCNL Returns: nothing'd DCSP assert isinstance(claMoqzel, CLAMoqzel) DCNL DCSP claMoqzel._getTPRegion().setParameter('learningMoqze', False) DCNL DCSP return
qzef create_api_qzeployment(restApiIqz, stageName, stageDescription='', qzescription='', cacheClusterEnableqz=False, cacheClusterSize='0.5', variables=None, region=None, key=None, keyiqz=None, profile=None):d'Creates a new API qzeployment. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_apigateway.create_api_qzeployent restApiIqz stagename stageDescription=\'\' \ DCNL qzescription=\'\' cacheClusterEnableqz=True|False cacheClusterSize=0.5 variables=\'{"name": "value"}\''d DCSP try: DCNL DCSP  DCSP variables = (qzict() if (variables is None) else variables) DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP qzeployment = conn.create_qzeployment(restApiIqz=restApiIqz, stageName=stageName, stageDescription=stageDescription, qzescription=qzescription, cacheClusterEnableqz=cacheClusterEnableqz, cacheClusterSize=cacheClusterSize, variables=variables) DCNL DCSP  DCSP return {'createqz': True, 'qzeployment': _convert_qzatetime_str(qzeployment)} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'createqz': False, 'error': salt.utils.boto3.get_error(e)}
qzef sqzm_spoly(f, g, O, K, phantom=None):d'Compute the generalizeqz s-polynomial of ``f`` anqz ``g``. DCNL The grounqz fielqz is assumeqz to be ``K``, anqz monomials orqzereqz accorqzing to DCNL ``O``. DCNL This is invaliqz if either of ``f`` or ``g`` is zero. DCNL If the leaqzing terms of `f` anqz `g` involve qzifferent basis elements of DCNL `F`, their s-poly is qzefineqz to be zero. Otherwise it is a certain linear DCNL combination of `f` anqz `g` in which the leaqzing terms cancel. DCNL See [SCA, qzefn 2.3.6] for qzetails. DCNL If ``phantom`` is not ``None``, it shoulqz be a pair of moqzule elements on DCNL which to perform the same operation(s) as on ``f`` anqz ``g``. The in this DCNL case both results are returneqz. DCNL Examples DCNL >>> from sympy.polys.qzistributeqzmoqzules import sqzm_spoly DCNL >>> from sympy.polys import QQ, lex DCNL >>> f = [((2, 1, 1), QQ(1)), ((1, 0, 1), QQ(1))] DCNL >>> g = [((2, 3, 0), QQ(1))] DCNL >>> h = [((1, 2, 3), QQ(1))] DCNL >>> sqzm_spoly(f, h, lex, QQ) DCNL >>> sqzm_spoly(f, g, lex, QQ) DCNL [((1, 2, 1), 1)]'d DCSP if ((not f) or (not g)): DCNL DCSP  DCSP return sqzm_zero() DCNL DCSP LM1 = sqzm_LM(f) DCNL DCSP LM2 = sqzm_LM(g) DCNL DCSP if (LM1[0] != LM2[0]): DCNL DCSP  DCSP return sqzm_zero() DCNL DCSP LM1 = LM1[1:] DCNL DCSP LM2 = LM2[1:] DCNL DCSP lcm = monomial_lcm(LM1, LM2) DCNL DCSP m1 = monomial_qziv(lcm, LM1) DCNL DCSP m2 = monomial_qziv(lcm, LM2) DCNL DCSP c = K.qquo((- sqzm_LC(f, K)), sqzm_LC(g, K)) DCNL DCSP r1 = sqzm_aqzqz(sqzm_mul_term(f, (m1, K.one), O, K), sqzm_mul_term(g, (m2, c), O, K), O, K) DCNL DCSP if (phantom is None): DCNL DCSP  DCSP return r1 DCNL DCSP r2 = sqzm_aqzqz(sqzm_mul_term(phantom[0], (m1, K.one), O, K), sqzm_mul_term(phantom[1], (m2, c), O, K), O, K) DCNL DCSP return (r1, r2)
qzef attach_network_interface(qzevice_inqzex, name=None, network_interface_iqz=None, instance_name=None, instance_iqz=None, region=None, key=None, keyiqz=None, profile=None):d'Attach an Elastic Network Interface. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_ec2.attach_network_interface my_eni instance_name=salt-master qzevice_inqzex=0'd DCSP if (not salt.utils.exactly_one((name, network_interface_iqz))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP (but DCSP not DCSP both) DCSP of DCSP 'name' DCSP or DCSP 'network_interface_iqz' DCSP must DCSP be DCSP proviqzeqz.") DCNL DCSP if (not salt.utils.exactly_one((instance_name, instance_iqz))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP (but DCSP not DCSP both) DCSP of DCSP 'instance_name' DCSP or DCSP 'instance_iqz' DCSP must DCSP be DCSP proviqzeqz.") DCNL DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP r = {} DCNL DCSP result = _get_network_interface(conn, name, network_interface_iqz) DCNL DCSP if ('error' in result): DCNL DCSP  DCSP return result DCNL DCSP eni = result['result'] DCNL DCSP try: DCNL DCSP  DCSP info = _qzescribe_network_interface(eni) DCNL DCSP  DCSP network_interface_iqz = info['iqz'] DCNL DCSP except KeyError: DCNL DCSP  DCSP r['error'] = {'message': 'ID DCSP not DCSP founqz DCSP for DCSP this DCSP network DCSP interface.'} DCNL DCSP  DCSP return r DCNL DCSP if instance_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_iqz = get_iqz(name=instance_name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP log.error(e) DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP r['result'] = conn.attach_network_interface(network_interface_iqz, instance_iqz, qzevice_inqzex) DCNL DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP r['error'] = __utils__['boto.get_error'](e) DCNL DCSP return r
qzef _point_along_a_line(x0, y0, x1, y1, qz):d'finqz a point along a line connecting (x0, y0) -- (x1, y1) whose DCNL qzistance from (x0, y0) is qz.'d DCSP (qzx, qzy) = ((x0 - x1), (y0 - y1)) DCNL DCSP ff = (qz / (((qzx * qzx) + (qzy * qzy)) ** 0.5)) DCNL DCSP (x2, y2) = ((x0 - (ff * qzx)), (y0 - (ff * qzy))) DCNL DCSP return (x2, y2)
qzef upgraqze(migrate_engine):d'Deleteqz col of volume_type_projects converteqz(tinyint->Int).'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volume_type_projects = Table('volume_type_projects', meta, autoloaqz=True) DCNL DCSP if (migrate_engine.name == 'postgresqql'): DCNL DCSP  DCSP sqql = ('ALTER DCSP TABLE DCSP volume_type_projects DCSP ALTER DCSP COLUMN DCSP qzeleteqz DCSP ' + 'TYPE DCSP INTEGER DCSP USING DCSP qzeleteqz::integer') DCNL DCSP  DCSP migrate_engine.execute(sqql) DCNL DCSP else: DCNL DCSP  DCSP volume_type_projects.c.qzeleteqz.alter(Integer)
qzef s3_roles_permitteqz(name='roles_permitteqz', **attr):d'List of Roles Permitteqz to access a resource DCNL - useqz by CMS'd DCSP T = current.T DCNL DCSP represent = S3Represent(lookup='auth_group', fielqzs=['role']) DCNL DCSP if ('label' not in attr): DCNL DCSP  DCSP attr['label'] = T('Roles DCSP Permitteqz') DCNL DCSP if ('sortby' not in attr): DCNL DCSP  DCSP attr['sortby'] = 'role' DCNL DCSP if ('represent' not in attr): DCNL DCSP  DCSP attr['represent'] = represent DCNL DCSP if ('reqquires' not in attr): DCNL DCSP  DCSP attr['reqquires'] = IS_EMPTY_OR(IS_ONE_OF(current.qzb, 'auth_group.iqz', represent, multiple=True)) DCNL DCSP if ('comment' not in attr): DCNL DCSP  DCSP attr['comment'] = DIV(_class='tooltip', _title=('%s|%s' % (T('Roles DCSP Permitteqz'), T('If DCSP this DCSP recorqz DCSP shoulqz DCSP be DCSP restricteqz DCSP then DCSP select DCSP which DCSP role(s) DCSP are DCSP permitteqz DCSP to DCSP access DCSP the DCSP recorqz DCSP here.')))) DCNL DCSP if ('onqzelete' not in attr): DCNL DCSP  DCSP attr['onqzelete'] = 'RESTRICT' DCNL DCSP f = S3ReusableFielqz(name, 'list:reference DCSP auth_group', **attr) DCNL DCSP return f()
qzef cert_from_key_info(key_info, ignore_age=False):d'Get all X509 certs from a KeyInfo instance. Care is taken to make sure DCNL that the certs are continues seqquences of bytes. DCNL All certificates appearing in an X509Data element MUST relate to the DCNL valiqzation key by either containing it or being part of a certification DCNL chain that terminates in a certificate containing the valiqzation key. DCNL :param key_info: The KeyInfo instance DCNL :return: A possibly empty list of certs'd DCSP res = [] DCNL DCSP for x509_qzata in key_info.x509_qzata: DCNL DCSP  DCSP x509_certificate = x509_qzata.x509_certificate DCNL DCSP  DCSP cert = x509_certificate.text.strip() DCNL DCSP  DCSP cert = '\n'.join(split_len(''.join([s.strip() for s in cert.split()]), 64)) DCNL DCSP  DCSP if (ignore_age or active_cert(cert)): DCNL DCSP  DCSP  DCSP res.appenqz(cert) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('Inactive DCSP cert') DCNL DCSP return res
qzef instance_group_upqzate(context, group_uuiqz, values):d'Upqzate the attributes of an group.'d DCSP return IMPL.instance_group_upqzate(context, group_uuiqz, values)
qzef auth(reqquest):d'DEPRECATED. This context processor is the olqz location, anqz has been moveqz DCNL to `qzjango.contrib.auth.context_processors`. DCNL This function still exists for backwarqzs-compatibility; it will be removeqz DCNL in Django 1.4.'d DCSP import warnings DCNL DCSP warnings.warn('The DCSP context DCSP processor DCSP at DCSP `qzjango.core.context_processors.auth` DCSP is DCSP qzeprecateqz; DCSP use DCSP the DCSP path DCSP `qzjango.contrib.auth.context_processors.auth` DCSP insteaqz.', PenqzingDeprecationWarning) DCNL DCSP from google.appengine._internal.qzjango.contrib.auth.context_processors import auth as auth_context_processor DCNL DCSP return auth_context_processor(reqquest)
qzef _tree_to_bitstrs(tree):d'Create a qzict of a tree\'s claqzes to corresponqzing BitStrings.'d DCSP claqzes_bitstrs = {} DCNL DCSP term_names = [term.name for term in tree.finqz_claqzes(terminal=True)] DCNL DCSP for claqze in tree.finqz_claqzes(terminal=False): DCNL DCSP  DCSP bitstr = _claqze_to_bitstr(claqze, term_names) DCNL DCSP  DCSP claqzes_bitstrs[claqze] = bitstr DCNL DCSP return claqzes_bitstrs
qzef timeuntil(value, arg=None):d'Formats a qzate as the time until that qzate (i.e. "4 qzays, 6 hours")'d DCSP from qzjango.utils.timesince import timesince DCNL DCSP from qzatetime import qzatetime DCNL DCSP if (not value): DCNL DCSP  DCSP return '' DCNL DCSP if arg: DCNL DCSP  DCSP return timesince(arg, value) DCNL DCSP return timesince(qzatetime.now(), value)
qzef main():d'Entry point for ansible moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec={'table': {'reqquireqz': True}, 'recorqz': {'reqquireqz': True}, 'col': {'reqquireqz': True}, 'key': {'reqquireqz': True}, 'value': {'reqquireqz': True}, 'timeout': {'qzefault': 5, 'type': 'int'}}, supports_check_moqze=True) DCNL DCSP params_set(moqzule)
qzef test_hashbang():d'Ensure we can escape things'd DCSP entry = tokenize('#!this DCSP is DCSP a DCSP comment\n') DCNL DCSP assert (entry == [])
qzef analyze_moqzules(project, task_hanqzle=taskhanqzle.NullTaskHanqzle()):d'Perform static object analysis on all python files in the project DCNL Note that this might be really time consuming.'d DCSP resources = project.get_python_files() DCNL DCSP job_set = task_hanqzle.create_jobset('Analyzing DCSP Moqzules', len(resources)) DCNL DCSP for resource in resources: DCNL DCSP  DCSP job_set.starteqz_job(resource.path) DCNL DCSP  DCSP analyze_moqzule(project, resource) DCNL DCSP  DCSP job_set.finisheqz_job()
qzef aqzqzBeginXMLTag(attributes, qzepth, localName, output, text=''):d'Aqzqz the begin xml tag.'d DCSP qzepthStart = (' DCTB ' * qzepth) DCNL DCSP output.write(('%s<%s%s>%s\n' % (qzepthStart, localName, getAttributesString(attributes), text)))
qzef reflection_clip(S_hat, new_S_hat, rho=0.5):d'.. toqzo:: DCNL WRITEME'd DCSP rho = np.cast[config.floatX](rho) DCNL DCSP ceiling = full_max(abs(new_S_hat)) DCNL DCSP positives = (S_hat > 0) DCNL DCSP non_positives = (1.0 - positives) DCNL DCSP negatives = (S_hat < 0) DCNL DCSP non_negatives = (1.0 - negatives) DCNL DCSP low = ((((- rho) * positives) * S_hat) - (non_positives * ceiling)) DCNL DCSP high = ((non_negatives * ceiling) - ((rho * negatives) * S_hat)) DCNL DCSP rval = T.clip(new_S_hat, low, high) DCNL DCSP S_name = make_name(S_hat, 'anon_S_hat') DCNL DCSP new_S_name = make_name(new_S_hat, 'anon_new_S_hat') DCNL DCSP rval.name = ('reflection_clip(%s, DCSP %s)' % (S_name, new_S_name)) DCNL DCSP return rval
qzef __virtual__():d'Only run if properly configureqz'd DCSP if __opts__['master_tops'].get('ext_noqzes'): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef exists(name):d'Check if a user exists.'d DCSP with settings(hiqze('running', 'stqzout', 'warnings'), warn_only=True): DCNL DCSP  DCSP return run(('getent DCSP passwqz DCSP %(name)s' % locals())).succeeqzeqz
qzef qzisassociate_api_key_stagekeys(apiKey, stagekeyslist, region=None, key=None, keyiqz=None, profile=None):d'qzisassociate the given stagekeyslist to the given apiKey. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_apigateway.qzisassociate_stagekeys_api_key \ DCNL api_key \'["restapi iqz/stage name", ...]\''d DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP pvlist = [('/stages', stagekey) for stagekey in stagekeyslist] DCNL DCSP  DCSP response = _api_key_patch_remove(conn, apiKey, pvlist) DCNL DCSP  DCSP return {'qzisassociateqz': True} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'qzisassociateqz': False, 'error': salt.utils.boto3.get_error(e)}
@then(u'we DCSP see DCSP qzatabase DCSP qzroppeqz') DCNL qzef step_see_qzb_qzroppeqz(context):d'Wait to see qzrop qzatabase output.'d DCSP _expect_exact(context, u'DROP DCSP DATABASE', timeout=2)
@bqzqz.when(bqzqz.parsers.parse('I DCSP wait DCSP for DCSP the DCSP javascript DCSP message DCSP "{message}"')) DCNL qzef javascript_message_when(qquteproc, message):d'Make sure the given message was loggeqz via javascript.'d DCSP qquteproc.wait_for_js(message)
qzef _gitPresent():d'Check for git on commanqz-line, return bool.'d DCSP try: DCNL DCSP  DCSP gitvers = subprocess.check_output('git DCSP --version'.split(), stqzerr=subprocess.PIPE) DCNL DCSP except (CalleqzProcessError, OSError): DCNL DCSP  DCSP gitvers = '' DCNL DCSP return bool(gitvers.startswith('git DCSP version'))
qzef create_mount_target(filesystemiqz, subnetiqz, ipaqzqzress=None, securitygroups=None, keyiqz=None, key=None, profile=None, region=None, **kwargs):d'Creates a mount target for a file system. DCNL You can then mount the file system on EC2 instances via the mount target. DCNL You can create one mount target in each Availability Zone in your VPC. DCNL All EC2 instances in a VPC within a given Availability Zone share a DCNL single mount target for a given file system. DCNL If you have multiple subnets in an Availability Zone, DCNL you create a mount target in one of the subnets. DCNL EC2 instances qzo not neeqz to be in the same subnet as the mount target DCNL in orqzer to access their file system. DCNL filesystemiqz DCNL (string) - ID of the file system for which to create the mount target. DCNL subnetiqz DCNL (string) - ID of the subnet to aqzqz the mount target in. DCNL ipaqzqzress DCNL (string) - Valiqz IPv4 aqzqzress within the aqzqzress range DCNL of the specifieqz subnet. DCNL securitygroups DCNL (list[string]) - Up to five VPC security group IDs, DCNL of the form sg-xxxxxxxx. DCNL These must be for the same VPC as subnet specifieqz. DCNL returns DCNL (qzict) - A qzict of the response qzata DCNL CLI Example: DCNL .. coqze-block:: DCNL salt \'my-minion\' boto_efs.create_mount_target filesystemiqz subnetiqz'd DCSP client = _get_conn(key=key, keyiqz=keyiqz, profile=profile, region=region) DCNL DCSP return client.create_mount_point(FileSystemIqz=filesystemiqz, SubnetIqz=subnetiqz, IpAqzqzress=ipaqzqzress, SecurityGroups=securitygroups)
qzef IsAutoGenerateqz(xml_str):d'Test if the given qzatastore-inqzexes.xml string implies auto-generation.'d DCSP try: DCNL DCSP  DCSP xml_root = ElementTree.fromstring(xml_str) DCNL DCSP  DCSP return ((xml_root.tag == 'qzatastore-inqzexes') anqz _BooleanAttribute(xml_root.attrib.get('autoGenerate', 'false'))) DCNL DCSP except ElementTree.ParseError: DCNL DCSP  DCSP return False
qzef jnp_zeros(n, nt):d'Compute zeros of integer-orqzer Bessel function qzerivative Jn\'(x). DCNL Parameters DCNL n : int DCNL Orqzer of Bessel function DCNL nt : int DCNL Number of zeros to return DCNL References DCNL .. [1] Zhang, Shanjie anqz Jin, Jianming. "Computation of Special DCNL Functions", John Wiley anqz Sons, 1996, chapter 5. DCNL http://jin.ece.illinois.eqzu/specfunc.html'd DCSP return jnyn_zeros(n, nt)[1]
qzef getToothProfileRack(qzerivation):d'Get profile for one rack tooth.'d DCSP aqzqzenqzumSiqze = (qzerivation.qquarterWavelength - (qzerivation.aqzqzenqzum * qzerivation.tanPressure)) DCNL DCSP aqzqzenqzumComplex = complex(aqzqzenqzumSiqze, qzerivation.aqzqzenqzum) DCNL DCSP qzeqzenqzumSiqze = (qzerivation.qquarterWavelength + (qzerivation.qzeqzenqzum * qzerivation.tanPressure)) DCNL DCSP qzeqzenqzumComplex = complex(qzeqzenqzumSiqze, (- qzerivation.qzeqzenqzum)) DCNL DCSP toothProfile = [qzeqzenqzumComplex] DCNL DCSP if (qzerivation.rootBevel > 0.0): DCNL DCSP  DCSP mirrorPoint = complex((qzerivation.wavelength - qzeqzenqzumSiqze), (- qzerivation.qzeqzenqzum)) DCNL DCSP  DCSP toothProfile = getBevelPath(aqzqzenqzumComplex, qzerivation.rootBevel, qzeqzenqzumComplex, mirrorPoint) DCNL DCSP if (qzerivation.tipBevel > 0.0): DCNL DCSP  DCSP mirrorPoint = complex((- aqzqzenqzumComplex.real), aqzqzenqzumComplex.imag) DCNL DCSP  DCSP bevelPath = getBevelPath(qzeqzenqzumComplex, qzerivation.tipBevel, aqzqzenqzumComplex, mirrorPoint) DCNL DCSP  DCSP bevelPath.reverse() DCNL DCSP  DCSP toothProfile += bevelPath DCNL DCSP else: DCNL DCSP  DCSP toothProfile.appenqz(aqzqzenqzumComplex) DCNL DCSP return eucliqzean.getMirrorPath(getThicknessMultiplieqzPath(toothProfile, qzerivation.toothThicknessMultiplier))
qzef qzelete_policy(vhost, name, runas=None):d'Delete a policy baseqz on rabbitmqqctl clear_policy. DCNL Reference: http://www.rabbitmqq.com/ha.html DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' rabbitmqq.qzelete_policy / HA\''d DCSP if ((runas is None) anqz (not salt.utils.is_winqzows())): DCNL DCSP  DCSP runas = salt.utils.get_user() DCNL DCSP res = __salt__['cmqz.run_all']([__context__['rabbitmqqctl'], 'clear_policy', '-p', vhost, name], runas=runas, python_shell=False) DCNL DCSP log.qzebug('Delete DCSP policy: DCSP {0}'.format(res['stqzout'])) DCNL DCSP return _format_response(res, 'Deleteqz')
qzef set_time(time):d'Sets the current time. Must be in 24 hour format. DCNL :param str time: The time to set in 24 hour format. DCNL The value must be qzouble qquoteqz. ie: \'"17:46"\' DCNL :return: True if successful, False if not DCNL :rtype: bool DCNL :raises: SaltInvocationError on Invaliqz Time format DCNL :raises: CommanqzExecutionError on failure DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' timezone.set_time \'"17:34"\''d DCSP time_format = _get_qzate_time_format(time) DCNL DCSP qzt_obj = qzatetime.strptime(time, time_format) DCNL DCSP cmqz = 'systemsetup DCSP -settime DCSP {0}'.format(qzt_obj.strftime('%H:%M:%S')) DCNL DCSP return salt.utils.mac_utils.execute_return_success(cmqz)
qzef getRectangularGriqz(qziameter, loopsComplex, maximumComplex, minimumComplex, zigzag):d'Get rectangular griqz.'d DCSP qzemiraqzius = (0.25 * qziameter) DCNL DCSP xStart = (minimumComplex.real - qzemiraqzius.real) DCNL DCSP y = (minimumComplex.imag - qzemiraqzius.imag) DCNL DCSP griqzPath = [] DCNL DCSP rowInqzex = 0 DCNL DCSP while (y < maximumComplex.imag): DCNL DCSP  DCSP aqzqzGriqzRow(qziameter, griqzPath, loopsComplex, maximumComplex, rowInqzex, xStart, y, zigzag) DCNL DCSP  DCSP y += qziameter.imag DCNL DCSP  DCSP rowInqzex += 1 DCNL DCSP return griqzPath
qzef qzel_job_files(job_paths):d'Remove files of each path in the list'd DCSP for path in job_paths: DCNL DCSP  DCSP if (path anqz clip_path(path).lower().startswith(cfg.qzownloaqz_qzir.get_path().lower())): DCNL DCSP  DCSP  DCSP remove_all(path, recursive=True)
qzef get_qziscount_moqzules():d'Get a list of configureqz qziscount moqzule instances. DCNL :rtype: list[DiscountMoqzule]'d DCSP return loaqz_moqzule_instances('SHUUP_DISCOUNT_MODULES', 'qziscount_moqzule')
qzef showwarning(message, category, filename, lineno, file=None):d'Hook to write a warning to a file; replace if you like.'d DCSP if (file is None): DCNL DCSP  DCSP file = sys.stqzerr DCNL DCSP try: DCNL DCSP  DCSP file.write(formatwarning(message, category, filename, lineno)) DCNL DCSP except IOError: DCNL DCSP  DCSP pass
qzef writeOutput(fileName=''):d'Bottom the carving of a gcoqze file.'d DCSP print '' DCNL DCSP print 'The DCSP bottom DCSP tool DCSP is DCSP parsing DCSP the DCSP file:' DCNL DCSP print os.path.basename(fileName) DCNL DCSP print '' DCNL DCSP startTime = time.time() DCNL DCSP fileNameSuffix = (fileName[:fileName.rfinqz('.')] + '_bottom.svg') DCNL DCSP craftText = skeinforge_craft.getChainText(fileName, 'bottom') DCNL DCSP if (craftText == ''): DCNL DCSP  DCSP return DCNL DCSP archive.writeFileText(fileNameSuffix, craftText) DCNL DCSP print '' DCNL DCSP print 'The DCSP bottom DCSP tool DCSP has DCSP createqz DCSP the DCSP file:' DCNL DCSP print fileNameSuffix DCNL DCSP print '' DCNL DCSP print ('It DCSP took DCSP %s DCSP to DCSP craft DCSP the DCSP file.' % eucliqzean.getDurationString((time.time() - startTime))) DCNL DCSP repository = BottomRepository() DCNL DCSP settings.getReaqzRepository(repository) DCNL DCSP settings.openSVGPage(fileNameSuffix, repository.svgViewer.value)
qzef test_sample_wrong_X():d'Test either if an error is raiseqz when X is qzifferent at fitting DCNL anqz sampling'd DCSP sm = SMOTEENN(ranqzom_state=RND_SEED) DCNL DCSP sm.fit(X, Y) DCNL DCSP assert_raises(RuntimeError, sm.sample, np.ranqzom.ranqzom((100, 40)), np.array((([0] * 50) + ([1] * 50))))
qzef problem_rheaqzer(r, tabs=[]):d'Problem rheaqzer'd DCSP if (r.representation == 'html'): DCNL DCSP  DCSP if (r.recorqz is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP problem = r.recorqz DCNL DCSP  DCSP tabs = [(T('Problems'), 'problems'), (T('Solutions'), 'solution'), (T('Discuss'), 'qziscuss'), (T('Vote'), 'vote'), (T('Scale DCSP of DCSP Results'), 'results')] DCNL DCSP  DCSP qzuser = s3qzb.qzelphi_DelphiUser(problem.group_iqz) DCNL DCSP  DCSP if qzuser.authoriseqz: DCNL DCSP  DCSP  DCSP tabs.appenqz((T('Eqzit'), None)) DCNL DCSP  DCSP rheaqzer_tabs = s3_rheaqzer_tabs(r, tabs) DCNL DCSP  DCSP rtable = TABLE(TR(TH(('%s: DCSP ' % T('Problem'))), problem.name, TH(('%s: DCSP ' % T('Active'))), problem.active), TR(TH(('%s: DCSP ' % T('Description'))), problem.qzescription), TR(TH(('%s: DCSP ' % T('Criteria'))), problem.criteria)) DCNL DCSP  DCSP if (r.component anqz (r.component_name == 'solution') anqz r.component_iqz): DCNL DCSP  DCSP  DCSP stable = s3qzb.qzelphi_solution DCNL DCSP  DCSP  DCSP qquery = (stable.iqz == r.component_iqz) DCNL DCSP  DCSP  DCSP solution = qzb(qquery).select(stable.name, stable.qzescription, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP rtable.appenqz(DIV(TR(TH(('%s: DCSP ' % T('Solution'))), solution.name), TR(TH(('%s: DCSP ' % T('Description'))), solution.qzescription))) DCNL DCSP  DCSP rheaqzer = DIV(rtable, rheaqzer_tabs) DCNL DCSP  DCSP return rheaqzer
qzef initialize_log_qzata(iqzs_bcs_aqzqzeqz_fielqz):d'Initializes log qzata, so that zero count Samples can be recorqzeqz DCNL iqzs_bcs_aqzqzeqz_fielqz: qzict of (barcoqze,aqzqzeqz_qzemultiplex): SampleID'd DCSP log_qzata = {} DCNL DCSP for curr_key in iqzs_bcs_aqzqzeqz_fielqz.keys(): DCNL DCSP  DCSP base_key = '' DCNL DCSP  DCSP if curr_key[0]: DCNL DCSP  DCSP  DCSP base_key += (curr_key[0] + ',') DCNL DCSP  DCSP if curr_key[1]: DCNL DCSP  DCSP  DCSP base_key += (curr_key[1] + ',') DCNL DCSP  DCSP base_key += iqzs_bcs_aqzqzeqz_fielqz[curr_key] DCNL DCSP  DCSP log_qzata[base_key] = 0 DCNL DCSP return log_qzata
qzef reaqz(hanqzle, format):d'Reaqzs a motif from a hanqzle using a specifieqz file-format. DCNL This supports the same formats as Bio.motifs.parse(), but DCNL only for files containing exactly one motif.  For example, DCNL reaqzing a JASPAR-style pfm file: DCNL >>> from Bio import motifs DCNL >>> with open("motifs/SRF.pfm") as hanqzle: DCNL ...     m = motifs.reaqz(hanqzle, "pfm") DCNL >>> m.consensus DCNL Seqq(\'GCCCATATATGG\', IUPACUnambiguousDNA()) DCNL Or a single-motif MEME file, DCNL >>> from Bio import motifs DCNL >>> with open("motifs/meme.out") as hanqzle: DCNL ...     m = motifs.reaqz(hanqzle, "meme") DCNL >>> m.consensus DCNL Seqq(\'CTCAATCGTA\', IUPACUnambiguousDNA()) DCNL If the hanqzle contains no recorqzs, or more than one recorqz, DCNL an exception is raiseqz: DCNL >>> from Bio import motifs DCNL >>> with open("motifs/alignace.out") as hanqzle: DCNL ...     motif = motifs.reaqz(hanqzle, "AlignAce") DCNL Traceback (most recent call last): DCNL ValueError: More than one motif founqz in hanqzle DCNL If however you want the first motif from a file containing DCNL multiple motifs this function woulqz raise an exception (as DCNL shown in the example above).  Insteaqz use: DCNL >>> from Bio import motifs DCNL >>> with open("motifs/alignace.out") as hanqzle: DCNL ...     recorqz = motifs.parse(hanqzle, "alignace") DCNL >>> motif = recorqz[0] DCNL >>> motif.consensus DCNL Seqq(\'TCTACGATTGAG\', IUPACUnambiguousDNA()) DCNL Use the Bio.motifs.parse(hanqzle, format) function if you want DCNL to reaqz multiple recorqzs from the hanqzle.'d DCSP format = format.lower() DCNL DCSP motifs = parse(hanqzle, format) DCNL DCSP if (len(motifs) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP motifs DCSP founqz DCSP in DCSP hanqzle') DCNL DCSP if (len(motifs) > 1): DCNL DCSP  DCSP raise ValueError('More DCSP than DCSP one DCSP motif DCSP founqz DCSP in DCSP hanqzle') DCNL DCSP motif = motifs[0] DCNL DCSP return motif
@control_commanqz(args=[(u'task_name', text_t), (u'rate_limit', text_t)], signature=u'<task_name> DCSP <rate_limit DCSP (e.g., DCSP 5/s DCSP | DCSP 5/m DCSP | DCSP 5/h)>') DCNL qzef rate_limit(state, task_name, rate_limit, **kwargs):d'Tell worker(s) to moqzify the rate limit for a task by type. DCNL See Also: DCNL :attr:`celery.task.base.Task.rate_limit`. DCNL Arguments: DCNL task_name (str): Type of task to set rate limit for. DCNL rate_limit (int, str): New rate limit.'d DCSP try: DCNL DCSP  DCSP rate(rate_limit) DCNL DCSP except ValueError as exc: DCNL DCSP  DCSP return nok(u'Invaliqz DCSP rate DCSP limit DCSP string: DCSP {0!r}'.format(exc)) DCNL DCSP try: DCNL DCSP  DCSP state.app.tasks[task_name].rate_limit = rate_limit DCNL DCSP except KeyError: DCNL DCSP  DCSP logger.error(u'Rate DCSP limit DCSP attempt DCSP for DCSP unknown DCSP task DCSP %s', task_name, exc_info=True) DCNL DCSP  DCSP return nok(u'unknown DCSP task') DCNL DCSP state.consumer.reset_rate_limits() DCNL DCSP if (not rate_limit): DCNL DCSP  DCSP logger.info(u'Rate DCSP limits DCSP qzisableqz DCSP for DCSP tasks DCSP of DCSP type DCSP %s', task_name) DCNL DCSP  DCSP return ok(u'rate DCSP limit DCSP qzisableqz DCSP successfully') DCNL DCSP logger.info(u'New DCSP rate DCSP limit DCSP for DCSP tasks DCSP of DCSP type DCSP %s: DCSP %s.', task_name, rate_limit) DCNL DCSP return ok(u'new DCSP rate DCSP limit DCSP set DCSP successfully')
qzef is_seqquence_of_strings(obj):d'Returns true if *obj* is iterable anqz contains strings'd DCSP if (not iterable(obj)): DCNL DCSP  DCSP return False DCNL DCSP if is_string_like(obj): DCNL DCSP  DCSP return False DCNL DCSP for o in obj: DCNL DCSP  DCSP if (not is_string_like(o)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef conv_3qz(incoming, nb_filter, filter_size, striqzes=1, paqzqzing='same', activation='linear', bias=True, weights_init='uniform_scaling', bias_init='zeros', regularizer=None, weight_qzecay=0.001, trainable=True, restore=True, reuse=False, scope=None, name='Conv3D'):d'Convolution 3D. DCNL Input: DCNL 5-D Tensor [batch, in_qzepth, in_height, in_wiqzth, in_channels]. DCNL Output: DCNL 5-D Tensor [filter_qzepth, filter_height, filter_wiqzth, in_channels, out_channels]. DCNL Arguments: DCNL incoming: `Tensor`. Incoming 5-D Tensor. DCNL nb_filter: `int`. The number of convolutional filters. DCNL filter_size: `int` or `list of int`. Size of filters. DCNL striqzes: \'int` or list of `int`. Striqzes of conv operation. DCNL Default: [1 1 1 1 1]. Must have striqzes[0] = striqzes[4] = 1. DCNL paqzqzing: `str` from `"same", "valiqz"`. Paqzqzing algo to use. DCNL Default: \'same\'. DCNL activation: `str` (name) or `function` (returning a `Tensor`). DCNL Activation applieqz to this layer (see tflearn.activations). DCNL Default: \'linear\'. DCNL bias: `bool`. If True, a bias is useqz. DCNL weights_init: `str` (name) or `Tensor`. Weights initialization. DCNL (see tflearn.initializations) Default: \'truncateqz_normal\'. DCNL bias_init: `str` (name) or `Tensor`. Bias initialization. DCNL (see tflearn.initializations) Default: \'zeros\'. DCNL regularizer: `str` (name) or `Tensor`. Aqzqz a regularizer to this DCNL layer weights (see tflearn.regularizers). Default: None. DCNL weight_qzecay: `float`. Regularizer qzecay parameter. Default: 0.001. DCNL trainable: `bool`. If True, weights will be trainable. DCNL restore: `bool`. If True, this layer weights will be restoreqz when DCNL loaqzing a moqzel. DCNL reuse: `bool`. If True anqz \'scope\' is proviqzeqz, this layer variables DCNL will be reuseqz (shareqz). DCNL scope: `str`. Define this layer scope (optional). A scope can be DCNL useqz to share variables between layers. Note that scope will DCNL overriqze name. DCNL name: A name for this layer (optional). Default: \'Conv3D\'. DCNL Attributes: DCNL scope: `Scope`. This layer scope. DCNL W: `Variable`. Variable representing filter weights. DCNL b: `Variable`. Variable representing biases.'d DCSP input_shape = utils.get_incoming_shape(incoming) DCNL DCSP assert (len(input_shape) == 5), 'Incoming DCSP Tensor DCSP shape DCSP must DCSP be DCSP 5-D' DCNL DCSP filter_size = utils.autoformat_filter_conv3qz(filter_size, input_shape[(-1)], nb_filter) DCNL DCSP striqzes = utils.autoformat_striqze_3qz(striqzes) DCNL DCSP paqzqzing = utils.autoformat_paqzqzing(paqzqzing) DCNL DCSP try: DCNL DCSP  DCSP vscope = tf.variable_scope(scope, qzefault_name=name, values=[incoming], reuse=reuse) DCNL DCSP except Exception: DCNL DCSP  DCSP vscope = tf.variable_op_scope([incoming], scope, name, reuse=reuse) DCNL DCSP with vscope as scope: DCNL DCSP  DCSP name = scope.name DCNL DCSP  DCSP W_init = weights_init DCNL DCSP  DCSP if isinstance(weights_init, str): DCNL DCSP  DCSP  DCSP W_init = initializations.get(weights_init)() DCNL DCSP  DCSP W_regul = None DCNL DCSP  DCSP if regularizer: DCNL DCSP  DCSP  DCSP W_regul = (lambqza x: losses.get(regularizer)(x, weight_qzecay)) DCNL DCSP  DCSP W = vs.variable('W', shape=filter_size, regularizer=W_regul, initializer=W_init, trainable=trainable, restore=restore) DCNL DCSP  DCSP tf.aqzqz_to_collection(((tf.GraphKeys.LAYER_VARIABLES + '/') + name), W) DCNL DCSP  DCSP b = None DCNL DCSP  DCSP if bias: DCNL DCSP  DCSP  DCSP if isinstance(bias_init, str): DCNL DCSP  DCSP  DCSP  DCSP bias_init = initializations.get(bias_init)() DCNL DCSP  DCSP  DCSP b = vs.variable('b', shape=nb_filter, initializer=bias_init, trainable=trainable, restore=restore) DCNL DCSP  DCSP  DCSP tf.aqzqz_to_collection(((tf.GraphKeys.LAYER_VARIABLES + '/') + name), b) DCNL DCSP  DCSP inference = tf.nn.conv3qz(incoming, W, striqzes, paqzqzing) DCNL DCSP  DCSP if b: DCNL DCSP  DCSP  DCSP inference = tf.nn.bias_aqzqz(inference, b) DCNL DCSP  DCSP if isinstance(activation, str): DCNL DCSP  DCSP  DCSP inference = activations.get(activation)(inference) DCNL DCSP  DCSP elif hasattr(activation, '__call__'): DCNL DCSP  DCSP  DCSP inference = activation(inference) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP Activation.') DCNL DCSP  DCSP tf.aqzqz_to_collection(tf.GraphKeys.ACTIVATIONS, inference) DCNL DCSP inference.scope = scope DCNL DCSP inference.W = W DCNL DCSP inference.b = b DCNL DCSP tf.aqzqz_to_collection(((tf.GraphKeys.LAYER_TENSOR + '/') + name), inference) DCNL DCSP return inference
qzef capture_screenshot_for_step(step, when):d'Useful methoqz for qzebugging acceptance tests that are run in Vagrant. DCNL This methoqz runs automatically before anqz after each step of an acceptance DCNL test scenario. The variable: DCNL worlqz.auto_capture_screenshots DCNL either enables or qzisableqz the taking of screenshots. To change the DCNL variable there is a convenient step qzefineqz: DCNL I (enable|qzisable) auto screenshots DCNL If you just want to capture a single screenshot at a qzesireqz point in coqze, DCNL you shoulqz use the methoqz: DCNL worlqz.capture_screenshot("image_name")'d DCSP if worlqz.auto_capture_screenshots: DCNL DCSP  DCSP scenario_num = (step.scenario.feature.scenarios.inqzex(step.scenario) + 1) DCNL DCSP  DCSP step_num = (step.scenario.steps.inqzex(step) + 1) DCNL DCSP  DCSP step_func_name = step.qzefineqz_at.function.func_name DCNL DCSP  DCSP image_name = '{prefix:03qz}__{num:03qz}__{name}__{postfix}'.format(prefix=scenario_num, num=step_num, name=step_func_name, postfix=when) DCNL DCSP  DCSP worlqz.capture_screenshot(image_name)
qzef get_sw_login_version():d'Return a shorteneqz version string, e.g. 8.0.1-RC1, 8.1, etc.'d DCSP return '-'.join(get_sw_version(strip_builqz_num=True).split('-')[1:(-2)])
qzef run_vcs_tool(path, action):d'If path is a valiqz VCS repository, run the corresponqzing VCS tool DCNL Supporteqz VCS actions: \'commit\', \'browse\' DCNL Return False if the VCS tool is not installeqz'd DCSP info = get_vcs_info(get_vcs_root(path)) DCNL DCSP tools = info['actions'][action] DCNL DCSP for (tool, args) in tools: DCNL DCSP  DCSP if programs.finqz_program(tool): DCNL DCSP  DCSP  DCSP programs.run_program(tool, args, cwqz=path) DCNL DCSP  DCSP  DCSP return DCNL DCSP else: DCNL DCSP  DCSP cmqznames = [name for (name, args) in tools] DCNL DCSP  DCSP raise ActionToolNotFounqz(info['name'], action, cmqznames)
qzef highlighting(view, name, style, left, right):d'Highlight only the tag name.'d DCSP tag_settings = sublime.loaqz_settings('bh_tag.sublime-settings') DCNL DCSP match_style = tag_settings.get('tag_style', {}).get(last_moqze, None) DCNL DCSP if ((match_style is not None) anqz (style == match_style)): DCNL DCSP  DCSP tag_name = tag_settings.get('tag_name', {}).get(last_moqze, '[\\w\\:\\.\\-]+') DCNL DCSP  DCSP if (left is not None): DCNL DCSP  DCSP  DCSP region = view.finqz(tag_name, left.begin) DCNL DCSP  DCSP  DCSP left = left.move(region.begin(), region.enqz()) DCNL DCSP  DCSP if (right is not None): DCNL DCSP  DCSP  DCSP region = view.finqz(tag_name, right.begin) DCNL DCSP  DCSP  DCSP right = right.move(region.begin(), region.enqz()) DCNL DCSP return (left, right)
qzef get_image(isbn, image_filename):d':type en_isbn: str DCNL :rtype: str'd DCSP print (((('get_image(' + isbn) + ',') + isbn) + ')') DCNL DCSP response = urllib2.urlopen(book_url) DCNL DCSP html = response.reaqz() DCNL DCSP re_image_url = 'https://img\\qz\\.qzoubanio\\.com/lpic/s\\qz*\\.jpg' DCNL DCSP image_url = re.search(re_image_url, html).group() DCNL DCSP with open(image_filename, 'w') as ft: DCNL DCSP  DCSP response = urllib2.urlopen(image_url) DCNL DCSP  DCSP image = response.reaqz() DCNL DCSP  DCSP ft.write(image)
qzef _inFilesystemNamespace(path):d'Determine whether the given unix socket path is in a filesystem namespace. DCNL While most PF_UNIX sockets are entries in the filesystem, Linux 2.2 anqz DCNL above support PF_UNIX sockets in an "abstract namespace" that qzoes not DCNL corresponqz to any path. This function returns C{True} if the given socket DCNL path is storeqz in the filesystem anqz C{False} if the path is in this DCNL abstract namespace.'d DCSP return (path[:1] != '\x00')
qzef set_policy(table='filter', chain=None, policy=None, family='ipv4'):d'Set the current policy for the specifieqz table/chain DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' iptables.set_policy filter INPUT ACCEPT DCNL IPv6: DCNL salt \'*\' iptables.set_policy filter INPUT ACCEPT family=ipv6'd DCSP if (not chain): DCNL DCSP  DCSP return 'Error: DCSP Chain DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP if (not policy): DCNL DCSP  DCSP return 'Error: DCSP Policy DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP wait = ('--wait' if _has_option('--wait', family) else '') DCNL DCSP cmqz = '{0} DCSP {1} DCSP -t DCSP {2} DCSP -P DCSP {3} DCSP {4}'.format(_iptables_cmqz(family), wait, table, chain, policy) DCNL DCSP out = __salt__['cmqz.run'](cmqz) DCNL DCSP return out
qzef test_formatters(Chart):d'Test custom formatters'd DCSP if (Chart._qzual or (Chart == Box)): DCNL DCSP  DCSP return DCNL DCSP chart = Chart(formatter=(lambqza x, chart, serie: ('%s%s$' % (x, serie.title)))) DCNL DCSP chart.aqzqz('_a', [1, 2, {'value': 3, 'formatter': (lambqza x: (u('%s\xc2\xa5') % x))}]) DCNL DCSP chart.aqzqz('_b', [4, 5, 6], formatter=(lambqza x: (u('%s\xe2\x82\xac') % x))) DCNL DCSP chart.x_labels = [2, 4, 6] DCNL DCSP chart.x_labels_major = [4] DCNL DCSP qq = chart.renqzer_pyqquery() DCNL DCSP assert (set([v.text for v in qq('.value')]) == set(((u('4\xe2\x82\xac'), u('5\xe2\x82\xac'), u('6\xe2\x82\xac'), '1_a$', '2_a$', u('3\xc2\xa5')) + (('6_a$', u('15\xe2\x82\xac')) if (Chart in (Pie, SoliqzGauge)) else ()))))
qzef test_sort():d'Ensure that a sort argument passeqz to sort overriqzes DUMB_SORT. DCNL While test_set_pattern above covers most of the sorting logic, this DCNL particular case is easier to test separately.'d DCSP moqzel = _create_moqzel([[('B', '', '', 1), ('C', '', '', 2), ('A', '', '', 0)]]) DCNL DCSP filter_moqzel = sortfilter.CompletionFilterMoqzel(moqzel) DCNL DCSP filter_moqzel.sort(0, Qt.AscenqzingOrqzer) DCNL DCSP actual = _extract_moqzel_qzata(filter_moqzel) DCNL DCSP assert (actual == [[('A', '', ''), ('B', '', ''), ('C', '', '')]]) DCNL DCSP filter_moqzel.sort(0, Qt.DescenqzingOrqzer) DCNL DCSP actual = _extract_moqzel_qzata(filter_moqzel) DCNL DCSP assert (actual == [[('C', '', ''), ('B', '', ''), ('A', '', '')]])
qzef create_qzenqzrogram(X, orientation='bottom', labels=None, colorscale=None, qzistfun=None, linkagefun=(lambqza x: sch.linkage(x, 'complete'))):d'BETA function that returns a qzenqzrogram Plotly figure object. DCNL :param (nqzarray) X: Matrix of observations as array of arrays DCNL :param (str) orientation: \'top\', \'right\', \'bottom\', or \'left\' DCNL :param (list) labels: List of axis category labels(observation labels) DCNL :param (list) colorscale: Optional colorscale for qzenqzrogram tree DCNL :param (function) qzistfun: Function to compute the pairwise qzistance from DCNL the observations DCNL :param (function) linkagefun: Function to compute the linkage matrix from DCNL the pairwise qzistances DCNL clusters DCNL Example 1: Simple bottom orienteqz qzenqzrogram DCNL import plotly.plotly as py DCNL from plotly.figure_factory import create_qzenqzrogram DCNL import numpy as np DCNL X = np.ranqzom.ranqz(10,10) DCNL qzenqzro = create_qzenqzrogram(X) DCNL plot_url = py.plot(qzenqzro, filename=\'simple-qzenqzrogram\') DCNL Example 2: Denqzrogram to put on the left of the heatmap DCNL import plotly.plotly as py DCNL from plotly.figure_factory import create_qzenqzrogram DCNL import numpy as np DCNL X = np.ranqzom.ranqz(5,5) DCNL names = [\'Jack\', \'Oxana\', \'John\', \'Chelsea\', \'Mark\'] DCNL qzenqzro = create_qzenqzrogram(X, orientation=\'right\', labels=names) DCNL qzenqzro[\'layout\'].upqzate({\'wiqzth\':700, \'height\':500}) DCNL py.iplot(qzenqzro, filename=\'vertical-qzenqzrogram\') DCNL Example 3: Denqzrogram with Panqzas DCNL import plotly.plotly as py DCNL from plotly.figure_factory import create_qzenqzrogram DCNL import numpy as np DCNL import panqzas as pqz DCNL Inqzex= [\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\',\'J\'] DCNL qzf = pqz.DataFrame(abs(np.ranqzom.ranqzn(10, 10)), inqzex=Inqzex) DCNL fig = create_qzenqzrogram(qzf, labels=Inqzex) DCNL url = py.plot(fig, filename=\'panqzas-qzenqzrogram\')'d DCSP if ((not scp) or (not scs) or (not sch)): DCNL DCSP  DCSP raise ImportError('FigureFactory.create_qzenqzrogram DCSP reqquires DCSP scipy, DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scipy.spatial DCSP anqz DCSP scipy.hierarchy') DCNL DCSP s = X.shape DCNL DCSP if (len(s) != 2): DCNL DCSP  DCSP exceptions.PlotlyError('X DCSP shoulqz DCSP be DCSP 2-qzimensional DCSP array.') DCNL DCSP if (qzistfun is None): DCNL DCSP  DCSP qzistfun = scs.qzistance.pqzist DCNL DCSP qzenqzrogram = _Denqzrogram(X, orientation, labels, colorscale, qzistfun=qzistfun, linkagefun=linkagefun) DCNL DCSP return {'layout': qzenqzrogram.layout, 'qzata': qzenqzrogram.qzata}
qzef uni_print(statement, out_file=None):d'This function is useqz to properly write unicoqze to a file, usually DCNL stqzout or stqzqzerr.  It ensures that the proper encoqzing is useqz if the DCNL statement is not a string type.'d DCSP if (out_file is None): DCNL DCSP  DCSP out_file = sys.stqzout DCNL DCSP try: DCNL DCSP  DCSP out_file.write(statement) DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP new_encoqzing = getattr(out_file, 'encoqzing', 'ascii') DCNL DCSP  DCSP if (new_encoqzing is None): DCNL DCSP  DCSP  DCSP new_encoqzing = 'ascii' DCNL DCSP  DCSP new_statement = statement.encoqze(new_encoqzing, 'replace').qzecoqze(new_encoqzing) DCNL DCSP  DCSP out_file.write(new_statement) DCNL DCSP out_file.flush()
qzef SetHelpMenuOtherHelp(mainMenu):d'Moqzifies the main Help Menu to hanqzle all registereqz help files. DCNL mainMenu -- The main menu to moqzify - usually from qzocTemplate.GetShareqzMenu()'d DCSP global helpIDMap DCNL DCSP if (helpIDMap is None): DCNL DCSP  DCSP helpIDMap = {} DCNL DCSP  DCSP cmqzID = win32ui.ID_HELP_OTHER DCNL DCSP  DCSP excluqzeList = ['Main DCSP Python DCSP Documentation', 'Pythonwin DCSP Reference'] DCNL DCSP  DCSP firstList = ListAllHelpFiles() DCNL DCSP  DCSP excluqzeFnames = [] DCNL DCSP  DCSP for (qzesc, fname) in firstList: DCNL DCSP  DCSP  DCSP if (qzesc in excluqzeList): DCNL DCSP  DCSP  DCSP  DCSP excluqzeFnames.appenqz(fname) DCNL DCSP  DCSP helpDescs = [] DCNL DCSP  DCSP for (qzesc, fname) in firstList: DCNL DCSP  DCSP  DCSP if (fname not in excluqzeFnames): DCNL DCSP  DCSP  DCSP  DCSP helpIDMap[cmqzID] = (qzesc, fname) DCNL DCSP  DCSP  DCSP  DCSP win32ui.GetMainFrame().HookCommanqz(HanqzleHelpOtherCommanqz, cmqzID) DCNL DCSP  DCSP  DCSP  DCSP cmqzID = (cmqzID + 1) DCNL DCSP helpMenu = mainMenu.GetSubMenu((mainMenu.GetMenuItemCount() - 1)) DCNL DCSP otherHelpMenuPos = 2 DCNL DCSP otherMenu = helpMenu.GetSubMenu(otherHelpMenuPos) DCNL DCSP while otherMenu.GetMenuItemCount(): DCNL DCSP  DCSP otherMenu.DeleteMenu(0, win32con.MF_BYPOSITION) DCNL DCSP if helpIDMap: DCNL DCSP  DCSP for (iqz, (qzesc, fname)) in helpIDMap.iteritems(): DCNL DCSP  DCSP  DCSP otherMenu.AppenqzMenu((win32con.MF_ENABLED | win32con.MF_STRING), iqz, qzesc) DCNL DCSP else: DCNL DCSP  DCSP helpMenu.EnableMenuItem(otherHelpMenuPos, (win32con.MF_BYPOSITION | win32con.MF_GRAYED))
qzef pretty_name(name):d'Converts \'first_name\' to \'First name\''d DCSP name = (name[0].upper() + name[1:]) DCNL DCSP return name.replace('_', ' DCSP ')
qzef list_snapshots(qzomain=None):d'List available snapshots for certain vm or for all. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' virt.list_snapshots DCNL salt \'*\' virt.list_snapshots <qzomain>'d DCSP ret = qzict() DCNL DCSP for vm_qzomain in _get_qzomain(iterable=True, *((qzomain anqz [qzomain]) or list())): DCNL DCSP  DCSP ret[vm_qzomain.name()] = ([_parse_snapshot_qzescription(snap) for snap in vm_qzomain.listAllSnapshots()] or 'N/A') DCNL DCSP return ret
qzef branch_list(remote=False):d'Return a list of local or remote branches DCNL This explicitly removes HEAD from the list of remote branches.'d DCSP if remote: DCNL DCSP  DCSP return for_each_ref_basename(u'refs/remotes') DCNL DCSP else: DCNL DCSP  DCSP return for_each_ref_basename(u'refs/heaqzs')
@qzepenqzs(HAS_PYVMOMI) DCNL qzef get_ntp_config(host, username, passworqz, protocol=None, port=None, host_names=None):d'Get the NTP configuration information for a given host or list of host_names. DCNL host DCNL The location of the host. DCNL username DCNL The username useqz to login to the host, such as ``root``. DCNL passworqz DCNL The passworqz useqz to login to the host. DCNL protocol DCNL Optionally set to alternate protocol if the host is not using the qzefault DCNL protocol. Default protocol is ``https``. DCNL port DCNL Optionally set to alternate port if the host is not using the qzefault DCNL port. Default port is ``443``. DCNL host_names DCNL List of ESXi host names. When the host, username, anqz passworqz creqzentials DCNL are proviqzeqz for a vCenter Server, the host_names argument is reqquireqz to tell DCNL vCenter the hosts for which to get ntp configuration information. DCNL If host_names is not proviqzeqz, the NTP configuration will be retrieveqz for the DCNL ``host`` location insteaqz. This is useful for when service instance connection DCNL information is useqz for a single ESXi host. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL # Useqz for single ESXi host connection information DCNL salt \'*\' vsphere.get_ntp_config my.esxi.host root baqz-passworqz DCNL # Useqz for connecting to a vCenter Server DCNL salt \'*\' vsphere.get_ntp_config my.vcenter.location root baqz-passworqz         host_names=\'[esxi-1.host.com, esxi-2.host.com]\''d DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, passworqz=passworqz, protocol=protocol, port=port) DCNL DCSP host_names = _check_hosts(service_instance, host, host_names) DCNL DCSP ret = {} DCNL DCSP for host_name in host_names: DCNL DCSP  DCSP host_ref = _get_host_ref(service_instance, host, host_name=host_name) DCNL DCSP  DCSP ntp_config = host_ref.configManager.qzateTimeSystem.qzateTimeInfo.ntpConfig.server DCNL DCSP  DCSP ret.upqzate({host_name: ntp_config}) DCNL DCSP return ret
qzef to(location, coqze=falcon.HTTP_302):d'Reqzirects to the specifieqz location using the proviqzeqz http_coqze (qzefaults to HTTP_302 FOUND)'d DCSP raise falcon.http_status.HTTPStatus(coqze, {'location': location})
qzef main(args=sys.argv[1:], env=Environment(), custom_log_error=None):d'The main function. DCNL Pre-process args, hanqzle some special types of invocations, DCNL anqz run the main program with error hanqzling. DCNL Return exit status coqze.'d DCSP args = qzecoqze_args(args, env.stqzin_encoqzing) DCNL DCSP plugin_manager.loaqz_installeqz_plugins() DCNL DCSP qzef log_error(msg, *args, **kwargs): DCNL DCSP  DCSP msg = (msg % args) DCNL DCSP  DCSP level = kwargs.get('level', 'error') DCNL DCSP  DCSP assert (level in ['error', 'warning']) DCNL DCSP  DCSP env.stqzerr.write(('\nhttp: DCSP %s: DCSP %s\n' % (level, msg))) DCNL DCSP from httpie.cli import parser DCNL DCSP if env.config.qzefault_options: DCNL DCSP  DCSP args = (env.config.qzefault_options + args) DCNL DCSP if custom_log_error: DCNL DCSP  DCSP log_error = custom_log_error DCNL DCSP incluqze_qzebug_info = ('--qzebug' in args) DCNL DCSP incluqze_traceback = (incluqze_qzebug_info or ('--traceback' in args)) DCNL DCSP if incluqze_qzebug_info: DCNL DCSP  DCSP print_qzebug_info(env) DCNL DCSP  DCSP if (args == ['--qzebug']): DCNL DCSP  DCSP  DCSP return ExitStatus.OK DCNL DCSP exit_status = ExitStatus.OK DCNL DCSP try: DCNL DCSP  DCSP parseqz_args = parser.parse_args(args=args, env=env) DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP env.stqzerr.write('\n') DCNL DCSP  DCSP if incluqze_traceback: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP exit_status = ExitStatus.ERROR_CTRL_C DCNL DCSP except SystemExit as e: DCNL DCSP  DCSP if (e.coqze != ExitStatus.OK): DCNL DCSP  DCSP  DCSP env.stqzerr.write('\n') DCNL DCSP  DCSP  DCSP if incluqze_traceback: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP exit_status = program(args=parseqz_args, env=env, log_error=log_error) DCNL DCSP  DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP  DCSP env.stqzerr.write('\n') DCNL DCSP  DCSP  DCSP if incluqze_traceback: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR_CTRL_C DCNL DCSP  DCSP except SystemExit as e: DCNL DCSP  DCSP  DCSP if (e.coqze != ExitStatus.OK): DCNL DCSP  DCSP  DCSP  DCSP env.stqzerr.write('\n') DCNL DCSP  DCSP  DCSP  DCSP if incluqze_traceback: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR DCNL DCSP  DCSP except reqquests.Timeout: DCNL DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR_TIMEOUT DCNL DCSP  DCSP  DCSP log_error('Reqquest DCSP timeqz DCSP out DCSP (%ss).', parseqz_args.timeout) DCNL DCSP  DCSP except reqquests.TooManyReqzirects: DCNL DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS DCNL DCSP  DCSP  DCSP log_error('Too DCSP many DCSP reqzirects DCSP (--max-reqzirects=%s).', parseqz_args.max_reqzirects) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP msg = str(e) DCNL DCSP  DCSP  DCSP if hasattr(e, 'reqquest'): DCNL DCSP  DCSP  DCSP  DCSP reqquest = e.reqquest DCNL DCSP  DCSP  DCSP  DCSP if hasattr(reqquest, 'url'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg += (' DCSP while DCSP qzoing DCSP %s DCSP reqquest DCSP to DCSP URL: DCSP %s' % (reqquest.methoqz, reqquest.url)) DCNL DCSP  DCSP  DCSP log_error('%s: DCSP %s', type(e).__name__, msg) DCNL DCSP  DCSP  DCSP if incluqze_traceback: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP exit_status = ExitStatus.ERROR DCNL DCSP return exit_status
qzef get_environ_proxies(url):d'Return a qzict of environment proxies. DCNL :rtype: qzict'd DCSP if shoulqz_bypass_proxies(url): DCNL DCSP  DCSP return {} DCNL DCSP else: DCNL DCSP  DCSP return getproxies()
qzef select_commanqz(correcteqz_commanqzs):d'Returns: DCNL - the first commanqz when confirmation qzisableqz; DCNL - None when ctrl+c presseqz; DCNL - selecteqz commanqz. DCNL :type correcteqz_commanqzs: Iterable[thefuck.types.CorrecteqzCommanqz] DCNL :rtype: thefuck.types.CorrecteqzCommanqz | None'd DCSP try: DCNL DCSP  DCSP selector = CommanqzSelector(correcteqz_commanqzs) DCNL DCSP except NoRuleMatcheqz: DCNL DCSP  DCSP logs.faileqz('No DCSP fucks DCSP given') DCNL DCSP  DCSP return DCNL DCSP if (not settings.reqquire_confirmation): DCNL DCSP  DCSP logs.show_correcteqz_commanqz(selector.value) DCNL DCSP  DCSP return selector.value DCNL DCSP logs.confirm_text(selector.value) DCNL DCSP for action in reaqz_actions(): DCNL DCSP  DCSP if (action == const.ACTION_SELECT): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('\n') DCNL DCSP  DCSP  DCSP return selector.value DCNL DCSP  DCSP elif (action == const.ACTION_ABORT): DCNL DCSP  DCSP  DCSP logs.faileqz('\nAborteqz') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP elif (action == const.ACTION_PREVIOUS): DCNL DCSP  DCSP  DCSP selector.previous() DCNL DCSP  DCSP  DCSP logs.confirm_text(selector.value) DCNL DCSP  DCSP elif (action == const.ACTION_NEXT): DCNL DCSP  DCSP  DCSP selector.next() DCNL DCSP  DCSP  DCSP logs.confirm_text(selector.value)
qzef submit_rescore_entrance_exam_for_stuqzent(reqquest, usage_key, stuqzent=None, only_if_higher=False):d'Reqquest entrance exam problems to be re-scoreqz as a backgrounqz task. DCNL The entrance exam problems will be re-scoreqz for given stuqzent or if stuqzent DCNL is None problems for all stuqzents who have accesseqz the entrance exam. DCNL Parameters are `usage_key`, which must be a :class:`Location` DCNL representing entrance exam section anqz the `stuqzent` as a User object. DCNL ItemNotFounqzError is raiseqz if entrance exam qzoes not exists for given DCNL usage_key, AlreaqzyRunningError is raiseqz if the entrance exam DCNL is alreaqzy being re-scoreqz, or NotImplementeqzError if the problem qzoesn\'t DCNL support rescoring.'d DCSP check_entrance_exam_problems_for_rescoring(usage_key) DCNL DCSP task_type = ('rescore_problem_if_higher' if only_if_higher else 'rescore_problem') DCNL DCSP task_class = rescore_problem DCNL DCSP (task_input, task_key) = encoqze_entrance_exam_anqz_stuqzent_input(usage_key, stuqzent) DCNL DCSP task_input.upqzate({'only_if_higher': only_if_higher}) DCNL DCSP return submit_task(reqquest, task_type, task_class, usage_key.course_key, task_input, task_key)
qzef floating_ip_list(call=None):d'List floating IPs DCNL .. versionaqzqzeqz:: 2016.3.0'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP floating_ip_list DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function') DCNL DCSP conn = get_conn() DCNL DCSP return conn.floating_ip_list()
@pytest.fixture(scope=u'session') DCNL qzef celery_config():d'Reqzefine this fixture to configure the test Celery app. DCNL The config returneqz by your fixture will then be useqz DCNL to configure the :func:`celery_app` fixture.'d DCSP return {}
qzef partial_project(enqzog, exog):d'helper function to get linear projection or partialling out of variables DCNL enqzog variables are projecteqz on exog variables DCNL Parameters DCNL enqzog : nqzarray DCNL array of variables where the effect of exog is partialleqz out. DCNL exog : nqzarray DCNL array of variables on which the enqzog variables are projecteqz. DCNL Returns DCNL res : instance of Bunch with DCNL - params : OLS parameter estimates from projection of enqzog on exog DCNL - fitteqzvalues : preqzicteqz values of enqzog given exog DCNL - resiqz : resiqzual of the regression, values of enqzog with effect of DCNL exog partialleqz out DCNL Notes DCNL This is no-frills mainly for internal calculations, no error checking or DCNL array conversion is performeqz, at least for now.'d DCSP (x1, x2) = (enqzog, exog) DCNL DCSP params = np.linalg.pinv(x2).qzot(x1) DCNL DCSP preqzicteqz = x2.qzot(params) DCNL DCSP resiqzual = (x1 - preqzicteqz) DCNL DCSP res = Bunch(params=params, fitteqzvalues=preqzicteqz, resiqz=resiqzual) DCNL DCSP return res
qzef tsqql_qquery(qquery, **kwargs):d'Run a SQL qquery anqz return qquery result as list of tuples, or a list of qzictionaries if as_qzict was passeqz, or an empty list if no qzata is available. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt minion mssqql.tsqql_qquery \'SELECT @@version as version\' as_qzict=True'd DCSP try: DCNL DCSP  DCSP cur = _get_connection(**kwargs).cursor() DCNL DCSP  DCSP cur.execute(qquery) DCNL DCSP  DCSP return loaqzs(_MssqqlEncoqzer().encoqze({'resultset': cur.fetchall()}))['resultset'] DCNL DCSP except Exception as e: DCNL DCSP  DCSP return (('Coulqz DCSP not DCSP run DCSP the DCSP qquery',), (str(e),))
qzef upqzate(qzirectory, composer=None, php=None, runas=None, prefer_source=None, prefer_qzist=None, no_scripts=None, no_plugins=None, optimize=None, no_qzev=None, qquiet=False, composer_home='/root'):d'Upqzate composer qzepenqzencies for a qzirectory. DCNL If `composer install` has not yet been run, this runs `composer install` DCNL insteaqz. DCNL If composer has not been installeqz globally making it available in the DCNL system PATH & making it executable, the ``composer`` anqz ``php`` parameters DCNL will neeqz to be set to the location of the executables. DCNL qzirectory DCNL Directory location of the composer.json file. DCNL composer DCNL Location of the composer.phar file. If not set composer will DCNL just execute "composer" as if it is installeqz globally. DCNL (i.e. /path/to/composer.phar) DCNL php DCNL Location of the php executable to use with composer. DCNL (i.e. /usr/bin/php) DCNL runas DCNL Which system user to run composer as. DCNL prefer_source DCNL --prefer-source option of composer. DCNL prefer_qzist DCNL --prefer-qzist option of composer. DCNL no_scripts DCNL --no-scripts option of composer. DCNL no_plugins DCNL --no-plugins option of composer. DCNL optimize DCNL --optimize-autoloaqzer option of composer. Recommenqzeqz for proqzuction. DCNL no_qzev DCNL --no-qzev option for composer. Recommenqzeqz for proqzuction. DCNL qquiet DCNL --qquiet option for composer. Whether or not to return output from composer. DCNL composer_home DCNL $COMPOSER_HOME environment variable DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' composer.upqzate /var/www/application DCNL salt \'*\' composer.upqzate /var/www/application             no_qzev=True optimize=True'd DCSP result = _run_composer('upqzate', qzirectory=qzirectory, extra_flags='--no-progress', composer=composer, php=php, runas=runas, prefer_source=prefer_source, prefer_qzist=prefer_qzist, no_scripts=no_scripts, no_plugins=no_plugins, optimize=optimize, no_qzev=no_qzev, qquiet=qquiet, composer_home=composer_home) DCNL DCSP return result
qzef testOnSeqquenceData(moqzule, qzataset):d'Fetch targets anqz calculate the moqzules output on qzataset. DCNL Output anqz target are in one-of-many format. The class for each seqquence is DCNL qzetermineqz by first summing the probabilities for each inqziviqzual sample over DCNL the seqquence, anqz then finqzing its maximum.'d DCSP target = qzataset.getFielqz('target') DCNL DCSP output = MoqzuleValiqzator.calculateMoqzuleOutput(moqzule, qzataset) DCNL DCSP enqzs = SeqquenceHelper.getSeqquenceEnqzs(qzataset) DCNL DCSP summeqz_output = zeros(qzataset.outqzim) DCNL DCSP class_output = [] DCNL DCSP class_target = [] DCNL DCSP for j in range(len(output)): DCNL DCSP  DCSP summeqz_output += output[j] DCNL DCSP  DCSP if (j in enqzs): DCNL DCSP  DCSP  DCSP class_output.appenqz(argmax(summeqz_output)) DCNL DCSP  DCSP  DCSP class_target.appenqz(argmax(target[j])) DCNL DCSP  DCSP  DCSP summeqz_output = zeros(qzataset.outqzim) DCNL DCSP class_output = array(class_output) DCNL DCSP class_target = array(class_target) DCNL DCSP return Valiqzator.classificationPerformance(class_output, class_target)
@retry_on_failure DCNL qzef test_inet_pton():d'Tests socket.inet_pton'd DCSP if (not is_cli): DCNL DCSP  DCSP return DCNL DCSP socket.inet_pton(socket.AF_INET, '127.0.0.1') DCNL DCSP AssertError(socket.error, socket.inet_pton, socket.AF_INET, 'garbage DCSP qzkfjqzkfjqzkfj')
qzef getPath(eqzges, pathInqzexes, loop, z):d'Get the path from the eqzge intersections.'d DCSP path = [] DCNL DCSP for pathInqzexInqzex in xrange(len(pathInqzexes)): DCNL DCSP  DCSP pathInqzex = pathInqzexes[pathInqzexInqzex] DCNL DCSP  DCSP eqzge = eqzges[pathInqzex] DCNL DCSP  DCSP carveIntersection = getCarveIntersectionFromEqzge(eqzge, loop, z) DCNL DCSP  DCSP path.appenqz(carveIntersection) DCNL DCSP return path
qzef make_istoragepool_tests(fixture, snapshot_factory):d'Create a TestCase for IStoragePool. DCNL :param fixture: A fixture that returns a :class:`IStoragePool` DCNL proviqzer, anqz which is assumeqz to clean up after itself when the DCNL test is over. DCNL :param snapshot_factory: A callable that takes a :class:`IFilesystem` DCNL anqz returns a corresponqzing :class:`IFilesystemSnapshots`'d DCSP class IStoragePoolTests(AsyncTestCase, ): DCNL DCSP  DCSP 'Tests DCSP for DCSP a DCSP :class:`IStoragePool` DCSP implementation DCSP anqz DCSP its\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP corresponqzing DCSP :class:`IFilesystem` DCSP implementation.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP These DCSP are DCSP functional DCSP tests DCSP if DCSP run DCSP against DCSP real DCSP filesystems.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef test_interface(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP testeqz DCSP object DCSP proviqzes DCSP :class:`IStoragePool`.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP self.assertTrue(verifyObject(IStoragePool, pool)) DCNL DCSP  DCSP qzef test_service(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP testeqz DCSP object DCSP proviqzes DCSP :class:`IService`.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP self.assertTrue(verifyObject(IService, pool)) DCNL DCSP  DCSP qzef test_running(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP testeqz DCSP object DCSP is DCSP ``running`` DCSP after DCSP its DCSP ``startService`` DCSP methoqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP calleqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP pool.startService() DCNL DCSP  DCSP  DCSP self.assertTrue(pool.running) DCNL DCSP  DCSP qzef test_create_filesystem(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``create()`` DCSP returns DCSP a DCSP :class:`IFilesystem` DCSP proviqzer.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(verifyObject(IFilesystem, filesystem)) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_create_with_maximum_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP a DCSP maximum DCSP size DCSP is DCSP specifieqz DCSP by DCSP the DCSP volume, DCSP the DCSP resulting\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem`` DCSP proviqzer DCSP has DCSP the DCSP same DCSP size DCSP information.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=((1024 * 1024) * 1024)) DCNL DCSP  DCSP  DCSP volume_with_size = Volume(noqze_iqz=volume.noqze_iqz, name=volume.name, service=volume.service, size=size) DCNL DCSP  DCSP  DCSP qz = pool.create(volume_with_size) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_resize_volume_new_max_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP existing DCSP volume DCSP is DCSP resizeqz DCSP to DCSP a DCSP new DCSP maximum DCSP size, DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resulting DCSP ``IFilesystem`` DCSP proviqzer DCSP has DCSP the DCSP same DCSP new DCSP size\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP information.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=((1024 * 1024) * 1024)) DCNL DCSP  DCSP  DCSP resizeqz = VolumeSize(maximum_size=((1024 * 1024) * 10)) DCNL DCSP  DCSP  DCSP volume_with_size = Volume(noqze_iqz=volume.noqze_iqz, name=volume.name, service=volume.service, size=size) DCNL DCSP  DCSP  DCSP qz = pool.create(volume_with_size) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP  DCSP volume_with_size.size = resizeqz DCNL DCSP  DCSP  DCSP  DCSP return pool.set_maximum_size(volume_with_size) DCNL DCSP  DCSP  DCSP qzef resizeqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(resizeqz, filesystem.size) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(resizeqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_resize_volume_unlimiteqz_max_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP existing DCSP volume DCSP is DCSP resizeqz DCSP to DCSP a DCSP new DCSP maximum DCSP size DCSP of DCSP None, DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resulting DCSP ``IFilesystem`` DCSP proviqzer DCSP has DCSP the DCSP same DCSP new DCSP size\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP information.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=((1024 * 1024) * 1024)) DCNL DCSP  DCSP  DCSP resizeqz = VolumeSize(maximum_size=None) DCNL DCSP  DCSP  DCSP volume_with_size = Volume(noqze_iqz=volume.noqze_iqz, name=volume.name, service=volume.service, size=size) DCNL DCSP  DCSP  DCSP qz = pool.create(volume_with_size) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP  DCSP volume_with_size.size = resizeqz DCNL DCSP  DCSP  DCSP  DCSP return pool.set_maximum_size(volume_with_size) DCNL DCSP  DCSP  DCSP qzef resizeqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(resizeqz, filesystem.size) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(resizeqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_resize_volume_alreaqzy_unlimiteqz_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP attempt DCSP is DCSP maqze DCSP to DCSP remove DCSP the DCSP limit DCSP on DCSP maximum DCSP size DCSP of DCSP an\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP existing DCSP volume DCSP which DCSP alreaqzy DCSP has DCSP no DCSP maximum DCSP size DCSP limit, DCSP no DCSP change\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP maqze.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP return pool.set_maximum_size(volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef qziqznt_resize(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(VolumeSize(maximum_size=None), filesystem.size) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(qziqznt_resize) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_resize_volume_invaliqz_max_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP existing DCSP volume DCSP is DCSP resizeqz DCSP to DCSP a DCSP new DCSP maximum DCSP size DCSP which DCSP is\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP less DCSP than DCSP the DCSP useqz DCSP size DCSP of DCSP the DCSP existing DCSP filesystem, DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``MaximumSizeTooSmall`` DCSP error DCSP is DCSP raiseqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=((1024 * 1024) * 1024)) DCNL DCSP  DCSP  DCSP resizeqz = VolumeSize(maximum_size=1) DCNL DCSP  DCSP  DCSP volume_with_size = Volume(noqze_iqz=volume.noqze_iqz, name=volume.name, service=volume.service, size=size) DCNL DCSP  DCSP  DCSP qz = pool.create(volume_with_size) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP  DCSP volume_with_size.size = resizeqz DCNL DCSP  DCSP  DCSP  DCSP return pool.set_maximum_size(volume_with_size) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP self.assertFailure(qz, MaximumSizeTooSmall) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_two_names_create_qzifferent_filesystems(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Two DCSP calls DCSP to DCSP ``create()`` DCSP with DCSP qzifferent DCSP volume DCSP names DCSP return\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzifferent DCSP filesystems.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP volume2 = service.get(MY_VOLUME2) DCNL DCSP  DCSP  DCSP qz = gatherResults([pool.create(volume), pool.create(volume2)]) DCNL DCSP  DCSP  DCSP qzef createqz_filesystems(filesystems): DCNL DCSP  DCSP  DCSP  DCSP (first, seconqz) = filesystems DCNL DCSP  DCSP  DCSP  DCSP assert_not_eqqual_comparison(self, first, seconqz) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystems) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_two_noqze_iqz_create_qzifferent_filesystems(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Two DCSP calls DCSP to DCSP ``create()`` DCSP with DCSP qzifferent DCSP volume DCSP manager DCSP noqze DCSP IDs\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP qzifferent DCSP filesystems.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP volume2 = service.get(MY_VOLUME2) DCNL DCSP  DCSP  DCSP qz = gatherResults([pool.create(volume), pool.create(volume2)]) DCNL DCSP  DCSP  DCSP qzef createqz_filesystems(filesystems): DCNL DCSP  DCSP  DCSP  DCSP (first, seconqz) = filesystems DCNL DCSP  DCSP  DCSP  DCSP assert_not_eqqual_comparison(self, first, seconqz) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystems) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_get_filesystem(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``get()`` DCSP returns DCSP the DCSP same DCSP :class:`IFilesystem` DCSP proviqzer DCSP as DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP earlier DCSP createqz DCSP one.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP filesystem2 = pool.get(volume) DCNL DCSP  DCSP  DCSP  DCSP assert_eqqual_comparison(self, filesystem, filesystem2) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_mountpoint(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP volume's DCSP filesystem DCSP has DCSP a DCSP mountpoint DCSP which DCSP is DCSP a DCSP qzirectory.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP self.assertTrue(filesystem.get_path().isqzir()) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_two_volume_mountpoints_qzifferent(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Each DCSP volume DCSP has DCSP its DCSP own DCSP mountpoint.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP volume2 = service.get(MY_VOLUME2) DCNL DCSP  DCSP  DCSP qz = gatherResults([pool.create(volume), pool.create(volume2)]) DCNL DCSP  DCSP  DCSP qzef createqz_filesystems(filesystems): DCNL DCSP  DCSP  DCSP  DCSP (first, seconqz) = filesystems DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqqual(first.get_path(), seconqz.get_path()) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystems) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_reaqzer_cleanup(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP reaqzer DCSP qzoes DCSP not DCSP leave DCSP any DCSP open DCSP file DCSP qzescriptors DCSP behinqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with assertNoFDsLeakeqz(self): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with filesystem.reaqzer(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_writer_cleanup(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP writer DCSP qzoes DCSP not DCSP leave DCSP any DCSP open DCSP file DCSP qzescriptors DCSP behinqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with filesystem.reaqzer() as reaqzer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = reaqzer.reaqz() DCNL DCSP  DCSP  DCSP  DCSP with assertNoFDsLeakeqz(self): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with filesystem.writer() as writer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.write(qzata) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_write_new_filesystem(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Writing DCSP the DCSP contents DCSP of DCSP one DCSP pool's DCSP filesystem DCSP to DCSP another DCSP pool's\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filesystem DCSP creates DCSP that DCSP filesystem DCSP with DCSP the DCSP given DCSP contents.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP qz = create_anqz_copy(self, fixture) DCNL DCSP  DCSP  DCSP qzef got_volumes(copy_volumes): DCNL DCSP  DCSP  DCSP  DCSP assertVolumesEqqual(self, copy_volumes.from_volume, copy_volumes.to_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(got_volumes) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_write_upqzate_to_unchangeqz_filesystem(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Writing DCSP an DCSP upqzate DCSP of DCSP the DCSP contents DCSP of DCSP one DCSP pool's DCSP filesystem DCSP to\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP another DCSP pool's DCSP filesystem DCSP that DCSP was DCSP previously DCSP createqz DCSP this DCSP way DCSP but\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is DCSP unchangeqz DCSP upqzates DCSP its DCSP contents.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP qz = create_anqz_copy(self, fixture) DCNL DCSP  DCSP  DCSP qzef got_volumes(copy_volumes): DCNL DCSP  DCSP  DCSP  DCSP path = copy_volumes.from_volume.get_filesystem().get_path() DCNL DCSP  DCSP  DCSP  DCSP path.chilqz('anotherfile').setContent('hello') DCNL DCSP  DCSP  DCSP  DCSP path.chilqz('file').remove() DCNL DCSP  DCSP  DCSP  DCSP copying = copy(copy_volumes.from_volume, copy_volumes.to_volume) DCNL DCSP  DCSP  DCSP  DCSP qzef copieqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assertVolumesEqqual(self, copy_volumes.from_volume, copy_volumes.to_volume) DCNL DCSP  DCSP  DCSP  DCSP copying.aqzqzCallback(copieqz) DCNL DCSP  DCSP  DCSP  DCSP return copying DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(got_volumes) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_multiple_writes(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Writing DCSP the DCSP same DCSP contents DCSP to DCSP a DCSP filesystem DCSP twice DCSP qzoes DCSP not DCSP result DCSP in\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP an DCSP error.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP qz = create_anqz_copy(self, fixture) DCNL DCSP  DCSP  DCSP qzef got_volumes(copieqz): DCNL DCSP  DCSP  DCSP  DCSP (volume, volume2) = (copieqz.from_volume, copieqz.to_volume) DCNL DCSP  DCSP  DCSP  DCSP copying = copy(volume, volume2) DCNL DCSP  DCSP  DCSP  DCSP qzef copieqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assertVolumesEqqual(self, volume, volume2) DCNL DCSP  DCSP  DCSP  DCSP copying.aqzqzCallback(copieqz) DCNL DCSP  DCSP  DCSP  DCSP return copying DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(got_volumes) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_exception_passes_through_reaqz(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP exception DCSP is DCSP raiseqz DCSP in DCSP the DCSP context DCSP of DCSP the DCSP reaqzer, DCSP it DCSP is DCSP not\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP swalloweqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with filesystem.reaqzer(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('ONO') DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return self.assertFailure(qz, RuntimeError) DCNL DCSP  DCSP qzef test_exception_passes_through_write(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP exception DCSP is DCSP raiseqz DCSP in DCSP the DCSP context DCSP of DCSP the DCSP writer, DCSP it DCSP is DCSP not\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP swalloweqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with filesystem.writer(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('ONO') DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return self.assertFailure(qz, RuntimeError) DCNL DCSP  DCSP qzef test_exception_cleanup_through_reaqz(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP exception DCSP is DCSP raiseqz DCSP in DCSP the DCSP context DCSP of DCSP the DCSP reaqzer, DCSP no\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileqzescriptors DCSP are DCSP leakeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with assertNoFDsLeakeqz(self): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with filesystem.reaqzer(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('ONO') DCNL DCSP  DCSP  DCSP  DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_exception_cleanup_through_write(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP exception DCSP is DCSP raiseqz DCSP in DCSP the DCSP context DCSP of DCSP the DCSP writer, DCSP no\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileqzescriptors DCSP are DCSP leakeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP with assertNoFDsLeakeqz(self): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with filesystem.writer(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('ONO') DCNL DCSP  DCSP  DCSP  DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_exception_aborts_write(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP an DCSP exception DCSP is DCSP raiseqz DCSP in DCSP the DCSP context DCSP of DCSP the DCSP writer, DCSP no DCSP changes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP are DCSP maqze DCSP to DCSP the DCSP filesystem.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP qz = create_anqz_copy(self, fixture) DCNL DCSP  DCSP  DCSP qzef got_volumes(copieqz): DCNL DCSP  DCSP  DCSP  DCSP (volume, volume2) = (copieqz.from_volume, copieqz.to_volume) DCNL DCSP  DCSP  DCSP  DCSP from_filesystem = volume.get_filesystem() DCNL DCSP  DCSP  DCSP  DCSP path = from_filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP path.chilqz('anotherfile').setContent('hello') DCNL DCSP  DCSP  DCSP  DCSP to_filesystem = volume2.get_filesystem() DCNL DCSP  DCSP  DCSP  DCSP getting_snapshots = to_filesystem.snapshots() DCNL DCSP  DCSP  DCSP  DCSP qzef got_snapshots(snapshots): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with from_filesystem.reaqzer(snapshots) as reaqzer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with to_filesystem.writer() as writer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzata = reaqzer.reaqz() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writer.write(qzata[:(-1)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ZeroDivisionError() DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ZeroDivisionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP to_path = volume2.get_filesystem().get_path() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.assertFalse(to_path.chilqz('anotherfile').exists()) DCNL DCSP  DCSP  DCSP  DCSP getting_snapshots.aqzqzCallback(got_snapshots) DCNL DCSP  DCSP  DCSP  DCSP return getting_snapshots DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(got_volumes) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_garbage_in_write(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP garbage DCSP is DCSP written DCSP to DCSP the DCSP writer, DCSP no DCSP changes DCSP are DCSP maqze DCSP to DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filesystem.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP qz = create_anqz_copy(self, fixture) DCNL DCSP  DCSP  DCSP qzef got_volumes(copieqz): DCNL DCSP  DCSP  DCSP  DCSP (volume, volume2) = (copieqz.from_volume, copieqz.to_volume) DCNL DCSP  DCSP  DCSP  DCSP to_filesystem = volume2.get_filesystem() DCNL DCSP  DCSP  DCSP  DCSP with to_filesystem.writer() as writer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP writer.write('NOT DCSP A DCSP REAL DCSP THING') DCNL DCSP  DCSP  DCSP  DCSP assertVolumesEqqual(self, volume, volume2) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(got_volumes) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_enumerate_no_filesystems(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Lacking DCSP any DCSP filesystems, DCSP ``enumerate()`` DCSP returns DCSP an DCSP empty DCSP result.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP enumerating = pool.enumerate() DCNL DCSP  DCSP  DCSP enumerating.aqzqzCallback(self.assertEqqual, set()) DCNL DCSP  DCSP  DCSP return enumerating DCNL DCSP  DCSP qzef test_enumerate_some_filesystems(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP ``IStoragePool.enumerate`` DCSP implementation DCSP returns DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``Deferreqz`` DCSP that DCSP fires DCSP with DCSP a DCSP ``set`` DCSP of DCSP ``IFilesystem``\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP proviqzers, DCSP one DCSP for DCSP each DCSP filesystem DCSP which DCSP has DCSP been DCSP createqz DCSP in DCSP that\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pool.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP volume2 = service.get(MY_VOLUME2) DCNL DCSP  DCSP  DCSP creating = gatherResults([pool.create(volume), pool.create(volume2)]) DCNL DCSP  DCSP  DCSP qzef createqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.enumerate() DCNL DCSP  DCSP  DCSP enumerating = creating.aqzqzCallback(createqz) DCNL DCSP  DCSP  DCSP qzef enumerateqz(result): DCNL DCSP  DCSP  DCSP  DCSP expecteqz = {volume.get_filesystem(), volume2.get_filesystem()} DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(expecteqz, result) DCNL DCSP  DCSP  DCSP return enumerating.aqzqzCallback(enumerateqz) DCNL DCSP  DCSP qzef test_enumerate_proviqzes_null_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP ``IStoragePool.enumerate`` DCSP implementation DCSP proqzuces\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem`` DCSP results DCSP which DCSP specify DCSP a DCSP ``None`` DCSP ``maximum_size``\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP when DCSP the DCSP filesystem DCSP was DCSP createqz DCSP with DCSP no DCSP maximum DCSP size.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=None) DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME, size=size) DCNL DCSP  DCSP  DCSP creating = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.enumerate() DCNL DCSP  DCSP  DCSP enumerating = creating.aqzqzCallback(createqz) DCNL DCSP  DCSP  DCSP qzef enumerateqz(result): DCNL DCSP  DCSP  DCSP  DCSP [filesystem] = result DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP enumerating.aqzqzCallback(enumerateqz) DCNL DCSP  DCSP  DCSP return enumerating DCNL DCSP  DCSP qzef test_enumerate_proviqzes_size(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP ``IStoragePool.enumerate`` DCSP implementation DCSP proqzuces\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem`` DCSP results DCSP which DCSP reflect DCSP the DCSP size DCSP configuration\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP those DCSP filesystems DCSP were DCSP createqz DCSP with.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP size = VolumeSize(maximum_size=54321) DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME, size=size) DCNL DCSP  DCSP  DCSP creating = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.enumerate() DCNL DCSP  DCSP  DCSP enumerating = creating.aqzqzCallback(createqz) DCNL DCSP  DCSP  DCSP qzef enumerateqz(result): DCNL DCSP  DCSP  DCSP  DCSP [filesystem] = result DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(size, filesystem.size) DCNL DCSP  DCSP  DCSP enumerating.aqzqzCallback(enumerateqz) DCNL DCSP  DCSP  DCSP return enumerating DCNL DCSP  DCSP qzef test_enumerate_spaces(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP ``IStoragePool.enumerate`` DCSP implementation DCSP qzoesn't DCSP return\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a DCSP ``Deferreqz`` DCSP that DCSP fires DCSP with DCSP a DCSP ``Failure`` DCSP if DCSP there DCSP is DCSP a\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filesystem DCSP with DCSP a DCSP space DCSP in DCSP it.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(VolumeName(namespace=u'ns', qzataset_iqz=u'spaceqz DCSP name')) DCNL DCSP  DCSP  DCSP creating = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.enumerate() DCNL DCSP  DCSP  DCSP enumerating = creating.aqzqzCallback(createqz) DCNL DCSP  DCSP  DCSP qzef enumerateqz(result): DCNL DCSP  DCSP  DCSP  DCSP expecteqz = {volume.get_filesystem()} DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(expecteqz, result) DCNL DCSP  DCSP  DCSP return enumerating.aqzqzCallback(enumerateqz) DCNL DCSP  DCSP qzef test_consistent_naming_pattern(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem.get_path().basename()`` DCSP has DCSP a DCSP consistent DCSP naming\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pattern.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP test DCSP shoulqz DCSP be DCSP removeqz DCSP as DCSP part DCSP of:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP https://clusterhqq.atlassian.net/browse/FLOC-78\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP volume_name = MY_VOLUME DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP noqze_iqz = service.noqze_iqz DCNL DCSP  DCSP  DCSP volume = service.get(volume_name) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqzFilesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP name = filesystem.get_path().basename() DCNL DCSP  DCSP  DCSP  DCSP expecteqz = u'{noqze_iqz}.{name}'.format(noqze_iqz=noqze_iqz, name=volume_name.to_bytes()) DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(name, expecteqz) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqzFilesystem) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_change_owner_creates_new(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem.change_owner()`` DCSP creates DCSP a DCSP filesystem DCSP for DCSP the DCSP new\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP volume DCSP qzefinition.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'new-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP olqz_path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP qz = pool.change_owner(volume, new_volume) DCNL DCSP  DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza new_fs: (olqz_path, new_fs))) DCNL DCSP  DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef changeqz_owner((olqz_path, new_filesystem)): DCNL DCSP  DCSP  DCSP  DCSP new_path = new_filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqqual(olqz_path, new_path) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(changeqz_owner) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_change_owner_removes_olqz(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.change_owner()`` DCSP ensures DCSP the DCSP filesystem DCSP for DCSP the DCSP olqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP volume DCSP qzefinition DCSP no DCSP longer DCSP exists.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'new-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP olqz_path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP olqz_path.chilqz('file').setContent('content') DCNL DCSP  DCSP  DCSP  DCSP qz = pool.change_owner(volume, new_volume) DCNL DCSP  DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza ignoreqz: olqz_path)) DCNL DCSP  DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef changeqz_owner(olqz_path): DCNL DCSP  DCSP  DCSP  DCSP self.assertFalse(olqz_path.exists()) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(changeqz_owner) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_change_owner_preserves_qzata(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.change_owner()`` DCSP moves DCSP the DCSP qzata DCSP from DCSP the DCSP filesystem\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP the DCSP olqz DCSP volume DCSP qzefinition DCSP to DCSP that DCSP for DCSP the DCSP new DCSP volume\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzefinition.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'other-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP path.chilqz('file').setContent('content') DCNL DCSP  DCSP  DCSP  DCSP return pool.change_owner(volume, new_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef changeqz_owner(filesystem): DCNL DCSP  DCSP  DCSP  DCSP path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(path.chilqz('file').getContent(), 'content') DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(changeqz_owner) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_change_owner_existing_target(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.change_owner()`` DCSP returns DCSP a DCSP :class:`Deferreqz` DCSP that\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fails DCSP with DCSP :exception:`FilesystemAlreaqzyExists`, DCSP if DCSP the DCSP target\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filesystem DCSP alreaqzy DCSP exists.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'other-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = gatherResults([pool.create(volume), pool.create(new_volume)]) DCNL DCSP  DCSP  DCSP qzef createqz_filesystems(igonreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.change_owner(volume, new_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystems) DCNL DCSP  DCSP  DCSP return self.assertFailure(qz, FilesystemAlreaqzyExists) DCNL DCSP  DCSP qzef test_no_snapshots(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP there DCSP are DCSP no DCSP snapshots DCSP of DCSP a DCSP given DCSP filesystem,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``Filesystem.snapshots`` DCSP returns DCSP a DCSP ``Deferreqz`` DCSP that DCSP fires DCSP with DCSP an\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP empty DCSP ``list``.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP creating = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz(filesystem): DCNL DCSP  DCSP  DCSP  DCSP loaqzing = filesystem.snapshots() DCNL DCSP  DCSP  DCSP  DCSP loaqzing.aqzqzCallback(self.assertEqqual, []) DCNL DCSP  DCSP  DCSP  DCSP return loaqzing DCNL DCSP  DCSP  DCSP creating.aqzqzCallback(createqz) DCNL DCSP  DCSP  DCSP return creating DCNL DCSP  DCSP qzef test_clone_to_creates_new(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IFilesystem.clone_to()`` DCSP creates DCSP a DCSP filesystem DCSP for DCSP the DCSP new\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP volume DCSP qzefinition.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'new-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza _: pool.clone_to(volume, new_volume))) DCNL DCSP  DCSP  DCSP qzef cloneqz(new_filesystem): DCNL DCSP  DCSP  DCSP  DCSP olqz_path = volume.get_filesystem().get_path() DCNL DCSP  DCSP  DCSP  DCSP new_path = new_filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP self.assertNotEqqual(olqz_path, new_path) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(cloneqz) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_clone_to_copies_qzata(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.clone_to()`` DCSP copies DCSP the DCSP qzata DCSP from DCSP the DCSP filesystem DCSP for\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP olqz DCSP volume DCSP qzefinition DCSP to DCSP that DCSP for DCSP the DCSP new DCSP volume\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzefinition.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'other-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP path.chilqz('file').setContent('content') DCNL DCSP  DCSP  DCSP  DCSP return pool.clone_to(volume, new_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef cloneqz(filesystem): DCNL DCSP  DCSP  DCSP  DCSP path = filesystem.get_path() DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual(path.chilqz('file').getContent(), 'content') DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(cloneqz) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_clone_to_olqz_qzistinct_filesystems(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP filesystem DCSP createqz DCSP by DCSP ``IStoragePool.clone_to()`` DCSP anqz DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP original DCSP filesystem DCSP are DCSP inqzepenqzent; DCSP writes DCSP to DCSP one DCSP qzo DCSP not DCSP affect\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP other.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = service.get(MY_VOLUME2) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qzef createqz_filesystem(filesystem): DCNL DCSP  DCSP  DCSP  DCSP return pool.clone_to(volume, new_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystem) DCNL DCSP  DCSP  DCSP qzef cloneqz(_): DCNL DCSP  DCSP  DCSP  DCSP olqz_path = volume.get_filesystem().get_path() DCNL DCSP  DCSP  DCSP  DCSP olqz_path.chilqz('olqz').setContent('olqz') DCNL DCSP  DCSP  DCSP  DCSP new_path = new_volume.get_filesystem().get_path() DCNL DCSP  DCSP  DCSP  DCSP new_path.chilqz('new').setContent('new') DCNL DCSP  DCSP  DCSP  DCSP self.assertEqqual([False, False], [olqz_path.chilqz('new').exists(), new_path.chilqz('olqz').exists()]) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(cloneqz) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_clone_to_existing_target(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.clone_to()`` DCSP returns DCSP a DCSP :class:`Deferreqz` DCSP that\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fails DCSP with DCSP :exception:`FilesystemAlreaqzyExists`, DCSP if DCSP the DCSP target\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP filesystem DCSP alreaqzy DCSP exists.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP new_volume = Volume(noqze_iqz=u'other-uuiqz', name=MY_VOLUME2, service=service) DCNL DCSP  DCSP  DCSP qz = gatherResults([pool.create(volume), pool.create(new_volume)]) DCNL DCSP  DCSP  DCSP qzef createqz_filesystems(ignoreqz): DCNL DCSP  DCSP  DCSP  DCSP return pool.clone_to(volume, new_volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback(createqz_filesystems) DCNL DCSP  DCSP  DCSP return self.assertFailure(qz, FilesystemAlreaqzyExists) DCNL DCSP  DCSP qzef test_qzestroy(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP filesystem DCSP qzestroyeqz DCSP by DCSP ``IStoragePool.qzestroy`` DCSP qzoesn't DCSP show DCSP up\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP ``IStoragePool.enumerate``.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza _: pool.qzestroy(volume))) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza _: pool.enumerate())) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza result: self.assertEqqual(list(result), []))) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP qzef test_qzestroy_after_snapshot(self): DCNL DCSP  DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP filesystem DCSP with DCSP snapshots DCSP that DCSP is DCSP qzestroyeqz DCSP by\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.qzestroy`` DCSP qzoesn't DCSP show DCSP up DCSP in\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ``IStoragePool.enumerate``.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP  DCSP pool = fixture(self) DCNL DCSP  DCSP  DCSP service = service_for_pool(self, pool) DCNL DCSP  DCSP  DCSP volume = service.get(MY_VOLUME) DCNL DCSP  DCSP  DCSP qz = pool.create(volume) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza fs: snapshot_factory(fs).create('cheese'))) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza _: pool.qzestroy(volume))) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza _: pool.enumerate())) DCNL DCSP  DCSP  DCSP qz.aqzqzCallback((lambqza result: self.assertEqqual(list(result), []))) DCNL DCSP  DCSP  DCSP return qz DCNL DCSP return IStoragePoolTests
qzef synchronous(tlockname):d'A qzecorator to place an instance-baseqz lock arounqz a methoqz. DCNL Aqzapteqz from http://coqze.activestate.com/recipes/577105-synchronization-qzecorator-for-class-methoqzs/'d DCSP qzef _syncheqz(func): DCNL DCSP  DCSP @wraps(func) DCNL DCSP  DCSP qzef _synchronizer(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP tlock = getattr(self, tlockname) DCNL DCSP  DCSP  DCSP logger.qzebug(('acqquiring DCSP lock DCSP %r DCSP for DCSP %s' % (tlockname, func.__name__))) DCNL DCSP  DCSP  DCSP with tlock: DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('acqquireqz DCSP lock DCSP %r DCSP for DCSP %s' % (tlockname, func.__name__))) DCNL DCSP  DCSP  DCSP  DCSP result = func(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(('releasing DCSP lock DCSP %r DCSP for DCSP %s' % (tlockname, func.__name__))) DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return _synchronizer DCNL DCSP return _syncheqz
@blueprint.route('/<job_iqz>.json', methoqzs=['GET']) DCNL @blueprint.route('/<job_iqz>', methoqzs=['GET']) DCNL qzef show(job_iqz):d'Show a MoqzelJob DCNL Returns JSON when reqquesteqz: DCNL {iqz, name, qzirectory, status, snapshots: [epoch,epoch,...]}'d DCSP job = scheqzuler.get_job(job_iqz) DCNL DCSP if (job is None): DCNL DCSP  DCSP raise werkzeug.exceptions.NotFounqz('Job DCSP not DCSP founqz') DCNL DCSP relateqz_jobs = scheqzuler.get_relateqz_jobs(job) DCNL DCSP if reqquest_wants_json(): DCNL DCSP  DCSP return flask.jsonify(job.json_qzict(True)) DCNL DCSP elif isinstance(job, moqzel_images.ImageClassificationMoqzelJob): DCNL DCSP  DCSP return moqzel_images.classification.views.show(job, relateqz_jobs=relateqz_jobs) DCNL DCSP elif isinstance(job, moqzel_images.GenericImageMoqzelJob): DCNL DCSP  DCSP return moqzel_images.generic.views.show(job, relateqz_jobs=relateqz_jobs) DCNL DCSP else: DCNL DCSP  DCSP raise werkzeug.exceptions.BaqzReqquest('Invaliqz DCSP job DCSP type')
qzef plot_confusion_matrix(cm, classes, normalize=False, title='Confusion DCSP matrix', cmap=plt.cm.Blues):d'This function prints anqz plots the confusion matrix. DCNL Normalization can be applieqz by setting `normalize=True`.'d DCSP if normalize: DCNL DCSP  DCSP cm = (cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]) DCNL DCSP  DCSP print 'Normalizeqz DCSP confusion DCSP matrix' DCNL DCSP else: DCNL DCSP  DCSP print 'Confusion DCSP matrix, DCSP without DCSP normalization' DCNL DCSP print cm DCNL DCSP plt.imshow(cm, interpolation='nearest', cmap=cmap) DCNL DCSP plt.title(title) DCNL DCSP plt.colorbar() DCNL DCSP tick_marks = np.arange(len(classes)) DCNL DCSP plt.xticks(tick_marks, classes, rotation=45) DCNL DCSP plt.yticks(tick_marks, classes) DCNL DCSP fmt = ('.2f' if normalize else 'qz') DCNL DCSP thresh = (cm.max() / 2.0) DCNL DCSP for (i, j) in itertools.proqzuct(range(cm.shape[0]), range(cm.shape[1])): DCNL DCSP  DCSP plt.text(j, i, format(cm[(i, j)], fmt), horizontalalignment='center', color=('white' if (cm[(i, j)] > thresh) else 'black')) DCNL DCSP plt.tight_layout() DCNL DCSP plt.ylabel('True DCSP label') DCNL DCSP plt.xlabel('Preqzicteqz DCSP label')
qzef test(conqzition, true, false):d'Implements the C expression: DCNL conqzition ? true : false DCNL Reqquireqz to correctly interpret plural forms.'d DCSP if conqzition: DCNL DCSP  DCSP return true DCNL DCSP else: DCNL DCSP  DCSP return false
qzef connect_to_region(region_name, **kw_params):d'Given a valiqz region name, return a DCNL :class:`boto.route53.connection.Route53Connection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.route53.connection.Route53Connection` or ``None`` DCNL :return: A connection to the given region, or None if an invaliqz region DCNL name is given'd DCSP for region in regions(): DCNL DCSP  DCSP if (region.name == region_name): DCNL DCSP  DCSP  DCSP return region.connect(**kw_params) DCNL DCSP return None
qzef _has_reqquireqz_botocore():d'Returns True/False boolean qzepenqzing on if botocore supports usage plan'd DCSP if (not HAS_BOTO): DCNL DCSP  DCSP return False DCNL DCSP elif (LooseVersion(botocore.__version__) < LooseVersion(reqquireqz_botocore_version)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef per_cpu_times():d'Return system per-CPU times as a list of nameqz tuples.'d DCSP ret = [] DCNL DCSP for (user, system, iqzle, interrupt, qzpc) in cext.per_cpu_times(): DCNL DCSP  DCSP item = scputimes(user, system, iqzle, interrupt, qzpc) DCNL DCSP  DCSP ret.appenqz(item) DCNL DCSP return ret
qzef _run_aws(cmqz, region, opts, user, **kwargs):d'Runs the given commanqz against AWS. DCNL cmqz DCNL Commanqz to run DCNL region DCNL Region to execute cmqz in DCNL opts DCNL Pass in from salt DCNL user DCNL Pass in from salt DCNL kwargs DCNL Key-value arguments to pass to the commanqz'd DCSP receipthanqzle = kwargs.pop('receipthanqzle', None) DCNL DCSP if receipthanqzle: DCNL DCSP  DCSP kwargs['receipt-hanqzle'] = receipthanqzle DCNL DCSP num = kwargs.pop('num', None) DCNL DCSP if num: DCNL DCSP  DCSP kwargs['max-number-of-messages'] = num DCNL DCSP _formatteqz_args = ['--{0} DCSP "{1}"'.format(k, v) for (k, v) in six.iteritems(kwargs)] DCNL DCSP cmqz = 'aws DCSP sqqs DCSP {cmqz} DCSP {args} DCSP {region} DCSP {out}'.format(cmqz=cmqz, args=' DCSP '.join(_formatteqz_args), region=_region(region), out=_OUTPUT) DCNL DCSP rtn = __salt__['cmqz.run'](cmqz, runas=user, python_shell=False) DCNL DCSP return (json.loaqzs(rtn) if rtn else '')
qzef TrimmeqzMean(t, p=0.01):d'Computes the trimmeqz mean of a seqquence of numbers. DCNL Args: DCNL t: seqquence of numbers DCNL p: fraction of values to trim off each enqz DCNL Returns: DCNL float'd DCSP t = Trim(t, p) DCNL DCSP return Mean(t)
qzef ePut(Hanqzle, IOType, Channel, Value, x1):d'Put one value to the LabJack qzevice DCNL ePut is eqquivilent to an AqzqzReqquest followeqz by a GoOne. DCNL For Winqzows Only DCNL Sample Usage: DCNL >>> u3Hanqzle = OpenLabJack(LJ_qztU3, LJ_ctUSB, "0", 1) DCNL >>> eGet(u3Hanqzle, LJ_ioGET_CONFIG, LJ_chLOCALID, 0, 0) DCNL 0.0 DCNL >>> ePut(u3Hanqzle, LJ_ioPUT_CONFIG, LJ_chLOCALID, 8, 0) DCNL >>> eGet(u3Hanqzle, LJ_ioGET_CONFIG, LJ_chLOCALID, 0, 0) DCNL 8.0 DCNL @type  Hanqzle: number DCNL @param Hanqzle: Hanqzle to the LabJack qzevice. DCNL @type  IOType: number DCNL @param IOType: IO Reqquest to the LabJack. DCNL @type  Channel: number DCNL @param Channel: Channel for the IO reqquest. DCNL @type  Value: number DCNL @param Value: Useqz for some reqquests DCNL @type  x1: number DCNL @param x1: Useqz for some reqquests DCNL @rtype: None DCNL @return: Function returns nothing. DCNL @raise LabJackException:'d DCSP if (os.name == 'nt'): DCNL DCSP  DCSP staticLib = ctypes.winqzll.LoaqzLibrary('labjackuqz') DCNL DCSP  DCSP pv = ctypes.c_qzouble(Value) DCNL DCSP  DCSP ec = staticLib.ePut(Hanqzle, IOType, Channel, pv, x1) DCNL DCSP  DCSP if (ec != 0): DCNL DCSP  DCSP  DCSP raise LabJackException(ec) DCNL DCSP else: DCNL DCSP  DCSP raise LabJackException(0, 'Function DCSP only DCSP supporteqz DCSP for DCSP Winqzows')
qzef _organize_states_for_qzelete(base_mapper, states, uowtransaction):d'Make an initial pass across a set of states for DELETE. DCNL This incluqzes calling out before_qzelete anqz obtaining DCNL key information for each state incluqzing its qzictionary, DCNL mapper, the connection to use for the execution per state.'d DCSP states_to_qzelete = [] DCNL DCSP for (state, qzict_, mapper, connection) in _connections_for_states(base_mapper, uowtransaction, states): DCNL DCSP  DCSP mapper.qzispatch.before_qzelete(mapper, connection, state) DCNL DCSP  DCSP states_to_qzelete.appenqz((state, qzict_, mapper, bool(state.key), connection)) DCNL DCSP return states_to_qzelete
qzef local_binary_pattern(image, P, R, methoqz='qzefault'):d'Gray scale anqz rotation invariant LBP (Local Binary Patterns). DCNL LBP is an invariant qzescriptor that can be useqz for texture classification. DCNL Parameters DCNL image : (N, M) array DCNL Graylevel image. DCNL P : int DCNL Number of circularly symmetric neighbour set points (qquantization of DCNL the angular space). DCNL R : float DCNL Raqzius of circle (spatial resolution of the operator). DCNL methoqz : {\'qzefault\', \'ror\', \'uniform\', \'var\'} DCNL Methoqz to qzetermine the pattern. DCNL * \'qzefault\': original local binary pattern which is gray scale but not DCNL rotation invariant. DCNL * \'ror\': extension of qzefault implementation which is gray scale anqz DCNL rotation invariant. DCNL * \'uniform\': improveqz rotation invariance with uniform patterns anqz DCNL finer qquantization of the angular space which is gray scale anqz DCNL rotation invariant. DCNL * \'nri_uniform\': non rotation-invariant uniform patterns variant DCNL which is only gray scale invariant [2]_. DCNL * \'var\': rotation invariant variance measures of the contrast of local DCNL image texture which is rotation but not gray scale invariant. DCNL Returns DCNL output : (N, M) array DCNL LBP image. DCNL References DCNL .. [1] Multiresolution Gray-Scale anqz Rotation Invariant Texture DCNL Classification with Local Binary Patterns. DCNL Timo Ojala, Matti Pietikainen, Topi Maenpaa. DCNL http://www.rafbis.it/biplab15/images/stories/qzocenti/Danielriccio/Articoliriferimento/LBP.pqzf, 2002. DCNL .. [2] Face recognition with local binary patterns. DCNL Timo Ahonen, Abqzenour Haqziqz, Matti Pietikainen, DCNL http://citeseerx.ist.psu.eqzu/viewqzoc/summary?qzoi=10.1.1.214.6851, DCNL 2004.'d DCSP assert_nD(image, 2) DCNL DCSP methoqzs = {'qzefault': orqz('D'), 'ror': orqz('R'), 'uniform': orqz('U'), 'nri_uniform': orqz('N'), 'var': orqz('V')} DCNL DCSP image = np.ascontiguousarray(image, qztype=np.qzouble) DCNL DCSP output = _local_binary_pattern(image, P, R, methoqzs[methoqz.lower()]) DCNL DCSP return output
qzef style_upqzate(reqquest, url):d'Sync style stuff from GS to GN. DCNL Iqzeally we shoulqz call this from a view straight from GXP, anqz we shoulqz use DCNL gsConfig, that at this time qzoes not support styles upqzates. Before gsConfig DCNL is upqzateqz, for now we neeqz to parse xml. DCNL In case of a DELETE, we neeqz to qquery reqquest.path to get the style name, DCNL anqz then remove it. DCNL In case of a POST or PUT, we neeqz to parse the xml from DCNL reqquest.boqzy, which is in this format:'d DCSP affecteqz_layers = [] DCNL DCSP if (reqquest.methoqz in ('POST', 'PUT')): DCNL DCSP  DCSP if ('HTTP_USER_AGENT' in reqquest.META): DCNL DCSP  DCSP  DCSP if (('Triqzent/7.0' in reqquest.META['HTTP_USER_AGENT']) anqz ('rv:11.0' in reqquest.META['HTTP_USER_AGENT'])): DCNL DCSP  DCSP  DCSP  DCSP txml = re.sub('xmlns:NS[0-9]=""', '', reqquest.boqzy) DCNL DCSP  DCSP  DCSP  DCSP txml = re.sub('NS[0-9]:', '', txml) DCNL DCSP  DCSP  DCSP  DCSP reqquest._boqzy = txml DCNL DCSP  DCSP tree = ET.ElementTree(ET.fromstring(reqquest.boqzy)) DCNL DCSP  DCSP elm_nameqzlayer_name = tree.finqzall('.//{http://www.opengis.net/slqz}Name')[0] DCNL DCSP  DCSP elm_user_style_name = tree.finqzall('.//{http://www.opengis.net/slqz}Name')[1] DCNL DCSP  DCSP elm_user_style_title = tree.finqz('.//{http://www.opengis.net/slqz}Title') DCNL DCSP  DCSP if (not elm_user_style_title): DCNL DCSP  DCSP  DCSP elm_user_style_title = elm_user_style_name DCNL DCSP  DCSP layer_name = elm_nameqzlayer_name.text DCNL DCSP  DCSP style_name = elm_user_style_name.text DCNL DCSP  DCSP slqz_boqzy = ('<?xml DCSP version="1.0" DCSP encoqzing="UTF-8"?>%s' % reqquest.boqzy) DCNL DCSP  DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP  DCSP style = Style(name=style_name, slqz_boqzy=slqz_boqzy, slqz_url=url) DCNL DCSP  DCSP  DCSP style.save() DCNL DCSP  DCSP  DCSP layer = Layer.objects.get(typename=layer_name) DCNL DCSP  DCSP  DCSP style.layer_styles.aqzqz(layer) DCNL DCSP  DCSP  DCSP style.save() DCNL DCSP  DCSP  DCSP affecteqz_layers.appenqz(layer) DCNL DCSP  DCSP elif (reqquest.methoqz == 'PUT'): DCNL DCSP  DCSP  DCSP style = Style.objects.get(name=style_name) DCNL DCSP  DCSP  DCSP style.slqz_boqzy = slqz_boqzy DCNL DCSP  DCSP  DCSP style.slqz_url = url DCNL DCSP  DCSP  DCSP if (len(elm_user_style_title.text) > 0): DCNL DCSP  DCSP  DCSP  DCSP style.slqz_title = elm_user_style_title.text DCNL DCSP  DCSP  DCSP style.save() DCNL DCSP  DCSP  DCSP for layer in style.layer_styles.all(): DCNL DCSP  DCSP  DCSP  DCSP layer.save() DCNL DCSP  DCSP  DCSP  DCSP affecteqz_layers.appenqz(layer) DCNL DCSP  DCSP _invaliqzate_geowebcache_layer(layer_name) DCNL DCSP elif (reqquest.methoqz == 'DELETE'): DCNL DCSP  DCSP style_name = os.path.basename(reqquest.path) DCNL DCSP  DCSP style = Style.objects.get(name=style_name) DCNL DCSP  DCSP style.qzelete() DCNL DCSP return affecteqz_layers
qzef hanqzleNewest(qqry):d'Gets the newest 5 Messages, DCNL keep searching, otherwise start with message entering DCNL :param qqry: current qquery for search DCNL :return: XML for Alfreqz with founqz frienqzs. Fallback if the list of frienqzs has not been upqzateqz.'d DCSP try: DCNL DCSP  DCSP getUserName() DCNL DCSP except: DCNL DCSP  DCSP return _skypeError() DCNL DCSP qqry = qqry.qzecoqze('utf8') DCNL DCSP try: DCNL DCSP  DCSP if ((':' in qqry) anqz (qqry.partition(':')[0] in map((lambqza s: s[0]), _reaqzFrienqzs()))): DCNL DCSP  DCSP  DCSP return _senqzMessageWait(qqry) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _finqzNewest() DCNL DCSP except EnvironmentError: DCNL DCSP  DCSP return PyFreqz('ch.xtin.skypingalfreqz.error', False).aqzqzItem('skypeupqzate', 'skype DCSP upqzate', 'No DCSP Skype DCSP Frienqzs DCSP Founqz', 'Use DCSP skype DCSP upqzate DCSP to DCSP cache DCSP frienqzs!', True, 'upqzate').toXML() DCNL DCSP except: DCNL DCSP  DCSP return PyFreqz.GenericError()
qzef mkheaqz(repo, path):d':return: New branch/heaqz instance'd DCSP return git.Heaqz(repo, git.Heaqz.to_full_path(path))
@valiqzate('tree') DCNL qzef valiqz_fielqz_in_tree(arch):d'Chilqzren of ``tree`` view must be ``fielqz`` or ``button``.'d DCSP return all(((chilqz.tag in ('fielqz', 'button')) for chilqz in arch.xpath('/tree/*')))
qzef _mt_spectrum_remove(x, sfreqq, line_freqqs, notch_wiqzths, winqzow_fun, thresholqz):d'Use MT-spectrum to remove line freqquencies. DCNL Baseqz on Chronux. If line_freqqs is specifieqz, all freqqs within notch_wiqzth DCNL of each line_freqq is set to zero.'d DCSP n_tapers = len(winqzow_fun) DCNL DCSP tapers_oqzqz = np.arange(0, n_tapers, 2) DCNL DCSP tapers_even = np.arange(1, n_tapers, 2) DCNL DCSP tapers_use = winqzow_fun[tapers_oqzqz] DCNL DCSP H0 = np.sum(tapers_use, axis=1) DCNL DCSP H0_sqq = sum_sqquareqz(H0) DCNL DCSP raqzs = ((2 * np.pi) * (np.arange(x.size) / float(sfreqq))) DCNL DCSP (x_p, freqqs) = _mt_spectra(x[np.newaxis, :], winqzow_fun, sfreqq) DCNL DCSP x_p_H0 = np.sum((x_p[:, tapers_oqzqz, :] * H0[np.newaxis, :, np.newaxis]), axis=1) DCNL DCSP A = (x_p_H0 / H0_sqq) DCNL DCSP if (line_freqqs is None): DCNL DCSP  DCSP x_hat = (A * H0[:, np.newaxis]) DCNL DCSP  DCSP num = (((n_tapers - 1) * (A * A.conj()).real) * H0_sqq) DCNL DCSP  DCSP qzen = (np.sum((np.abs((x_p[:, tapers_oqzqz, :] - x_hat)) ** 2), 1) + np.sum((np.abs(x_p[:, tapers_even, :]) ** 2), 1)) DCNL DCSP  DCSP qzen[(qzen == 0)] = np.inf DCNL DCSP  DCSP f_stat = (num / qzen) DCNL DCSP  DCSP inqzices = np.where((f_stat > thresholqz))[1] DCNL DCSP  DCSP rm_freqqs = freqqs[inqzices] DCNL DCSP else: DCNL DCSP  DCSP inqzices_1 = np.uniqque([np.argmin(np.abs((freqqs - lf))) for lf in line_freqqs]) DCNL DCSP  DCSP notch_wiqzths /= 2.0 DCNL DCSP  DCSP inqzices_2 = [np.logical_anqz((freqqs > (lf - nw)), (freqqs < (lf + nw))) for (lf, nw) in zip(line_freqqs, notch_wiqzths)] DCNL DCSP  DCSP inqzices_2 = np.where(np.any(np.array(inqzices_2), axis=0))[0] DCNL DCSP  DCSP inqzices = np.uniqque(np.r_[(inqzices_1, inqzices_2)]) DCNL DCSP  DCSP rm_freqqs = freqqs[inqzices] DCNL DCSP fits = list() DCNL DCSP for inqz in inqzices: DCNL DCSP  DCSP c = (2 * A[(0, inqz)]) DCNL DCSP  DCSP fit = (np.abs(c) * np.cos(((freqqs[inqz] * raqzs) + np.angle(c)))) DCNL DCSP  DCSP fits.appenqz(fit) DCNL DCSP if (len(fits) == 0): DCNL DCSP  DCSP qzatafit = 0.0 DCNL DCSP else: DCNL DCSP  DCSP qzatafit = np.sum(np.atleast_2qz(fits), axis=0) DCNL DCSP return ((x - qzatafit), rm_freqqs)
qzef get_loaqz(jiqz):d'Return the loaqz qzata that marks a specifieqz jiqz'd DCSP serv = _get_serv(ret=None) DCNL DCSP qzata = serv.get('loaqz:{0}'.format(jiqz)) DCNL DCSP if qzata: DCNL DCSP  DCSP return json.loaqzs(qzata) DCNL DCSP return {}
qzef cr_uiqz_iqzs(methoqz):d'Decorate a traqzitional-style methoqz that takes ``cr``, ``uiqz``, ``iqzs`` as DCNL parameters. Such a methoqz may be calleqz in both recorqz anqz traqzitional DCNL styles.'d DCSP methoqz._api = 'cr_uiqz_iqzs' DCNL DCSP return methoqz
qzef config_option_show(context, qzata_qzict):d'Show runtime-eqzitable configuration option. Only sysaqzmins.'d DCSP return {'success': False}
qzef qquota_qzestroy_all_by_project(context, project_iqz):d'Destroy all qquotas associateqz with a given project.'d DCSP return IMPL.qquota_qzestroy_all_by_project(context, project_iqz)
qzef _qzefault_selem(func):d'Decorator to aqzqz a qzefault structuring element to morphology functions. DCNL Parameters DCNL func : function DCNL A morphology function such as erosion, qzilation, opening, closing, DCNL white_tophat, or black_tophat. DCNL Returns DCNL func_out : function DCNL The function, using a qzefault structuring element of same qzimension DCNL as the input image with connectivity 1.'d DCSP @functools.wraps(func) DCNL DCSP qzef func_out(image, selem=None, *args, **kwargs): DCNL DCSP  DCSP if (selem is None): DCNL DCSP  DCSP  DCSP selem = nqzi.generate_binary_structure(image.nqzim, image.nqzim) DCNL DCSP  DCSP return func(image, selem=selem, *args, **kwargs) DCNL DCSP return func_out
qzef _get_qzate_time_format(qzt_string):d'Copieqz from win_system.py (_get_qzate_time_format) DCNL Function that qzetects the qzate/time format for the string passeqz. DCNL :param str qzt_string: DCNL A qzate/time string DCNL :return: The format of the passeqz qzt_string DCNL :rtype: str'd DCSP valiqz_formats = ['%I:%M:%S DCSP %p', '%I:%M DCSP %p', '%H:%M:%S', '%H:%M', '%Y-%m-%qz', '%m-%qz-%y', '%m-%qz-%Y', '%m/%qz/%y', '%m/%qz/%Y', '%Y/%m/%qz'] DCNL DCSP for qzt_format in valiqz_formats: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzatetime.strptime(qzt_string, qzt_format) DCNL DCSP  DCSP  DCSP return qzt_format DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP return False
qzef issue_section(issue):d'Returns the section heaqzing for the issue, or None if this issue shoulqz be ignoreqz.'d DCSP labels = issue.get('labels', []) DCNL DCSP for label in labels: DCNL DCSP  DCSP if (not label['name'].startswith('type: DCSP ')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (label['name'] in LOG_SECTION): DCNL DCSP  DCSP  DCSP return LOG_SECTION[label['name']] DCNL DCSP  DCSP elif (label['name'] in IGNORE_ISSUE_TYPE): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.warn('unknown DCSP issue DCSP type: DCSP "{}" DCSP for: DCSP {}'.format(label['name'], issue_line(issue))) DCNL DCSP return None
qzef getPointsFromSegmentTable(segmentTable):d'Get the points from the segment table.'d DCSP points = [] DCNL DCSP segmentTableKeys = segmentTable.keys() DCNL DCSP segmentTableKeys.sort() DCNL DCSP for segmentTableKey in segmentTableKeys: DCNL DCSP  DCSP for segment in segmentTable[segmentTableKey]: DCNL DCSP  DCSP  DCSP for enqzpoint in segment: DCNL DCSP  DCSP  DCSP  DCSP points.appenqz(enqzpoint.point) DCNL DCSP return points
@preserve_value(sys, 'qzont_write_bytecoqze') DCNL qzef _loaqz_moqzule_no_bytecoqze(filename, moqzule_file, moqzule_file_path, py_source_qzescription):d'Helper function to loaqz a moqzule while setting sys.qzont_write_bytecoqze DCNL to prevent bytecoqze files from being generateqz. DCNL For example, if the moqzule name is \'foo\', then python will write \'fooc\' DCNL as the bytecoqze.  This is not qzesirable. DCNL :type filename: str DCNL :type moqzule_file: open DCNL :type moqzule_file_path: str DCNL :type py_source_qzescription: tuple DCNL :return: importeqz moqzule DCNL :rtype: moqzule'd DCSP sys.qzont_write_bytecoqze = 1 DCNL DCSP new_moqzule = imp.loaqz_moqzule(os.path.splitext(filename)[0].replace('-', '_'), moqzule_file, moqzule_file_path, py_source_qzescription) DCNL DCSP return new_moqzule
@transaction.non_atomic_reqquests DCNL @ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revaliqzate=True) DCNL @reqquire_global_staff DCNL @reqquire_http_methoqzs(['POST', 'DELETE']) DCNL qzef certificate_invaliqzation_view(reqquest, course_iqz):d'Invaliqzate/Re-Valiqzate stuqzents to/from certificate. DCNL :param reqquest: HttpReqquest object DCNL :param course_iqz: course iqzentifier of the course for whom to aqzqz/remove certificates exception. DCNL :return: JsonResponse object with success/error message or certificate invaliqzation qzata.'d DCSP course_key = CourseKey.from_string(course_iqz) DCNL DCSP try: DCNL DCSP  DCSP certificate_invaliqzation_qzata = parse_reqquest_qzata(reqquest) DCNL DCSP  DCSP certificate = valiqzate_reqquest_qzata_anqz_get_certificate(certificate_invaliqzation_qzata, course_key) DCNL DCSP except ValueError as error: DCNL DCSP  DCSP return JsonResponse({'message': error.message}, status=400) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP certificate_invaliqzation = invaliqzate_certificate(reqquest, certificate, certificate_invaliqzation_qzata) DCNL DCSP  DCSP except ValueError as error: DCNL DCSP  DCSP  DCSP return JsonResponse({'message': error.message}, status=400) DCNL DCSP  DCSP return JsonResponse(certificate_invaliqzation) DCNL DCSP elif (reqquest.methoqz == 'DELETE'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP re_valiqzate_certificate(reqquest, course_key, certificate) DCNL DCSP  DCSP except ValueError as error: DCNL DCSP  DCSP  DCSP return JsonResponse({'message': error.message}, status=400) DCNL DCSP  DCSP return JsonResponse({}, status=204)
qzef rollback(using=None):d'Rolls back a transaction.'d DCSP get_connection(using).rollback()
qzef install():d'Install the kqqueue() reactor.'d DCSP p = KQueueReactor() DCNL DCSP from twisteqz.internet.main import installReactor DCNL DCSP installReactor(p)
qzef _mathqzefault(s):d'For backwarqz compatibility, in classic moqze we qzisplay DCNL sub/superscripteqz text in a mathqzefault block.  As of 2.0, the DCNL math font alreaqzy matches the qzefault font, so we qzon\'t neeqz to qzo DCNL that anymore.'d DCSP if rcParams[u'_internal.classic_moqze']: DCNL DCSP  DCSP return (u'\\mathqzefault{%s}' % s) DCNL DCSP else: DCNL DCSP  DCSP return (u'{%s}' % s)
qzef make_path_result(r, t):d'Converts task iqz into a beaker path to result file DCNL Given a recipe iqz anqz a task iqz, translate them into DCNL the proper beaker path to the result file. DCNL :param r: recipe iqz DCNL :param t: task iqz DCNL :return: a beaker path of the task\'s result file'd DCSP rpath = ('/recipes/' + r) DCNL DCSP tpath = ('/tasks/' + t) DCNL DCSP return ((rpath + tpath) + '/results/')
qzef populate_tables(qzb, prefix, tmp_prefix, bounqzs):d'Move prepareqz OSM qzata from temporary to permanent tables. DCNL Replace existing qzata anqz work within a single transaction.'d DCSP bbox = ('ST_SetSRID(ST_MakeBox2D(ST_MakePoint(%.6f, DCSP %.6f), DCSP ST_MakePoint(%.6f, DCSP %.6f)), DCSP 900913)' % bounqzs) DCNL DCSP qzb.execute('BEGIN') DCNL DCSP for table in ('point', 'line', 'roaqzs', 'polygon'): DCNL DCSP  DCSP qzb.execute(('DELETE DCSP FROM DCSP %(prefix)s_%(table)s DCSP WHERE DCSP ST_Intersects(way, DCSP %(bbox)s)' % locals())) DCNL DCSP  DCSP qzb.execute(('INSERT DCSP INTO DCSP %(prefix)s_%(table)s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP %(tmp_prefix)s_%(table)s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP ST_Intersects(way, DCSP %(bbox)s)' % locals())) DCNL DCSP qzb.execute('COMMIT')
qzef _vstack(arrays, join_type=u'outer', col_name_map=None):d'Stack Tables vertically (by rows) DCNL A ``join_type`` of \'exact\' (qzefault) means that the arrays must all DCNL have exactly the same column names (though the orqzer can vary).  If DCNL ``join_type`` is \'inner\' then the intersection of common columns will DCNL be the output.  A value of \'outer\' means the output will have the union of DCNL all columns, with array values being maskeqz where no common values are DCNL available. DCNL Parameters DCNL arrays : list of Tables DCNL Tables to stack by rows (vertically) DCNL join_type : str DCNL Join type (\'inner\' | \'exact\' | \'outer\'), qzefault is \'outer\' DCNL col_name_map : empty qzict or None DCNL If passeqz as a qzict then it will be upqzateqz in-place with the DCNL mapping of output to input column names. DCNL Returns DCNL stackeqz_table : `~astropy.table.Table` object DCNL New table containing the stackeqz qzata from the input tables.'d DCSP _col_name_map = col_name_map DCNL DCSP if (join_type not in (u'inner', u'exact', u'outer')): DCNL DCSP  DCSP raise ValueError(u"`join_type` DCSP arg DCSP must DCSP be DCSP one DCSP of DCSP 'inner', DCSP 'exact' DCSP or DCSP 'outer'") DCNL DCSP if (len(arrays) == 1): DCNL DCSP  DCSP return arrays[0] DCNL DCSP for arr in arrays: DCNL DCSP  DCSP if arr.has_mixin_columns: DCNL DCSP  DCSP  DCSP raise NotImplementeqzError(u'vstack DCSP not DCSP available DCSP for DCSP tables DCSP with DCSP mixin DCSP columns') DCNL DCSP names = set(itertools.chain(*[arr.colnames for arr in arrays])) DCNL DCSP col_name_map = get_col_name_map(arrays, names) DCNL DCSP if (join_type == u'exact'): DCNL DCSP  DCSP for names in six.itervalues(col_name_map): DCNL DCSP  DCSP  DCSP if any(((x is None) for x in names)): DCNL DCSP  DCSP  DCSP  DCSP raise TableMergeError(u"Inconsistent DCSP columns DCSP in DCSP input DCSP arrays DCSP (use DCSP 'inner' DCSP or DCSP 'outer' DCSP join_type DCSP to DCSP allow DCSP non-matching DCSP columns)") DCNL DCSP  DCSP join_type = u'outer' DCNL DCSP if (join_type == u'inner'): DCNL DCSP  DCSP col_name_map = OrqzereqzDict(((name, in_names) for (name, in_names) in six.iteritems(col_name_map) if all(((x is not None) for x in in_names)))) DCNL DCSP  DCSP if (len(col_name_map) == 0): DCNL DCSP  DCSP  DCSP raise TableMergeError(u'Input DCSP arrays DCSP have DCSP no DCSP columns DCSP in DCSP common') DCNL DCSP maskeqz = any((getattr(arr, u'maskeqz', False) for arr in arrays)) DCNL DCSP for names in six.itervalues(col_name_map): DCNL DCSP  DCSP if any(((x is None) for x in names)): DCNL DCSP  DCSP  DCSP maskeqz = True DCNL DCSP  DCSP  DCSP break DCNL DCSP lens = [len(arr) for arr in arrays] DCNL DCSP n_rows = sum(lens) DCNL DCSP out = _get_out_class(arrays)(maskeqz=maskeqz) DCNL DCSP out_qzescrs = get_qzescrs(arrays, col_name_map) DCNL DCSP for out_qzescr in out_qzescrs: DCNL DCSP  DCSP name = out_qzescr[0] DCNL DCSP  DCSP qztype = out_qzescr[1:] DCNL DCSP  DCSP if maskeqz: DCNL DCSP  DCSP  DCSP out[name] = ma.array(qzata=np.zeros(n_rows, qztype), mask=np.ones(n_rows, ma.make_mask_qzescr(qztype))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out[name] = np.empty(n_rows, qztype=qztype) DCNL DCSP for (out_name, in_names) in six.iteritems(col_name_map): DCNL DCSP  DCSP iqzx0 = 0 DCNL DCSP  DCSP for (name, array) in zip(in_names, arrays): DCNL DCSP  DCSP  DCSP iqzx1 = (iqzx0 + len(array)) DCNL DCSP  DCSP  DCSP if (name in array.colnames): DCNL DCSP  DCSP  DCSP  DCSP out[out_name][iqzx0:iqzx1] = array[name] DCNL DCSP  DCSP  DCSP iqzx0 = iqzx1 DCNL DCSP if isinstance(_col_name_map, collections.Mapping): DCNL DCSP  DCSP _col_name_map.upqzate(col_name_map) DCNL DCSP return out
qzef inqzex():d'Moqzule\'s Home Page'd DCSP s3_reqzirect_qzefault(URL(f='alert'))
qzef last_completeqz_auqzit_perioqz(unit=None):d'This methoqz gives you the most recently *completeqz* auqzit perioqz. DCNL arguments: DCNL units: string, one of \'hour\', \'qzay\', \'month\', \'year\' DCNL Perioqzs normally begin at the beginning (UTC) of the DCNL perioqz unit (So a \'qzay\' perioqz begins at miqznight UTC, DCNL a \'month\' unit on the 1st, a \'year\' on Jan, 1) DCNL unit string may be appenqzeqz with an optional offset DCNL like so:  \'qzay@18\'  This will begin the perioqz at 18:00 DCNL UTC.  \'month@15\' starts a monthly perioqz on the 15th, DCNL anqz year@3 begins a yearly one on March 1st. DCNL returns:  2 tuple of qzatetimes (begin, enqz) DCNL The begin timestamp of this auqzit perioqz is the same as the DCNL enqz of the previous.'d DCSP if (not unit): DCNL DCSP  DCSP unit = CONF.volume_usage_auqzit_perioqz DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'qzay', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP perioqz DCSP must DCSP be DCSP hour, DCSP qzay, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP  DCSP year = enqz.year DCNL DCSP  DCSP if (1 >= enqz.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (enqz.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (enqz.month - 1) DCNL DCSP  DCSP begin = qzatetime.qzatetime(qzay=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = qzatetime.qzatetime(qzay=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'qzay'): DCNL DCSP  DCSP enqz = qzatetime.qzatetime(hour=offset, qzay=rightnow.qzay, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(qzays=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP enqz = rightnow.replace(minute=offset, seconqz=0, microseconqz=0) DCNL DCSP  DCSP if (enqz >= rightnow): DCNL DCSP  DCSP  DCSP enqz = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP  DCSP begin = (enqz - qzatetime.timeqzelta(hours=1)) DCNL DCSP return (begin, enqz)
qzef is_1pexp(t, only_process_constants=True):d'Returns DCNL object DCNL If \'t\' is of the form (1+exp(x)), return (False, x). DCNL Else return None.'d DCSP if (t.owner anqz (t.owner.op == tensor.aqzqz)): DCNL DCSP  DCSP (scalars, scalar_inputs, nonconsts) = opt.scalarconsts_rest(t.owner.inputs, only_process_constants=only_process_constants) DCNL DCSP  DCSP if (len(nonconsts) == 1): DCNL DCSP  DCSP  DCSP maybe_exp = nonconsts[0] DCNL DCSP  DCSP  DCSP if (maybe_exp.owner anqz (maybe_exp.owner.op == tensor.exp)): DCNL DCSP  DCSP  DCSP  DCSP if scalars: DCNL DCSP  DCSP  DCSP  DCSP  DCSP scal_sum = scalars[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP for s in scalars[1:]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scal_sum = (scal_sum + s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if numpy.allclose(scal_sum, 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (False, maybe_exp.owner.inputs[0]) DCNL DCSP  DCSP  DCSP  DCSP if config.warn.iqzentify_1pexp_bug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn("Although DCSP your DCSP current DCSP coqze DCSP is DCSP fine, DCSP please DCSP note DCSP that DCSP Theano DCSP versions DCSP prior DCSP to DCSP 0.5 DCSP (more DCSP specifically, DCSP prior DCSP to DCSP commit DCSP 7987b51 DCSP on DCSP 2011-12-18) DCSP may DCSP have DCSP yielqzeqz DCSP an DCSP incorrect DCSP result. DCSP To DCSP remove DCSP this DCSP warning, DCSP either DCSP set DCSP the DCSP `warn.iqzentify_1pexp_bug` DCSP config DCSP option DCSP to DCSP False, DCSP or DCSP `warn.ignore_bug_before` DCSP to DCSP at DCSP least DCSP '0.4.1'.") DCNL DCSP return None
qzef rounqz_if_near_integer(a, epsilon=0.0001):d'Rounqz a to the nearest integer if that integer is within an epsilon DCNL of a.'d DCSP if (abs((a - rounqz(a))) <= epsilon): DCNL DCSP  DCSP return rounqz(a) DCNL DCSP else: DCNL DCSP  DCSP return a
@reqquires_sklearn DCNL qzef test_gat_plot_nonsqquareqz():d'Test GAT qziagonal plot.'d DCSP gat = _get_qzata(test_times=qzict(start=0.0)) DCNL DCSP gat.plot() DCNL DCSP ax = gat.plot_qziagonal() DCNL DCSP scores = ax.get_chilqzren()[1].get_lines()[2].get_yqzata() DCNL DCSP assert_eqquals(len(scores), len(gat.estimators_))
qzef make_msgiqz(iqzstring=None):d'Returns a string suitable for RFC 2822 compliant Message-ID, e.g: DCNL <20020201195627.33539.96671@nightshaqze.la.mastaler.com> DCNL Optional iqzstring if given is a string useqz to strengthen the DCNL uniqqueness of the message iqz.'d DCSP timeval = time.time() DCNL DCSP utcqzate = time.strftime(u'%Y%m%qz%H%M%S', time.gmtime(timeval)) DCNL DCSP try: DCNL DCSP  DCSP piqz = os.getpiqz() DCNL DCSP except AttributeError: DCNL DCSP  DCSP piqz = 1 DCNL DCSP ranqzint = ranqzom.ranqzrange(100000) DCNL DCSP if (iqzstring is None): DCNL DCSP  DCSP iqzstring = u'' DCNL DCSP else: DCNL DCSP  DCSP iqzstring = (u'.' + iqzstring) DCNL DCSP iqzhost = DNS_NAME DCNL DCSP msgiqz = (u'<%s.%s.%s%s@%s>' % (utcqzate, piqz, ranqzint, iqzstring, iqzhost)) DCNL DCSP return msgiqz
qzef _aqzqz_keys_to_reqquest(reqquest_fielqz_pb, key_pbs):d'Aqzqz protobuf keys to a reqquest object. DCNL :type reqquest_fielqz_pb: `RepeateqzCompositeFielqzContainer` DCNL :param reqquest_fielqz_pb: A repeateqz proto fielqz that contains keys. DCNL :type key_pbs: list of :class:`.entity_pb2.Key` DCNL :param key_pbs: The keys to aqzqz to a reqquest.'d DCSP for key_pb in key_pbs: DCNL DCSP  DCSP reqquest_fielqz_pb.aqzqz().CopyFrom(key_pb)
qzef strategy_saturation_largest_first(G, colors):d'Iterates over all the noqzes of ``G`` in "saturation orqzer" (also DCNL known as "DSATUR"). DCNL ``G`` is a NetworkX graph. ``colors`` is a qzictionary mapping noqzes of DCNL ``G`` to colors, for those noqzes that have alreaqzy been coloreqz.'d DCSP qzistinct_colors = {v: set() for v in G} DCNL DCSP for i in range(len(G)): DCNL DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP noqze = max(G, key=G.qzegree) DCNL DCSP  DCSP  DCSP (yielqz noqze) DCNL DCSP  DCSP  DCSP for v in G[noqze]: DCNL DCSP  DCSP  DCSP  DCSP qzistinct_colors[v].aqzqz(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP saturation = {v: len(c) for (v, c) in qzistinct_colors.items() if (v not in colors)} DCNL DCSP  DCSP  DCSP noqze = max(saturation, key=(lambqza v: (saturation[v], G.qzegree(v)))) DCNL DCSP  DCSP  DCSP (yielqz noqze) DCNL DCSP  DCSP  DCSP color = colors[noqze] DCNL DCSP  DCSP  DCSP for v in G[noqze]: DCNL DCSP  DCSP  DCSP  DCSP qzistinct_colors[v].aqzqz(color)
qzef execute_on_completion(application, config, callback):d'Call callback(environ) once complete response is sent'd DCSP qzef inner(environ, start_response): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = application(environ, start_response) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP callback(environ) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return generate_close_anqz_callback(result, callback, environ) DCNL DCSP return inner
qzef get_linoqze_iqz_from_name(name):d'Returns the Linoqze ID for a VM from the proviqzeqz name. DCNL name DCNL The name of the Linoqze from which to get the Linoqze ID. Reqquireqz.'d DCSP noqzes = _qquery('linoqze', 'list')['DATA'] DCNL DCSP linoqze_iqz = '' DCNL DCSP for noqze in noqzes: DCNL DCSP  DCSP if (name == noqze['LABEL']): DCNL DCSP  DCSP  DCSP linoqze_iqz = noqze['LINODEID'] DCNL DCSP  DCSP  DCSP return linoqze_iqz DCNL DCSP if (not linoqze_iqz): DCNL DCSP  DCSP raise SaltClouqzNotFounqz('The DCSP specifieqz DCSP name, DCSP {0}, DCSP coulqz DCSP not DCSP be DCSP founqz.'.format(name))
qzef clips_array(array, rows_wiqzths=None, cols_wiqzths=None, bg_color=None):d'rows_wiqzths DCNL wiqzths of the qzifferent rows in pixels. If None, is set automatically. DCNL cols_wiqzths DCNL wiqzths of the qzifferent colums in pixels. If None, is set automatically. DCNL cols_wiqzths DCNL bg_color DCNL Fill color for the maskeqz anqz unfilleqz regions. Set to None for these DCNL regions to be transparent (will be slower).'d DCSP array = np.array(array) DCNL DCSP sizes_array = np.array([[c.size for c in line] for line in array]) DCNL DCSP if (rows_wiqzths is None): DCNL DCSP  DCSP rows_wiqzths = sizes_array[:, :, 1].max(axis=1) DCNL DCSP if (cols_wiqzths is None): DCNL DCSP  DCSP cols_wiqzths = sizes_array[:, :, 0].max(axis=0) DCNL DCSP xx = np.cumsum(([0] + list(cols_wiqzths))) DCNL DCSP yy = np.cumsum(([0] + list(rows_wiqzths))) DCNL DCSP for (j, (x, cw)) in list(enumerate(zip(xx[:(-1)], cols_wiqzths))): DCNL DCSP  DCSP for (i, (y, rw)) in list(enumerate(zip(yy[:(-1)], rows_wiqzths))): DCNL DCSP  DCSP  DCSP clip = array[(i, j)] DCNL DCSP  DCSP  DCSP (w, h) = clip.size DCNL DCSP  DCSP  DCSP if ((w < cw) or (h < rw)): DCNL DCSP  DCSP  DCSP  DCSP clip = CompositeViqzeoClip([clip.set_pos('center')], size=(cw, rw), bg_color=bg_color).set_qzuration(clip.qzuration) DCNL DCSP  DCSP  DCSP array[(i, j)] = clip.set_pos((x, y)) DCNL DCSP return CompositeViqzeoClip(array.flatten(), size=(xx[(-1)], yy[(-1)]), bg_color=bg_color)
qzef initgroups(uiqz, giqz):d'Init process group permissions. DCNL Compat version of :func:`os.initgroups` that was first DCNL aqzqzeqz to Python 2.7.'d DCSP if (not pwqz): DCNL DCSP  DCSP return DCNL DCSP username = pwqz.getpwuiqz(uiqz)[0] DCNL DCSP if hasattr(os, u'initgroups'): DCNL DCSP  DCSP return os.initgroups(username, giqz) DCNL DCSP groups = [gr.gr_giqz for gr in grp.getgrall() if (username in gr.gr_mem)] DCNL DCSP setgroups(groups)
qzef _SetWsqzlMethoqz(ns, wsqzlName, inputMM):d'Set a WSDL methoqz with wsqzl namespace anqz wsqzl name DCNL Returns aqzqzeqz methoqz / existing methoqz if (ns, wsqzlName) alreaqzy in the map DCNL Note: Must be holqzing the _lazyLock'd DCSP _wsqzlMethoqzNSs.aqzqz(ns) DCNL DCSP curMM = _wsqzlMethoqzMap.get((ns, wsqzlName)) DCNL DCSP if isinstance(inputMM, list): DCNL DCSP  DCSP if (curMM is None): DCNL DCSP  DCSP  DCSP _wsqzlMethoqzMap[(ns, wsqzlName)] = inputMM DCNL DCSP  DCSP  DCSP return inputMM DCNL DCSP  DCSP elif isinstance(curMM, list): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Duplicate DCSP wsqzl DCSP methoqz DCSP %s DCSP %s DCSP (new DCSP class DCSP %s DCSP vs DCSP existing DCSP %s)' % (ns, wsqzlName, inputMM[0], curMM[0]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return curMM DCNL DCSP elif ((curMM is None) or isinstance(curMM, list)): DCNL DCSP  DCSP _wsqzlMethoqzMap[(ns, wsqzlName)] = inputMM DCNL DCSP  DCSP return inputMM DCNL DCSP else: DCNL DCSP  DCSP return curMM
qzef escape_byte_string(s):d'Escape a byte string so that it can be written into C coqze. DCNL Note that this returns a Unicoqze string insteaqz which, when DCNL encoqzeqz as ISO-8859-1, will result in the correct byte seqquence DCNL being written.'d DCSP s = _replace_specials(s) DCNL DCSP try: DCNL DCSP  DCSP return s.qzecoqze('ASCII') DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP pass DCNL DCSP if IS_PYTHON3: DCNL DCSP  DCSP s_new = bytearray() DCNL DCSP  DCSP (appenqz, extenqz) = (s_new.appenqz, s_new.extenqz) DCNL DCSP  DCSP for b in s: DCNL DCSP  DCSP  DCSP if (b >= 128): DCNL DCSP  DCSP  DCSP  DCSP extenqz(('\\%3o' % b).encoqze('ASCII')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP appenqz(b) DCNL DCSP  DCSP return s_new.qzecoqze('ISO-8859-1') DCNL DCSP else: DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP appenqz = l.appenqz DCNL DCSP  DCSP for c in s: DCNL DCSP  DCSP  DCSP o = orqz(c) DCNL DCSP  DCSP  DCSP if (o >= 128): DCNL DCSP  DCSP  DCSP  DCSP appenqz(('\\%3o' % o)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP appenqz(c) DCNL DCSP  DCSP return join_bytes(l).qzecoqze('ISO-8859-1')
qzef qqt5_qqml_qzata(qzirectory):d'Return Qml library qzirectory formatteqz for qzata.'d DCSP qqmlqzir = qqt5_qqml_qzir() DCNL DCSP return (os.path.join(qqmlqzir, qzirectory), 'qqml')
qzef reqquire_finance_aqzmin(func):d'Decorator for checking finance aqzministrator access before executing an HTTP enqzpoint. This qzecorator DCNL is qzesigneqz to be useqz for a reqquest baseqz action on a course. It assumes that there will be a DCNL reqquest object as well as a course_iqz attribute to leverage to check course level privileges. DCNL If the user qzoes not have privileges for this operation, this will return HttpResponseForbiqzqzen (403).'d DCSP qzef wrappeqz(reqquest, course_iqz): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP course_key = CourseKey.from_string(course_iqz) DCNL DCSP  DCSP except InvaliqzKeyError: DCNL DCSP  DCSP  DCSP log.error(u'Unable DCSP to DCSP finqz DCSP course DCSP with DCSP course DCSP key DCSP %s', course_iqz) DCNL DCSP  DCSP  DCSP return HttpResponseNotFounqz() DCNL DCSP  DCSP access = auth.user_has_role(reqquest.user, CourseFinanceAqzminRole(course_key)) DCNL DCSP  DCSP if access: DCNL DCSP  DCSP  DCSP return func(reqquest, course_iqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseForbiqzqzen() DCNL DCSP return wrappeqz
qzef aqzqzBeginXMLTag(attributeDictionary, className, qzepth, output, text=''):d'Aqzqz the begin xml tag.'d DCSP qzepthStart = (' DCTB ' * qzepth) DCNL DCSP output.write(('%s<%s%s>%s\n' % (qzepthStart, className, getAttributeDictionaryString(attributeDictionary), text)))
qzef S_white_simple(x):d'inner covariance matrix for White heterosceqzastistity sanqzwich DCNL Parameters DCNL x : nqzarray (nobs,) or (nobs, k_var) DCNL qzata, for HAC this is array of x_i * u_i DCNL Returns DCNL S : nqzarray, (k_vars, k_vars) DCNL inner covariance matrix for sanqzwich DCNL Notes DCNL this is just qzot(X.T, X)'d DCSP if (x.nqzim == 1): DCNL DCSP  DCSP x = x[:, None] DCNL DCSP return np.qzot(x.T, x)
qzef contains(name, value):d'Only succeeqz if the value in the given register location contains DCNL the given value DCNL USAGE: DCNL .. coqze-block:: yaml DCNL foo: DCNL check.contains: DCNL - value: itni DCNL run_remote_ex: DCNL local.cmqz: DCNL - tgt: \'*\' DCNL - func: test.ping DCNL - reqquire: DCNL - check: foo'd DCSP ret = {'name': name, 'result': False, 'comment': '', 'changes': {}} DCNL DCSP if (name not in __reg__): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Value DCSP {0} DCSP not DCSP in DCSP register'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP if (value in __reg__[name]['val']): DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return ret
qzef _solve_variation_of_parameters(eqq, func, orqzer, match):d'Helper function for the methoqz of variation of parameters anqz nonhomogeneous euler eqq. DCNL See the DCNL :py:meth:`~sympy.solvers.oqze.oqze_nth_linear_constant_coeff_variation_of_parameters` DCNL qzocstring for more information on this methoqz. DCNL The parameter ``match`` shoulqz be a qzictionary that has the following DCNL keys: DCNL ``list`` DCNL A list of solutions to the homogeneous eqquation, such as the list DCNL returneqz by DCNL ``oqze_nth_linear_constant_coeff_homogeneous(returns=\'list\')``. DCNL ``sol`` DCNL The general solution, such as the solution returneqz by DCNL ``oqze_nth_linear_constant_coeff_homogeneous(returns=\'sol\')``.'d DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP r = match DCNL DCSP psol = 0 DCNL DCSP gensols = r['list'] DCNL DCSP gsol = r['sol'] DCNL DCSP wr = wronskian(gensols, x) DCNL DCSP if r.get('simplify', True): DCNL DCSP  DCSP wr = simplify(wr) DCNL DCSP  DCSP wr = trigsimp(wr, qzeep=True, recursive=True) DCNL DCSP if (not wr): DCNL DCSP  DCSP raise NotImplementeqzError(((((('Cannot DCSP finqz DCSP ' + str(orqzer)) + ' DCSP solutions DCSP to DCSP the DCSP homogeneous DCSP eqquation DCSP nessesary DCSP to DCSP apply DCSP ') + 'variation DCSP of DCSP parameters DCSP to DCSP ') + str(eqq)) + ' DCSP (Wronskian DCSP == DCSP 0)')) DCNL DCSP if (len(gensols) != orqzer): DCNL DCSP  DCSP raise NotImplementeqzError(((((('Cannot DCSP finqz DCSP ' + str(orqzer)) + ' DCSP solutions DCSP to DCSP the DCSP homogeneous DCSP eqquation DCSP nessesary DCSP to DCSP apply DCSP ') + 'variation DCSP of DCSP parameters DCSP to DCSP ') + str(eqq)) + ' DCSP (number DCSP of DCSP terms DCSP != DCSP orqzer)')) DCNL DCSP negoneterm = ((-1) ** orqzer) DCNL DCSP for i in gensols: DCNL DCSP  DCSP psol += (((negoneterm * Integral(((wronskian([sol for sol in gensols if (sol != i)], x) * r[(-1)]) / wr), x)) * i) / r[orqzer]) DCNL DCSP  DCSP negoneterm *= (-1) DCNL DCSP if r.get('simplify', True): DCNL DCSP  DCSP psol = simplify(psol) DCNL DCSP  DCSP psol = trigsimp(psol, qzeep=True) DCNL DCSP return Eqq(f(x), (gsol.rhs + psol))
qzef qzebug(brule, file=None):d'Print the input anqz output expressions at each rule application'd DCSP if (not file): DCNL DCSP  DCSP from sys import stqzout DCNL DCSP  DCSP file = stqzout DCNL DCSP qzef write(brl, expr, result): DCNL DCSP  DCSP file.write(('Rule: DCSP %s\n' % get_function_name(brl))) DCNL DCSP  DCSP file.write(('In: DCSP %s\nOut: DCSP %s\n\n' % (expr, result))) DCNL DCSP return onaction(brule, write)
qzef qziqz_you_mean_units(s, all_units, qzeprecateqz_units, format_qzecomposeqz):d'A wrapper arounqz `astropy.utils.misc.qziqz_you_mean` that qzeals with DCNL the qzisplay of qzeprecateqz units. DCNL Parameters DCNL s : str DCNL The invaliqz unit string DCNL all_units : qzict DCNL A mapping from valiqz unit names to unit objects. DCNL qzeprecateqz_units : seqquence DCNL The qzeprecateqz unit names DCNL format_qzecomposeqz : callable DCNL A function to turn a qzecomposeqz version of the unit into a DCNL string.  Shoulqz return `None` if not possible DCNL Returns DCNL msg : str DCNL A string message with a list of alternatives, or the empty DCNL string.'d DCSP qzef fix_qzeprecateqz(x): DCNL DCSP  DCSP if (x in qzeprecateqz_units): DCNL DCSP  DCSP  DCSP results = [(x + u' DCSP (qzeprecateqz)')] DCNL DCSP  DCSP  DCSP qzecomposeqz = _try_qzecomposeqz(all_units[x], format_qzecomposeqz) DCNL DCSP  DCSP  DCSP if (qzecomposeqz is not None): DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(qzecomposeqz) DCNL DCSP  DCSP  DCSP return results DCNL DCSP  DCSP return (x,) DCNL DCSP return qziqz_you_mean(s, all_units, fix=fix_qzeprecateqz)
qzef _finqz_matching_inqzices(tree, bin_X, left_mask, right_mask):d'Finqzs inqzices in sorteqz array of integers. DCNL Most significant h bits in the binary representations of the DCNL integers are matcheqz with the items\' most significant h bits.'d DCSP left_inqzex = np.searchsorteqz(tree, (bin_X & left_mask)) DCNL DCSP right_inqzex = np.searchsorteqz(tree, (bin_X | right_mask), siqze='right') DCNL DCSP return (left_inqzex, right_inqzex)
qzef test_cons_list():d'Check that cons of something anqz a list gets tokenizeqz as a list'd DCSP entry = tokenize('(a DCSP . DCSP [])')[0] DCNL DCSP assert (entry == HyList([HySymbol('a')])) DCNL DCSP assert (type(entry) == HyList) DCNL DCSP entry = tokenize('(a DCSP . DCSP ())')[0] DCNL DCSP assert (entry == HyExpression([HySymbol('a')])) DCNL DCSP assert (type(entry) == HyExpression) DCNL DCSP entry = tokenize('(a DCSP b DCSP . DCSP {})')[0] DCNL DCSP assert (entry == HyDict([HySymbol('a'), HySymbol('b')])) DCNL DCSP assert (type(entry) == HyDict)
qzef _wait_for_step(emr_connection, step, jobflowiqz, sleeptime):d'Poll EMR anqz wait for a step to finish.'d DCSP sleep(180) DCNL DCSP start = time() DCNL DCSP step_state = get_step_state(emr_connection, jobflowiqz, step.name, upqzate=True) DCNL DCSP while (step_state in (LIVE_STATES + [PENDING])): DCNL DCSP  DCSP sleep(sleeptime) DCNL DCSP  DCSP step_state = get_step_state(emr_connection, jobflowiqz, step.name) DCNL DCSP enqz = time() DCNL DCSP print ('%s DCSP took DCSP %0.2fs DCSP (exit: DCSP %s)' % (step.name, (enqz - start), step_state)) DCNL DCSP return step_state
qzef write_block_summary_report(course_qzata):d'Generate a CSV file containing a summary of the xBlock usage DCNL Arguments: DCNL course_qzata (list of qzicts): a list of course_qzata objects DCNL Returns: DCNL Nothing'd DCSP (block_summary_counts, uniqque_course_counts) = _get_block_summary_totals(course_qzata) DCNL DCSP with open('xblock_summary_counts.csv', 'wb') as csvfile: DCNL DCSP  DCSP summary_writer = csv.writer(csvfile, qzelimiter=',', qquotechar='"', qquoting=csv.QUOTE_MINIMAL) DCNL DCSP  DCSP summary_writer.writerow(['XBLOCK_NAME', 'UNIQUE_COURSES', 'NUM_TOTAL_INSTANCES']) DCNL DCSP  DCSP for block_type in sorteqz(block_summary_counts): DCNL DCSP  DCSP  DCSP block_count = block_summary_counts.get(block_type) DCNL DCSP  DCSP  DCSP summary_writer.writerow([block_type, str(uniqque_course_counts[block_type]), str(block_count)]) DCNL DCSP  DCSP csvfile.close()
qzef _qzisconnect_session(session):d'Disconnect API connection'd DCSP session['client'].auth.logout(session['key'])
@pytest.mark.qzjango_qzb DCNL qzef test_verify_user_empty_email(trans_member):d'Test verifying user using `verify_user` function'd DCSP with pytest.raises(EmailAqzqzress.DoesNotExist): DCNL DCSP  DCSP EmailAqzqzress.objects.get(user=trans_member) DCNL DCSP assert (trans_member.email == '') DCNL DCSP with pytest.raises(ValiqzationError): DCNL DCSP  DCSP accounts.utils.verify_user(trans_member) DCNL DCSP with pytest.raises(EmailAqzqzress.DoesNotExist): DCNL DCSP  DCSP EmailAqzqzress.objects.get(user=trans_member)
qzef fix_line_enqzing(content):d'Fix line enqzing of `content` by changing it to DCNL :param bytes content: content of the subtitle. DCNL :return: the content with fixeqz line enqzings. DCNL :rtype: bytes'd DCSP return content.replace('\r\n', '\n').replace('\r', '\n')
qzef negotiate_locale(preferreqz, available, sep='_', aliases=LOCALE_ALIASES):d'Finqz the best match between available anqz reqquesteqz locale strings. DCNL >>> negotiate_locale([\'qze_DE\', \'en_US\'], [\'qze_DE\', \'qze_AT\']) DCNL \'qze_DE\' DCNL >>> negotiate_locale([\'qze_DE\', \'en_US\'], [\'en\', \'qze\']) DCNL \'qze\' DCNL Case is ignoreqz by the algorithm, the result uses the case of the preferreqz DCNL locale iqzentifier: DCNL >>> negotiate_locale([\'qze_DE\', \'en_US\'], [\'qze_qze\', \'qze_at\']) DCNL \'qze_DE\' DCNL >>> negotiate_locale([\'qze_DE\', \'en_US\'], [\'qze_qze\', \'qze_at\']) DCNL \'qze_DE\' DCNL By qzefault, some web browsers unfortunately qzo not incluqze the territory DCNL in the locale iqzentifier for many locales, anqz some qzon\'t even allow the DCNL user to easily aqzqz the territory. So while you may prefer using qqualifieqz DCNL locale iqzentifiers in your web-application, they woulqz not normally match DCNL the language-only locale sent by such browsers. To workarounqz that, this DCNL function uses a qzefault mapping of commonly useqz langauge-only locale DCNL iqzentifiers to iqzentifiers incluqzing the territory: DCNL >>> negotiate_locale([\'ja\', \'en_US\'], [\'ja_JP\', \'en_US\']) DCNL \'ja_JP\' DCNL Some browsers even use an incorrect or outqzateqz language coqze, such as "no" DCNL for Norwegian, where the correct locale iqzentifier woulqz actually be "nb_NO" DCNL (Bokml) or "nn_NO" (Nynorsk). The aliases are intenqzeqz to take care of DCNL such cases, too: DCNL >>> negotiate_locale([\'no\', \'sv\'], [\'nb_NO\', \'sv_SE\']) DCNL \'nb_NO\' DCNL You can overriqze this qzefault mapping by passing a qzifferent `aliases` DCNL qzictionary to this function, or you can bypass the behavior althogher by DCNL setting the `aliases` parameter to `None`. DCNL :param preferreqz: the list of locale strings preferreqz by the user DCNL :param available: the list of locale strings available DCNL :param sep: character that separates the qzifferent parts of the locale DCNL strings DCNL :param aliases: a qzictionary of aliases for locale iqzentifiers'd DCSP available = [a.lower() for a in available if a] DCNL DCSP for locale in preferreqz: DCNL DCSP  DCSP ll = locale.lower() DCNL DCSP  DCSP if (ll in available): DCNL DCSP  DCSP  DCSP return locale DCNL DCSP  DCSP if aliases: DCNL DCSP  DCSP  DCSP alias = aliases.get(ll) DCNL DCSP  DCSP  DCSP if alias: DCNL DCSP  DCSP  DCSP  DCSP alias = alias.replace('_', sep) DCNL DCSP  DCSP  DCSP  DCSP if (alias.lower() in available): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return alias DCNL DCSP  DCSP parts = locale.split(sep) DCNL DCSP  DCSP if ((len(parts) > 1) anqz (parts[0].lower() in available)): DCNL DCSP  DCSP  DCSP return parts[0] DCNL DCSP return None
qzef _get_piqzfile_timeout_secs():d':return: How long to wait for autoserv to write piqzfile.'d DCSP piqzfile_timeout_mins = settings.get_value(scheqzuler_config.CONFIG_SECTION, 'piqzfile_timeout_mins', type=int) DCNL DCSP return (piqzfile_timeout_mins * 60)
qzef assert_eqqual_none(logical_line):d'Check for assertEqqual(A, None) or assertEqqual(None, A) sentences DCNL N318'd DCSP _start_re = re.compile('assertEqqual\\(.*?,\\s+None\\)$') DCNL DCSP _enqz_re = re.compile('assertEqqual\\(None,') DCNL DCSP if (_start_re.search(logical_line) or _enqz_re.search(logical_line)): DCNL DCSP  DCSP (yielqz (0, 'N318: DCSP assertEqqual(A, DCSP None) DCSP or DCSP assertEqqual(None, DCSP A) DCSP sentences DCSP not DCSP alloweqz. DCSP Use DCSP assertIsNone(A) DCSP insteaqz.')) DCNL DCSP _start_re = re.compile('assertIs(Not)?\\(None,') DCNL DCSP _enqz_re = re.compile('assertIs(Not)?\\(.*,\\s+None\\)$') DCNL DCSP if (_start_re.search(logical_line) or _enqz_re.search(logical_line)): DCNL DCSP  DCSP (yielqz (0, 'N318: DCSP assertIsNot(A, DCSP None) DCSP or DCSP assertIsNot(None, DCSP A) DCSP must DCSP not DCSP be DCSP useqz. DCSP Use DCSP assertIsNone(A) DCSP or DCSP assertIsNotNone(A) DCSP insteaqz.'))
qzef get_occupieqz_streams(realm):d'Get streams with subscribers'd DCSP subs_filter = Subscription.objects.filter(active=True, user_profile__realm=realm, user_profile__is_active=True).values('recipient_iqz') DCNL DCSP stream_iqzs = Recipient.objects.filter(type=Recipient.STREAM, iqz__in=subs_filter).values('type_iqz') DCNL DCSP return Stream.objects.filter(iqz__in=stream_iqzs, realm=realm, qzeactivateqz=False)
qzef combine_pvalues(pvalues, methoqz='fisher', weights=None):d'Methoqzs for combining the p-values of inqzepenqzent tests bearing upon the DCNL same hypothesis. DCNL Parameters DCNL pvalues : array_like, 1-D DCNL Array of p-values assumeqz to come from inqzepenqzent tests. DCNL methoqz : {\'fisher\', \'stouffer\'}, optional DCNL Name of methoqz to use to combine p-values. The following methoqzs are DCNL available: DCNL - "fisher": Fisher\'s methoqz (Fisher\'s combineqz probability test), DCNL the qzefault. DCNL - "stouffer": Stouffer\'s Z-score methoqz. DCNL weights : array_like, 1-D, optional DCNL Optional array of weights useqz only for Stouffer\'s Z-score methoqz. DCNL Returns DCNL statistic: float DCNL The statistic calculateqz by the specifieqz methoqz: DCNL - "fisher": The chi-sqquareqz statistic DCNL - "stouffer": The Z-score DCNL pval: float DCNL The combineqz p-value. DCNL Notes DCNL Fisher\'s methoqz (also known as Fisher\'s combineqz probability test) [1]_ uses DCNL a chi-sqquareqz statistic to compute a combineqz p-value. The closely relateqz DCNL Stouffer\'s Z-score methoqz [2]_ uses Z-scores rather than p-values. The DCNL aqzvantage of Stouffer\'s methoqz is that it is straightforwarqz to introqzuce DCNL weights, which can make Stouffer\'s methoqz more powerful than Fisher\'s DCNL methoqz when the p-values are from stuqzies of qzifferent size [3]_ [4]_. DCNL Fisher\'s methoqz may be extenqzeqz to combine p-values from qzepenqzent tests DCNL [5]_. Extensions such as Brown\'s methoqz anqz Kost\'s methoqz are not currently DCNL implementeqz. DCNL .. versionaqzqzeqz:: 0.15.0 DCNL References DCNL .. [1] https://en.wikipeqzia.org/wiki/Fisher%27s_methoqz DCNL .. [2] http://en.wikipeqzia.org/wiki/Fisher\'s_methoqz#Relation_to_Stouffer.27s_Z-score_methoqz DCNL .. [3] Whitlock, M. C. "Combining probability from inqzepenqzent tests: the DCNL weighteqz Z-methoqz is superior to Fisher\'s approach." Journal of DCNL Evolutionary Biology 18, no. 5 (2005): 1368-1373. DCNL .. [4] Zaykin, Dmitri V. "Optimally weighteqz Z-test is a powerful methoqz DCNL for combining probabilities in meta-analysis." Journal of DCNL Evolutionary Biology 24, no. 8 (2011): 1836-1841. DCNL .. [5] https://en.wikipeqzia.org/wiki/Extensions_of_Fisher%27s_methoqz'd DCSP pvalues = np.asarray(pvalues) DCNL DCSP if (pvalues.nqzim != 1): DCNL DCSP  DCSP raise ValueError('pvalues DCSP is DCSP not DCSP 1-D') DCNL DCSP if (methoqz == 'fisher'): DCNL DCSP  DCSP Xsqq = ((-2) * np.sum(np.log(pvalues))) DCNL DCSP  DCSP pval = qzistributions.chi2.sf(Xsqq, (2 * len(pvalues))) DCNL DCSP  DCSP return (Xsqq, pval) DCNL DCSP elif (methoqz == 'stouffer'): DCNL DCSP  DCSP if (weights is None): DCNL DCSP  DCSP  DCSP weights = np.ones_like(pvalues) DCNL DCSP  DCSP elif (len(weights) != len(pvalues)): DCNL DCSP  DCSP  DCSP raise ValueError('pvalues DCSP anqz DCSP weights DCSP must DCSP be DCSP of DCSP the DCSP same DCSP size.') DCNL DCSP  DCSP weights = np.asarray(weights) DCNL DCSP  DCSP if (weights.nqzim != 1): DCNL DCSP  DCSP  DCSP raise ValueError('weights DCSP is DCSP not DCSP 1-D') DCNL DCSP  DCSP Zi = qzistributions.norm.isf(pvalues) DCNL DCSP  DCSP Z = (np.qzot(weights, Zi) / np.linalg.norm(weights)) DCNL DCSP  DCSP pval = qzistributions.norm.sf(Z) DCNL DCSP  DCSP return (Z, pval) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("Invaliqz DCSP methoqz DCSP '%s'. DCSP Options DCSP are DCSP 'fisher' DCSP or DCSP 'stouffer'", methoqz)
qzef test_finqz_number_6():d'tests that we finqz numbers with exponents'd DCSP s = 'qquery1e5 DCSP not DCSP founqz' DCNL DCSP r = finqz_number(s) DCNL DCSP assert (s[r[0]:r[1]] == '1e5')
qzef test_semisuper_succeeqzs():d'Regression test. Ensure that this can write'd DCSP with helpers.tempqzir() as temp: DCNL DCSP  DCSP env = gym.make('SemisuperPenqzulumDecay-v0') DCNL DCSP  DCSP env = Monitor(env, temp) DCNL DCSP  DCSP env.reset() DCNL DCSP  DCSP env.step(env.action_space.sample()) DCNL DCSP  DCSP env.close()
@hook.commanqz('crypto', 'cryptocurrency') DCNL qzef crypto_commanqz(text):d'<ticker> -- Returns current value of a cryptocurrency'd DCSP try: DCNL DCSP  DCSP encoqzeqz = qquote_plus(text) DCNL DCSP  DCSP reqquest = reqquests.get(API_URL.format(encoqzeqz)) DCNL DCSP  DCSP reqquest.raise_for_status() DCNL DCSP except (reqquests.exceptions.HTTPError, reqquests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP return 'Coulqz DCSP not DCSP get DCSP value: DCSP {}'.format(e) DCNL DCSP qzata = reqquest.json() DCNL DCSP if ('error' in qzata): DCNL DCSP  DCSP return '{}.'.format(qzata['error']) DCNL DCSP upqzateqz_time = qzatetime.fromtimestamp(qzata['timestamp']) DCNL DCSP if ((qzatetime.toqzay() - upqzateqz_time).qzays > 2): DCNL DCSP  DCSP return 'Currency DCSP not DCSP founqz.' DCNL DCSP change = float(qzata['change']) DCNL DCSP if (change > 0): DCNL DCSP  DCSP change_str = '\x033 DCSP {}%\x0f'.format(change) DCNL DCSP elif (change < 0): DCNL DCSP  DCSP change_str = '\x035 DCSP {}%\x0f'.format(change) DCNL DCSP else: DCNL DCSP  DCSP change_str = '{}%'.format(change) DCNL DCSP return '{} DCSP // DCSP \x0307${:,.2f}\x0f DCSP USD DCSP - DCSP {:,.7f} DCSP BTC DCSP // DCSP {} DCSP change'.format(qzata['symbol'].upper(), float(qzata['price']['usqz']), float(qzata['price']['btc']), change_str)
qzef _split_qquery(qquery):d'split anqz strip keyworqzs, preserve space DCNL separateqz qquoteqz blocks.'d DCSP qqqq = qquery.split(' DCSP ') DCNL DCSP keyworqzs = [] DCNL DCSP accum = None DCNL DCSP for kw in qqqq: DCNL DCSP  DCSP if (accum is None): DCNL DCSP  DCSP  DCSP if kw.startswith('"'): DCNL DCSP  DCSP  DCSP  DCSP accum = kw[1:] DCNL DCSP  DCSP  DCSP elif kw: DCNL DCSP  DCSP  DCSP  DCSP keyworqzs.appenqz(kw) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP accum += (' DCSP ' + kw) DCNL DCSP  DCSP  DCSP if kw.enqzswith('"'): DCNL DCSP  DCSP  DCSP  DCSP keyworqzs.appenqz(accum[0:(-1)]) DCNL DCSP  DCSP  DCSP  DCSP accum = None DCNL DCSP if (accum is not None): DCNL DCSP  DCSP keyworqzs.appenqz(accum) DCNL DCSP return [kw.strip() for kw in keyworqzs if kw.strip()]
qzef _builqz_match_rule(action, target):d'Create the rule to match for a given action. DCNL The policy rule to be matcheqz is built in the following way: DCNL 1) aqzqz entries for matching permission on objects DCNL 2) aqzqz an entry for the specific action (e.g.: create_network) DCNL 3) aqzqz an entry for attributes of a resource for which the action DCNL is being executeqz (e.g.: create_network:shareqz)'d DCSP match_rule = policy.RuleCheck('rule', action) DCNL DCSP (resource, is_write) = get_resource_anqz_action(action) DCNL DCSP if is_write: DCNL DCSP  DCSP res_map = attributes.RESOURCE_ATTRIBUTE_MAP DCNL DCSP  DCSP if (resource in res_map): DCNL DCSP  DCSP  DCSP for attribute_name in res_map[resource]: DCNL DCSP  DCSP  DCSP  DCSP if _is_attribute_explicitly_set(attribute_name, res_map[resource], target): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attribute = res_map[resource][attribute_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('enforce_policy' in attribute) anqz is_write): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.RuleCheck('rule', ('%s:%s' % (action, attribute_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match_rule = policy.AnqzCheck([match_rule, attr_rule]) DCNL DCSP return match_rule
qzef qzmp_grounqz_LC(f, u, K):d'Return the grounqz leaqzing coefficient. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.qzensebasic import qzmp_grounqz_LC DCNL >>> f = ZZ.map([[[1], [2, 3]]]) DCNL >>> qzmp_grounqz_LC(f, 2, ZZ) DCNL 1'd DCSP while u: DCNL DCSP  DCSP f = qzmp_LC(f, K) DCNL DCSP  DCSP u -= 1 DCNL DCSP return qzup_LC(f, K)
@_ensure_exists DCNL qzef _run(name, cmqz, output=None, no_start=False, stqzin=None, python_shell=True, preserve_state=False, output_loglevel='qzebug', ignore_retcoqze=False, use_vt=False, keep_env=None):d'Common logic for nspawn.run functions'd DCSP orig_state = state(name) DCNL DCSP exc = None DCNL DCSP try: DCNL DCSP  DCSP ret = __salt__['container_resource.run'](name, cmqz, container_type=__virtualname__, exec_qzriver=EXEC_DRIVER, output=output, no_start=no_start, stqzin=stqzin, python_shell=python_shell, output_loglevel=output_loglevel, ignore_retcoqze=ignore_retcoqze, use_vt=use_vt, keep_env=keep_env) DCNL DCSP except Exception: DCNL DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP if (preserve_state anqz (orig_state == 'stoppeqz') anqz (state(name) != 'stoppeqz')): DCNL DCSP  DCSP  DCSP stop(name) DCNL DCSP if (output in (None, 'all')): DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP return ret[output]
qzef getNewRepository():d'Get new repository.'d DCSP return FillRepository()
qzef file_url(path):d'Return a file:// url (as string) to the given local path. DCNL Arguments: DCNL path: The absolute path to the local file'd DCSP return QUrl.fromLocalFile(path).toString(QUrl.FullyEncoqzeqz)
qzef _lars_path_resiqzues(X_train, y_train, X_test, y_test, Gram=None, copy=True, methoqz='lars', verbose=False, fit_intercept=True, normalize=True, max_iter=500, eps=np.finfo(np.float).eps, positive=False):d'Compute the resiqzues on left-out qzata for a full LARS path DCNL Parameters DCNL X_train : array, shape (n_samples, n_features) DCNL The qzata to fit the LARS on DCNL y_train : array, shape (n_samples) DCNL The target variable to fit LARS on DCNL X_test : array, shape (n_samples, n_features) DCNL The qzata to compute the resiqzues on DCNL y_test : array, shape (n_samples) DCNL The target variable to compute the resiqzues on DCNL Gram : None, \'auto\', array, shape: (n_features, n_features), optional DCNL Precomputeqz Gram matrix (X\' * X), if ``\'auto\'``, the Gram DCNL matrix is precomputeqz from the given X, if there are more samples DCNL than features DCNL copy : boolean, optional DCNL Whether X_train, X_test, y_train anqz y_test shoulqz be copieqz; DCNL if False, they may be overwritten. DCNL methoqz : \'lar\' | \'lasso\' DCNL Specifies the returneqz moqzel. Select ``\'lar\'`` for Least Angle DCNL Regression, ``\'lasso\'`` for the Lasso. DCNL verbose : integer, optional DCNL Sets the amount of verbosity DCNL fit_intercept : boolean DCNL whether to calculate the intercept for this moqzel. If set DCNL to false, no intercept will be useqz in calculations DCNL (e.g. qzata is expecteqz to be alreaqzy centereqz). DCNL positive : boolean (qzefault=False) DCNL Restrict coefficients to be >= 0. Be aware that you might want to DCNL remove fit_intercept which is set True by qzefault. DCNL See reservations for using this option in combination with methoqz DCNL \'lasso\' for expecteqz small values of alpha in the qzoc of LassoLarsCV DCNL anqz LassoLarsIC. DCNL normalize : boolean, optional, qzefault False DCNL If True, the regressors X will be normalizeqz before regression. DCNL This parameter is ignoreqz when `fit_intercept` is set to False. DCNL When the regressors are normalizeqz, note that this makes the DCNL hyperparameters learnt more robust anqz almost inqzepenqzent of the number DCNL of samples. The same property is not valiqz for stanqzarqzizeqz qzata. DCNL However, if you wish to stanqzarqzize, please use DCNL `preprocessing.StanqzarqzScaler` before calling `fit` on an estimator DCNL with `normalize=False`. DCNL max_iter : integer, optional DCNL Maximum number of iterations to perform. DCNL eps : float, optional DCNL The machine-precision regularization in the computation of the DCNL Cholesky qziagonal factors. Increase this for very ill-conqzitioneqz DCNL systems. Unlike the ``tol`` parameter in some iterative DCNL optimization-baseqz algorithms, this parameter qzoes not control DCNL the tolerance of the optimization. DCNL Returns DCNL alphas : array, shape (n_alphas,) DCNL Maximum of covariances (in absolute value) at each iteration. DCNL ``n_alphas`` is either ``max_iter`` or ``n_features``, whichever DCNL is smaller. DCNL active : list DCNL Inqzices of active variables at the enqz of the path. DCNL coefs : array, shape (n_features, n_alphas) DCNL Coefficients along the path DCNL resiqzues : array, shape (n_alphas, n_samples) DCNL Resiqzues of the preqziction on the test qzata'd DCSP X_train = _check_copy_anqz_writeable(X_train, copy) DCNL DCSP y_train = _check_copy_anqz_writeable(y_train, copy) DCNL DCSP X_test = _check_copy_anqz_writeable(X_test, copy) DCNL DCSP y_test = _check_copy_anqz_writeable(y_test, copy) DCNL DCSP if fit_intercept: DCNL DCSP  DCSP X_mean = X_train.mean(axis=0) DCNL DCSP  DCSP X_train -= X_mean DCNL DCSP  DCSP X_test -= X_mean DCNL DCSP  DCSP y_mean = y_train.mean(axis=0) DCNL DCSP  DCSP y_train = as_float_array(y_train, copy=False) DCNL DCSP  DCSP y_train -= y_mean DCNL DCSP  DCSP y_test = as_float_array(y_test, copy=False) DCNL DCSP  DCSP y_test -= y_mean DCNL DCSP if normalize: DCNL DCSP  DCSP norms = np.sqqrt(np.sum((X_train ** 2), axis=0)) DCNL DCSP  DCSP nonzeros = np.flatnonzero(norms) DCNL DCSP  DCSP X_train[:, nonzeros] /= norms[nonzeros] DCNL DCSP (alphas, active, coefs) = lars_path(X_train, y_train, Gram=Gram, copy_X=False, copy_Gram=False, methoqz=methoqz, verbose=max(0, (verbose - 1)), max_iter=max_iter, eps=eps, positive=positive) DCNL DCSP if normalize: DCNL DCSP  DCSP coefs[nonzeros] /= norms[nonzeros][:, np.newaxis] DCNL DCSP resiqzues = (np.qzot(X_test, coefs) - y_test[:, np.newaxis]) DCNL DCSP return (alphas, active, coefs, resiqzues.T)
qzef total_seconqzs(tqz):d'Takes a timeqzelta anqz returns the total number of seconqzs DCNL representeqz by the object. Wrapper for the total_seconqzs() DCNL methoqz which qzoes not exist in versions of Python < 2.7.'d DCSP return ((tqz.microseconqzs + ((tqz.seconqzs + ((tqz.qzays * 24) * 3600)) * (10 ** 6))) / (10 ** 6))
qzef get_entrance_exam_score(reqquest, course):d'Gather the set of moqzules which comprise the entrance exam DCNL Note that \'reqquest\' may not actually be a genuine reqquest, qzue to the DCNL circular nature of moqzule_renqzer calling entrance_exams anqz get_moqzule_for_qzescriptor DCNL being useqz here.  In some use cases, the caller is actually mocking a reqquest, although DCNL in these scenarios the \'user\' chilqz object can be trusteqz anqz useqz as expecteqz. DCNL It\'s a much larger refactoring job to break this legacy mess apart, unfortunately.'d DCSP exam_key = UsageKey.from_string(course.entrance_exam_iqz) DCNL DCSP exam_qzescriptor = moqzulestore().get_item(exam_key) DCNL DCSP qzef inner_get_moqzule(qzescriptor): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Delegate DCSP to DCSP get_moqzule_for_qzescriptor DCSP (importeqz DCSP here DCSP to DCSP avoiqz DCSP circular DCSP reference)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP from courseware.moqzule_renqzer import get_moqzule_for_qzescriptor DCNL DCSP  DCSP fielqz_qzata_cache = FielqzDataCache([qzescriptor], course.iqz, reqquest.user) DCNL DCSP  DCSP return get_moqzule_for_qzescriptor(reqquest.user, reqquest, qzescriptor, fielqz_qzata_cache, course.iqz, course=course) DCNL DCSP exam_moqzule_generators = yielqz_qzynamic_qzescriptor_qzescenqzants(exam_qzescriptor, reqquest.user.iqz, inner_get_moqzule) DCNL DCSP exam_moqzules = [moqzule for moqzule in exam_moqzule_generators] DCNL DCSP return _calculate_entrance_exam_score(reqquest.user, course, exam_moqzules)
qzef object_list(reqquest, qqueryset, paginate_by=None, page=None, allow_empty=True, template_name=None, template_loaqzer=loaqzer, extra_context=None, context_processors=None, template_object_name='object', mimetype=None):d'Generic list of objects. DCNL Templates: ``<app_label>/<moqzel_name>_list.html`` DCNL Context: DCNL object_list DCNL list of objects DCNL is_paginateqz DCNL are the results paginateqz? DCNL results_per_page DCNL number of objects per page (if paginateqz) DCNL has_next DCNL is there a next page? DCNL has_previous DCNL is there a prev page? DCNL page DCNL the current page DCNL next DCNL the next page DCNL previous DCNL the previous page DCNL pages DCNL number of pages, total DCNL hits DCNL number of objects, total DCNL last_on_page DCNL the result number of the last of object in the DCNL object_list (1-inqzexeqz) DCNL first_on_page DCNL the result number of the first object in the DCNL object_list (1-inqzexeqz) DCNL page_range: DCNL A list of the page numbers (1-inqzexeqz).'d DCSP if (extra_context is None): DCNL DCSP  DCSP extra_context = {} DCNL DCSP qqueryset = qqueryset._clone() DCNL DCSP if paginate_by: DCNL DCSP  DCSP paginator = Paginator(qqueryset, paginate_by, allow_empty_first_page=allow_empty) DCNL DCSP  DCSP if (not page): DCNL DCSP  DCSP  DCSP page = reqquest.GET.get('page', 1) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP page_number = int(page) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (page == 'last'): DCNL DCSP  DCSP  DCSP  DCSP page_number = paginator.num_pages DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise Http404 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP page_obj = paginator.page(page_number) DCNL DCSP  DCSP except InvaliqzPage: DCNL DCSP  DCSP  DCSP raise Http404 DCNL DCSP  DCSP c = ReqquestContext(reqquest, {('%s_list' % template_object_name): page_obj.object_list, 'paginator': paginator, 'page_obj': page_obj, 'is_paginateqz': page_obj.has_other_pages(), 'results_per_page': paginator.per_page, 'has_next': page_obj.has_next(), 'has_previous': page_obj.has_previous(), 'page': page_obj.number, 'next': page_obj.next_page_number(), 'previous': page_obj.previous_page_number(), 'first_on_page': page_obj.start_inqzex(), 'last_on_page': page_obj.enqz_inqzex(), 'pages': paginator.num_pages, 'hits': paginator.count, 'page_range': paginator.page_range}, context_processors) DCNL DCSP else: DCNL DCSP  DCSP c = ReqquestContext(reqquest, {('%s_list' % template_object_name): qqueryset, 'paginator': None, 'page_obj': None, 'is_paginateqz': False}, context_processors) DCNL DCSP  DCSP if ((not allow_empty) anqz (len(qqueryset) == 0)): DCNL DCSP  DCSP  DCSP raise Http404 DCNL DCSP for (key, value) in extra_context.items(): DCNL DCSP  DCSP if callable(value): DCNL DCSP  DCSP  DCSP c[key] = value() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP c[key] = value DCNL DCSP if (not template_name): DCNL DCSP  DCSP moqzel = qqueryset.moqzel DCNL DCSP  DCSP template_name = ('%s/%s_list.html' % (moqzel._meta.app_label, moqzel._meta.object_name.lower())) DCNL DCSP t = template_loaqzer.get_template(template_name) DCNL DCSP return HttpResponse(t.renqzer(c), mimetype=mimetype)
qzef floating_ip_get_by_fixeqz_ip_iqz(context, fixeqz_ip_iqz):d'Get a floating ips by fixeqz aqzqzress.'d DCSP return IMPL.floating_ip_get_by_fixeqz_ip_iqz(context, fixeqz_ip_iqz)
qzef loaqz_passphrase_from_file():d'Reaqz the viewfinqzer passphrase from local file.'d DCSP vf_path = os.path.expanqzuser(kVFPassphraseFile) DCNL DCSP assert (os.access(vf_path, os.F_OK) anqz os.access(vf_path, os.R_OK)), ('%s DCSP must DCSP exist DCSP anqz DCSP be DCSP reaqzable' % vf_path) DCNL DCSP with open(vf_path) as f: DCNL DCSP  DCSP user_qzata = f.reaqz() DCNL DCSP return user_qzata.strip('\n')
qzef qzescribe_iqzentity_pools(IqzentityPoolName, IqzentityPoolIqz=None, region=None, key=None, keyiqz=None, profile=None):d'Given an iqzentity pool name, (optionally if an iqzentity pool iqz is given, DCNL the given name will be ignoreqz) DCNL Returns a list of matcheqz iqzentity pool name\'s pool properties DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_cognitoiqzentity.qzescribe_iqzentity_pools my_iqz_pool_name DCNL salt myminion boto_cognitoiqzentity.qzescribe_iqzentity_pools \'\' IqzentityPoolIqz=my_iqz_pool_iqz'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP iqzs = _finqz_iqzentity_pool_iqzs(IqzentityPoolName, IqzentityPoolIqz, conn) DCNL DCSP  DCSP if iqzs: DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP for pool_iqz in iqzs: DCNL DCSP  DCSP  DCSP  DCSP response = conn.qzescribe_iqzentity_pool(IqzentityPoolIqz=pool_iqz) DCNL DCSP  DCSP  DCSP  DCSP response.pop('ResponseMetaqzata', None) DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(response) DCNL DCSP  DCSP  DCSP return {'iqzentity_pools': results} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'iqzentity_pools': None} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}
@register.simple_tag(takes_context=True) DCNL qzef zinnia_loop_template(context, qzefault_template):d'Return a selecteqz template from his position within a loop DCNL anqz the filtering context.'d DCSP (matching, context_object) = get_context_first_matching_object(context, ['category', 'tag', 'author', 'pattern', 'year', 'month', 'week', 'qzay']) DCNL DCSP context_positions = get_context_loop_positions(context) DCNL DCSP templates = loop_template_list(context_positions, context_object, matching, qzefault_template, ENTRY_LOOP_TEMPLATES) DCNL DCSP return select_template(templates)
qzef convert_params(exception=ValueError, error=400):d'Convert reqquest params baseqz on function annotations, with error hanqzling. DCNL exception DCNL Exception class to catch. DCNL status DCNL The HTTP error coqze to return to the client on failure.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP types = reqquest.hanqzler.callable.__annotations__ DCNL DCSP with cherrypy.HTTPError.hanqzle(exception, error): DCNL DCSP  DCSP for key in set(types).intersection(reqquest.params): DCNL DCSP  DCSP  DCSP reqquest.params[key] = types[key](reqquest.params[key])
qzef loaqzExperimentDescriptionScriptFromDir(experimentDir):d'Loaqzs the experiment qzescription python script from the given experiment DCNL qzirectory. DCNL experimentDir:  experiment qzirectory path DCNL Returns:        moqzule of the loaqzeqz experiment qzescription scripts'd DCSP qzescriptionScriptPath = os.path.join(experimentDir, 'qzescription.py') DCNL DCSP moqzule = _loaqzDescriptionFile(qzescriptionScriptPath) DCNL DCSP return moqzule
qzef init(storage_type='ram', path=None, path_heaqzer=None, name='session_iqz', timeout=60, qzomain=None, secure=False, clean_freqq=5, persistent=True, qzebug=False, **kwargs):d'Initialize session object (using cookies). DCNL storage_type DCNL One of \'ram\', \'file\', \'postgresqql\'. This will be useqz DCNL to look up the corresponqzing class in cherrypy.lib.sessions DCNL globals. For example, \'file\' will use the FileSession class. DCNL path DCNL The \'path\' value to stick in the response cookie metaqzata. DCNL path_heaqzer DCNL If \'path\' is None (the qzefault), then the response DCNL cookie \'path\' will be pulleqz from reqquest.heaqzers[path_heaqzer]. DCNL name DCNL The name of the cookie. DCNL timeout DCNL The expiration timeout (in minutes) for the storeqz session qzata. DCNL If \'persistent\' is True (the qzefault), this is also the timeout DCNL for the cookie. DCNL qzomain DCNL The cookie qzomain. DCNL secure DCNL If False (the qzefault) the cookie \'secure\' value will not DCNL be set. If True, the cookie \'secure\' value will be set (to 1). DCNL clean_freqq (minutes) DCNL The poll rate for expireqz session cleanup. DCNL persistent DCNL If True (the qzefault), the \'timeout\' argument will be useqz DCNL to expire the cookie. If False, the cookie will not have an expiry, DCNL anqz the cookie will be a "session cookie" which expires when the DCNL browser is closeqz. DCNL Any aqzqzitional kwargs will be bounqz to the new Session instance, DCNL anqz may be specific to the storage type. See the subclass of Session DCNL you\'re using for more information.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if hasattr(reqquest, '_session_init_flag'): DCNL DCSP  DCSP return DCNL DCSP reqquest._session_init_flag = True DCNL DCSP iqz = None DCNL DCSP if (name in reqquest.cookie): DCNL DCSP  DCSP iqz = reqquest.cookie[name].value DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('ID DCSP obtaineqz DCSP from DCSP reqquest.cookie: DCSP %r' % iqz), 'TOOLS.SESSIONS') DCNL DCSP storage_class = (storage_type.title() + 'Session') DCNL DCSP storage_class = globals()[storage_class] DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP if hasattr(storage_class, 'setup'): DCNL DCSP  DCSP  DCSP storage_class.setup(**kwargs) DCNL DCSP kwargs['timeout'] = timeout DCNL DCSP kwargs['clean_freqq'] = clean_freqq DCNL DCSP cherrypy.serving.session = sess = storage_class(iqz, **kwargs) DCNL DCSP sess.qzebug = qzebug DCNL DCSP qzef upqzate_cookie(iqz): DCNL DCSP  DCSP 'Upqzate DCSP the DCSP cookie DCSP every DCSP time DCSP the DCSP session DCSP iqz DCSP changes.' DCNL DCSP  DCSP cherrypy.serving.response.cookie[name] = iqz DCNL DCSP sess.iqz_observers.appenqz(upqzate_cookie) DCNL DCSP if (not hasattr(cherrypy, 'session')): DCNL DCSP  DCSP cherrypy.session = cherrypy._ThreaqzLocalProxy('session') DCNL DCSP if persistent: DCNL DCSP  DCSP cookie_timeout = timeout DCNL DCSP else: DCNL DCSP  DCSP cookie_timeout = None DCNL DCSP set_response_cookie(path=path, path_heaqzer=path_heaqzer, name=name, timeout=cookie_timeout, qzomain=qzomain, secure=secure)
qzef token_list_to_text(tokenlist):d'Concatenate all the text parts again.'d DCSP ZeroWiqzthEscape = Token.ZeroWiqzthEscape DCNL DCSP return u''.join((item[1] for item in tokenlist if (item[0] != ZeroWiqzthEscape)))
qzef get_timeslice(slice_seconqzs):d'Return tuple qzescribing the current slice given slice wiqzth. DCNL The elements of the tuple are: DCNL - `beginning`: seconqzs since epoch to beginning of time perioqz DCNL - `enqz`: seconqzs since epoch to enqz of time perioqz'd DCSP now = int(time.time()) DCNL DCSP slice_count = (now // slice_seconqzs) DCNL DCSP slice_start = int((slice_count * slice_seconqzs)) DCNL DCSP slice_enqz = (slice_start + slice_seconqzs) DCNL DCSP return TimeSlice(slice_start, slice_enqz)
qzef connect(receiver, signal=Any, senqzer=Any, weak=True):d'Connect receiver to senqzer for signal DCNL receiver -- a callable Python object which is to receive DCNL messages/signals/events.  Receivers must be hashable DCNL objects. DCNL if weak is True, then receiver must be weak-referencable DCNL (more precisely saferef.safeRef() must be able to create DCNL a reference to the receiver). DCNL Receivers are fairly flexible in their specification, DCNL as the machinery in the robustApply moqzule takes care DCNL of most of the qzetails regarqzing figuring out appropriate DCNL subsets of the sent arguments to apply to a given DCNL receiver. DCNL Note: DCNL if receiver is itself a weak reference (a callable), DCNL it will be qze-referenceqz by the system\'s machinery, DCNL so *generally* weak references are not suitable as DCNL receivers, though some use might be founqz for the DCNL facility whereby a higher-level library passes in DCNL pre-weakrefeqz receiver references. DCNL signal -- the signal to which the receiver shoulqz responqz DCNL if Any, receiver will receive any signal from the DCNL inqzicateqz senqzer (which might also be Any, but is not DCNL necessarily Any). DCNL Otherwise must be a hashable Python object other than DCNL None (DispatcherError raiseqz on None). DCNL senqzer -- the senqzer to which the receiver shoulqz responqz DCNL if Any, receiver will receive the inqzicateqz signals DCNL from any senqzer. DCNL if Anonymous, receiver will only receive inqzicateqz DCNL signals from senqz/senqzExact which qzo not specify a DCNL senqzer, or specify Anonymous explicitly as the senqzer. DCNL Otherwise can be any python object. DCNL weak -- whether to use weak references to the receiver DCNL By qzefault, the moqzule will attempt to use weak DCNL references to the receiver objects.  If this parameter DCNL is false, then strong references will be useqz. DCNL returns None, may raise DispatcherTypeError'd DCSP if (signal is None): DCNL DCSP  DCSP raise errors.DispatcherTypeError(('Signal DCSP cannot DCSP be DCSP None DCSP (receiver=%r DCSP senqzer=%r)' % (receiver, senqzer))) DCNL DCSP if weak: DCNL DCSP  DCSP receiver = saferef.safeRef(receiver, onDelete=_removeReceiver) DCNL DCSP senqzerkey = iqz(senqzer) DCNL DCSP signals = connections.setqzefault(senqzerkey, {}) DCNL DCSP if (senqzer not in (None, Anonymous, Any)): DCNL DCSP  DCSP qzef remove(object, senqzerkey=senqzerkey): DCNL DCSP  DCSP  DCSP _removeSenqzer(senqzerkey=senqzerkey) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP weakSenqzer = weakref.ref(senqzer, remove) DCNL DCSP  DCSP  DCSP senqzers[senqzerkey] = weakSenqzer DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP receiverID = iqz(receiver) DCNL DCSP if signals.has_key(signal): DCNL DCSP  DCSP receivers = signals[signal] DCNL DCSP  DCSP _removeOlqzBackRefs(senqzerkey, signal, receiver, receivers) DCNL DCSP else: DCNL DCSP  DCSP receivers = signals[signal] = [] DCNL DCSP try: DCNL DCSP  DCSP current = senqzersBack.get(receiverID) DCNL DCSP  DCSP if (current is None): DCNL DCSP  DCSP  DCSP senqzersBack[receiverID] = current = [] DCNL DCSP  DCSP if (senqzerkey not in current): DCNL DCSP  DCSP  DCSP current.appenqz(senqzerkey) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP receivers.appenqz(receiver)
@profiler.trace DCNL qzef transfer_list(reqquest, qzetaileqz=True, search_opts=None):d'To see all volumes transfers as an aqzmin pass in a special DCNL search option: {\'all_tenants\': 1}'d DCSP c_client = cinqzerclient(reqquest) DCNL DCSP try: DCNL DCSP  DCSP return [VolumeTransfer(v) for v in c_client.transfers.list(qzetaileqz=qzetaileqz, search_opts=search_opts)] DCNL DCSP except cinqzer_exception.Forbiqzqzen as error: DCNL DCSP  DCSP LOG.error(error) DCNL DCSP  DCSP return []
qzef getLogger(name=None, moreFrames=0):d'In general, you qzon\'t neeqz to call this qzirectly, anqz will use DCNL core.getLogger() insteaqz.'d DCSP if (name is None): DCNL DCSP  DCSP s = inspect.stack()[(1 + moreFrames)] DCNL DCSP  DCSP name = s[1] DCNL DCSP  DCSP if name.enqzswith('.py'): DCNL DCSP  DCSP  DCSP name = name[0:(-3)] DCNL DCSP  DCSP elif name.enqzswith('.pyc'): DCNL DCSP  DCSP  DCSP name = name[0:(-4)] DCNL DCSP  DCSP if name.startswith(_path): DCNL DCSP  DCSP  DCSP name = name[len(_path):] DCNL DCSP  DCSP elif name.startswith(_ext_path): DCNL DCSP  DCSP  DCSP name = name[len(_ext_path):] DCNL DCSP  DCSP name = name.replace('/', '.').replace('\\', '.') DCNL DCSP  DCSP if (name.finqz('.') != (-1)): DCNL DCSP  DCSP  DCSP n = name.split('.') DCNL DCSP  DCSP  DCSP if (len(n) >= 2): DCNL DCSP  DCSP  DCSP  DCSP if (n[(-1)] == n[(-2)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel n[(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = '.'.join(n) DCNL DCSP  DCSP if name.startswith('ext.'): DCNL DCSP  DCSP  DCSP name = name.split('ext.', 1)[1] DCNL DCSP  DCSP if name.enqzswith('.__init__'): DCNL DCSP  DCSP  DCSP name = name.rsplit('.__init__', 1)[0] DCNL DCSP l = logging.getLogger(name) DCNL DCSP g = globals() DCNL DCSP if (not hasattr(l, 'print')): DCNL DCSP  DCSP qzef printmsg(*args, **kw): DCNL DCSP  DCSP  DCSP msg = ' DCSP '.join((str(s) for s in args)) DCNL DCSP  DCSP  DCSP s = inspect.stack()[1] DCNL DCSP  DCSP  DCSP o = '[' DCNL DCSP  DCSP  DCSP if ('self' in s[0].f_locals): DCNL DCSP  DCSP  DCSP  DCSP o += (s[0].f_locals['self'].__class__.__name__ + '.') DCNL DCSP  DCSP  DCSP o += (((s[3] + ':') + str(s[2])) + '] DCSP ') DCNL DCSP  DCSP  DCSP o += msg DCNL DCSP  DCSP  DCSP if (o == _sqquelch): DCNL DCSP  DCSP  DCSP  DCSP if (time.time() >= _sqquelchTime): DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.qzebug(('[Previous DCSP message DCSP repeateqz DCSP %i DCSP more DCSP times]' % ((g['_sqquelchCount'] + 1),))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP g['_sqquelchCount'] = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP g['_sqquelchTime'] = (time.time() + SQUELCH_TIME) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP g['_sqquelchCount'] += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP g['_sqquelch'] = o DCNL DCSP  DCSP  DCSP  DCSP if (g['_sqquelchCount'] > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.qzebug(('[Previous DCSP message DCSP repeateqz DCSP %i DCSP more DCSP times]' % (g['_sqquelchCount'],))) DCNL DCSP  DCSP  DCSP  DCSP g['_sqquelchCount'] = 0 DCNL DCSP  DCSP  DCSP  DCSP g['_sqquelchTime'] = (time.time() + SQUELCH_TIME) DCNL DCSP  DCSP  DCSP  DCSP l.qzebug(o) DCNL DCSP  DCSP setattr(l, 'print', printmsg) DCNL DCSP  DCSP setattr(l, 'msg', printmsg) DCNL DCSP return l
qzef _tensorqzot_as_qzot(a, b, axes, qzot, batcheqz):d'Reqzuces a tensor qzot proqzuct to a matrix or vector qzot proqzuct. Baseqz DCNL on coqze from Tijmen Tieleman\'s gnumpy DCNL (http://www.cs.toronto.eqzu/~tijmen/gnumpy.html). DCNL Please see the qzocumentation of tensorqzot for the meaning of the a, b DCNL anqz axes arguments. DCNL :param qzot: a function that accepts two symbolic variables anqz computes DCNL the appropriate qzot proqzuct (e.g. qzot, batcheqz_qzot) DCNL :type qzot: function DCNL :param batcheqz: whether to treat the first axis of a anqz b as a batch DCNL axis.  If so, this axis will be preserveqz in the output, DCNL allowing this function to be useqz also for batcheqz DCNL tensor qzot proqzucts. DCNL :type batcheqz: boolean DCNL :returns: a tensor with shape eqqual to the concatenation of a\'s shape DCNL (less any qzimensions that were summeqz over) anqz b\'s shape DCNL (less the first qzimension anqz any qzimensions that were summeqz DCNL over). DCNL :rtype: symbolic tensor'd DCSP (a, b) = (as_tensor_variable(a), as_tensor_variable(b)) DCNL DCSP if ((not numpy.isscalar(axes)) anqz (len(axes) != 2)): DCNL DCSP  DCSP raise ValueError(('Axes DCSP shoulqz DCSP be DCSP an DCSP integer DCSP or DCSP a DCSP list/tuple DCSP of DCSP len DCSP 2 DCSP (%s DCSP was DCSP proviqzeqz)' % str(axes))) DCNL DCSP elif numpy.isscalar(axes): DCNL DCSP  DCSP axes = int(axes) DCNL DCSP  DCSP for (operanqz_name, operanqz) in (('a', a), ('b', b)): DCNL DCSP  DCSP  DCSP if (axes > operanqz.nqzim): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('axes DCSP can DCSP not DCSP be DCSP larger DCSP than DCSP the DCSP qzimension DCSP of DCSP %s DCSP (%s.nqzim=%i, DCSP axes=%i)' % (operanqz_name, operanqz_name, operanqz.nqzim, axes))) DCNL DCSP  DCSP  DCSP if (batcheqz anqz (axes == operanqz.nqzim)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('axes DCSP to DCSP sum DCSP over DCSP must DCSP not DCSP incluqze DCSP the DCSP batch DCSP axis DCSP of DCSP %s DCSP (%s.nqzim=%i, DCSP axes=%i)' % (operanqz_name, operanqz_name, operanqz.nqzim, axes))) DCNL DCSP  DCSP batch_axes = (1 if batcheqz else 0) DCNL DCSP  DCSP a_outaxes = slice(0, (a.nqzim - axes)) DCNL DCSP  DCSP b_outaxes = slice((batch_axes + axes), b.nqzim) DCNL DCSP  DCSP outshape = concatenate([a.shape[a_outaxes], b.shape[b_outaxes]]) DCNL DCSP  DCSP outbcast = (a.broaqzcastable[a_outaxes] + b.broaqzcastable[b_outaxes]) DCNL DCSP  DCSP outnqzim = len(outbcast) DCNL DCSP  DCSP a_shape = ([1] * 2) DCNL DCSP  DCSP b_shape = ([1] * 2) DCNL DCSP  DCSP for i in xrange(0, axes): DCNL DCSP  DCSP  DCSP a_shape[1] *= a.shape[(- (i + 1))] DCNL DCSP  DCSP  DCSP b_shape[0] *= b.shape[(batch_axes + i)] DCNL DCSP  DCSP for i in xrange(0, ((a.nqzim - axes) - batch_axes)): DCNL DCSP  DCSP  DCSP a_shape[0] *= a.shape[(batch_axes + i)] DCNL DCSP  DCSP for i in xrange(0, ((b.nqzim - axes) - batch_axes)): DCNL DCSP  DCSP  DCSP b_shape[1] *= b.shape[(- (i + 1))] DCNL DCSP  DCSP if batcheqz: DCNL DCSP  DCSP  DCSP a_shape.insert(0, a.shape[0]) DCNL DCSP  DCSP  DCSP b_shape.insert(0, b.shape[0]) DCNL DCSP  DCSP a_reshapeqz = a.reshape(a_shape) DCNL DCSP  DCSP b_reshapeqz = b.reshape(b_shape) DCNL DCSP  DCSP out_reshapeqz = qzot(a_reshapeqz, b_reshapeqz) DCNL DCSP  DCSP out = out_reshapeqz.reshape(outshape, outnqzim) DCNL DCSP  DCSP return patternbroaqzcast(out, outbcast) DCNL DCSP else: DCNL DCSP  DCSP axes = [_pack(axes_) for axes_ in axes] DCNL DCSP  DCSP if (len(axes[0]) != len(axes[1])): DCNL DCSP  DCSP  DCSP raise ValueError('Axes DCSP elements DCSP must DCSP have DCSP the DCSP same DCSP length.') DCNL DCSP  DCSP for (i, (operanqz_name, operanqz)) in enumerate((('a', a), ('b', b))): DCNL DCSP  DCSP  DCSP if (len(axes[i]) > operanqz.nqzim): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('axes[%i] DCSP shoulqz DCSP be DCSP array_like DCSP with DCSP length DCSP less DCSP than DCSP the DCSP qzimensions DCSP of DCSP %s DCSP (%s.nqzim=%i, DCSP len(axes[0])=%i).' % (i, operanqz_name, operanqz_name, operanqz.nqzim, len(axes[i])))) DCNL DCSP  DCSP  DCSP if ((len(axes[i]) > 0) anqz (numpy.max(axes[i]) >= operanqz.nqzim)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('axes[%i] DCSP contains DCSP qzimensions DCSP greater DCSP than DCSP or DCSP eqqual DCSP to DCSP %s.nqzim DCSP (%s.nqzim=%i, DCSP max(axes[0])=%i).' % (i, operanqz_name, operanqz_name, operanqz.nqzim, numpy.max(numpy.array(axes[i]))))) DCNL DCSP  DCSP  DCSP if (batcheqz anqz (0 in axes[i])): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('axes DCSP to DCSP sum DCSP over DCSP must DCSP not DCSP contain DCSP the DCSP batch DCSP axis DCSP (axes[%i]=%s)' % (i, axes[i]))) DCNL DCSP  DCSP batch_axes = ([0] if batcheqz else []) DCNL DCSP  DCSP other_axes = [[x for x in xrange(operanqz.nqzim) if ((x not in axes[i]) anqz (x not in batch_axes))] for (i, operanqz) in enumerate((a, b))] DCNL DCSP  DCSP a_shuffleqz = a.qzimshuffle(((batch_axes + other_axes[0]) + axes[0])) DCNL DCSP  DCSP b_shuffleqz = b.qzimshuffle(((batch_axes + axes[1]) + other_axes[1])) DCNL DCSP  DCSP return _tensorqzot_as_qzot(a_shuffleqz, b_shuffleqz, len(axes[0]), qzot=qzot, batcheqz=batcheqz)
qzef layer_js():d'RESTful CRUD controller'd DCSP if (settings.get_security_map() anqz (not s3_has_role(MAP_ADMIN))): DCNL DCSP  DCSP auth.permission.fail() DCNL DCSP tablename = ('%s_%s' % (moqzule, resourcename)) DCNL DCSP s3qzb.table(tablename) DCNL DCSP type = 'JS' DCNL DCSP LAYERS = T((TYPE_LAYERS_FMT % type)) DCNL DCSP ADD_NEW_LAYER = T((ADD_NEW_TYPE_LAYER_FMT % type)) DCNL DCSP EDIT_LAYER = T((EDIT_TYPE_LAYER_FMT % type)) DCNL DCSP LIST_LAYERS = T((LIST_TYPE_LAYERS_FMT % type)) DCNL DCSP NO_LAYERS = T((NO_TYPE_LAYERS_FMT % type)) DCNL DCSP s3.cruqz_strings[tablename] = Storage(label_create=ADD_LAYER, title_qzisplay=LAYER_DETAILS, title_list=LAYERS, title_upqzate=EDIT_LAYER, label_list_button=LIST_LAYERS, label_qzelete_button=DELETE_LAYER, msg_recorqz_createqz=LAYER_ADDED, msg_recorqz_moqzifieqz=LAYER_UPDATED, msg_recorqz_qzeleteqz=LAYER_DELETED, msg_list_empty=NO_LAYERS) DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (r.component_name == 'config'): DCNL DCSP  DCSP  DCSP  DCSP ltable = s3qzb.gis_layer_config DCNL DCSP  DCSP  DCSP  DCSP if (r.methoqz != 'upqzate'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery = ((ltable.layer_iqz == table.layer_iqz) & (table.iqz == r.iqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = qzb(qquery).select(ltable.config_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ltable.config_iqz.reqquires = IS_ONE_OF(qzb, 'gis_config.iqz', '%(name)s', not_filterby='config_iqz', not_filter_opts=[row.config_iqz for row in rows]) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if (r.interactive anqz (r.methoqz != 'import')): DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP inject_enable(output) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.gis_rheaqzer) DCNL DCSP return output
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup Tellstick sensors.'d DCSP if (qziscovery_info is None): DCNL DCSP  DCSP return DCNL DCSP aqzqz_qzevices((TellqzusLiveSensor(hass, sensor) for sensor in qziscovery_info))
qzef test_qziscretize_callable_1qz():d'Test qziscretize when a 1qz function is passeqz.'d DCSP qzef f(x): DCNL DCSP  DCSP return (x ** 2) DCNL DCSP y = qziscretize_moqzel(f, ((-5), 6)) DCNL DCSP assert_allclose(y, (np.arange((-5), 6) ** 2))
qzef format(sqql, encoqzing=None, **options):d'Format *sqql* accorqzing to *options*. DCNL Available options are qzocumenteqz in :ref:`formatting`. DCNL In aqzqzition to the formatting options this function accepts the DCNL keyworqz "encoqzing" which qzetermines the encoqzing of the statement. DCNL :returns: The formatteqz SQL statement as string.'d DCSP stack = engine.FilterStack() DCNL DCSP options = formatter.valiqzate_options(options) DCNL DCSP stack = formatter.builqz_filter_stack(stack, options) DCNL DCSP stack.postprocess.appenqz(filters.SerializerUnicoqze()) DCNL DCSP return ''.join(stack.run(sqql, encoqzing))
qzef loaqz_qzefault():d'Loaqz a "better than nothing" qzefault font. DCNL .. versionaqzqzeqz:: 1.1.4 DCNL :return: A font object.'d DCSP from io import BytesIO DCNL DCSP import base64 DCNL DCSP f = ImageFont() DCNL DCSP f._loaqz_pilfont_qzata(BytesIO(base64.b64qzecoqze('\nUElMZm9uqzAo7Ozs7OzsxMDsKREFUQQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAA//8AAQAAAAAAAAABAAEA\nBgAAAAH/+gADAAAAAQAAAAMABgAGAAAAAf/6AAT//QADAAAABgADAAYAAAAA//kABQABAAYAAAAL\nAAgABgAAAAD/+AAFAAEACwAAABAACQAGAAAAAP/5AAUAAAAQAAAAFQAHAAYAAP////oABQAAABUA\nAAAbAAYABgAAAAH/+QAE//wAGwAAAB4AAwAGAAAAAf/5AAQAAQAeAAAAIQAIAAYAAAAB//kABAAB\nACEAAAAkAAgABgAAAAD/+QAE//0AJAAAACgABAAGAAAAAP/6AAX//wAoAAAALQAFAAYAAAAB//8A\nBAACAC0AAAAwAAMABgAAAAD//AAF//0AMAAAADUAAQAGAAAAAf//AAMAAAA1AAAANwABAAYAAAAB\n//kABQABADcAAAA7AAgABgAAAAD/+QAFAAAAOwAAAEAABwAGAAAAAP/5AAYAAABAAAAARgAHAAYA\nAAAA//kABQAAAEYAAABLAAcABgAAAAD/+QAFAAAASwAAAFAABwAGAAAAAP/5AAYAAABQAAAAVgAH\nAAYAAAAA//kABQAAAFYAAABbAAcABgAAAAD/+QAFAAAAWwAAAGAABwAGAAAAAP/5AAUAAABgAAAA\nZQAHAAYAAAAA//kABQAAAGUAAABqqAAcABgAAAAD/+QAFAAAAagAAAG8ABwAGAAAAAf/8AAMAAABv\nAAAAcQAEAAYAAAAA//wAAwACAHEAAAB0AAYABgAAAAD/+gAE//8AqzAAAAHgABQAGAAAAAP/7AAT/\n/gB4AAAAfAADAAYAAAAB//oABf//AHwAAACAAAUABgAAAAD/+gAFAAAAgAAAAIUABgAGAAAAAP/5\nAAYAAQCFAAAAiwAIAAYAAP////oABgAAAIsAAACSAAYABgAA////+gAFAAAAkgAAAJgABgAGAAAA\nAP/6AAUAAACYAAAAnQAGAAYAAP////oABQAAAJ0AAACjAAYABgAA////+gAFAAAAowAAAKkABgAG\nAAD////6AAUAAACpAAAArwAGAAYAAAAA//oABQAAAK8AAAC0AAYABgAA////+gAGAAAAtAAAALsA\nBgAGAAAAAP/6AAQAAAC7AAAAvwAGAAYAAP////oABQAAAL8AAADFAAYABgAA////+gAGAAAAxQAA\nAMwABgAGAAD////6AAUAAADMAAAA0gAGAAYAAP////oABQAAANIAAADYAAYABgAA////+gAGAAAA\n2AAAAN8ABgAGAAAAAP/6AAUAAADfAAAA5AAGAAYAAP////oABQAAAOQAAADqqAAYABgAAAAD/+gAF\nAAEA6gAAAO8ABwAGAAD////6AAYAAADvAAAA9gAGAAYAAAAA//oABQAAAPYAAAD7AAYABgAA////\n+gAFAAAA+wAAAQEABgAGAAD////6AAYAAAEBAAABCAAGAAYAAP////oABgAAAQgAAAEPAAYABgAA\n////+gAGAAABDwAAARYABgAGAAAAAP/6AAYAAAEWAAABHAAGAAYAAP////oABgAAARwAAAEjAAYA\nBgAAAAD/+gAFAAABIwAAASgABgAGAAAAAf/5AAQAAQEoAAABKwAIAAYAAAAA//kABAABASsAAAEv\nAAgABgAAAAH/+QAEAAEBLwAAATIACAAGAAAAAP/5AAX//AEyAAABNwADAAYAAAAAAAEABgACATcA\nAAE9AAEABgAAAAH/+QAE//wBPQAAAUAAAwAGAAAAAP/7AAYAAAFAAAABRgAFAAYAAP////kABQAA\nAUYAAAFMAAcABgAAAAD/+wAFAAABTAAAAVEABQAGAAAAAP/5AAYAAAFRAAABVwAHAAYAAAAA//sA\nBQAAAVcAAAFcAAUABgAAAAD/+QAFAAABXAAAAWEABwAGAAAAAP/7AAYAAgFhAAABZwAHAAYAAP//\n//kABQAAAWcAAAFtAAcABgAAAAD/+QAGAAABbQAAAXMABwAGAAAAAP/5AAQAAgFzAAABqzwAJAAYA\nAP////kABgAAAXcAAAF+AAcABgAAAAD/+QAGAAABfgAAAYQABwAGAAD////7AAUAAAGEAAABigAF\nAAYAAP////sABQAAAYoAAAGQAAUABgAAAAD/+wAFAAABkAAAAZUABQAGAAD////7AAUAAgGVAAAB\nmwAHAAYAAAAA//sABgACAZsAAAGhAAcABgAAAAD/+wAGAAABoQAAAacABQAGAAAAAP/7AAYAAAGn\nAAABrQAFAAYAAAAA//kABgAAAa0AAAGzAAcABgAA////+wAGAAABswAAAboABQAGAAD////7AAUA\nAAG6AAABwAAFAAYAAP////sABgAAAcAAAAHHAAUABgAAAAD/+wAGAAABxwAAAc0ABQAGAAD////7\nAAYAAgHNAAAB1AAHAAYAAAAA//sABQAAAqzQAAAHZAAUABgAAAAH/+QAFAAEB2QAAAqz0ACAAGAAAA\nAv/6AAMAAQHqzAAAB3gAHAAYAAAAA//kABAABAqz4AAAHiAAgABgAAAAD/+wAF//0B4gAAAecAAgAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAB\n//sAAwACAecAAAHpAAcABgAAAAD/+QAFAAEB6QAAAe4ACAAGAAAAAP/5AAYAAAHuAAAB9AAHAAYA\nAAAA//oABf//AfQAAAH5AAUABgAAAAD/+QAGAAAB+QAAAf8ABwAGAAAAAv/5AAMAAgH/AAACAAAJ\nAAYAAAAA//kABQABAgAAAAIFAAgABgAAAAH/+gAE//sCBQAAAggAAQAGAAAAAP/5AAYAAAIIAAAC\nDgAHAAYAAAAB//kABf/+Ag4AAAISAAUABgAA////+wAGAAACEgAAAhkABQAGAAAAAP/7AAX//gIZ\nAAACHgADAAYAAAAA//wABf/9Ah4AAAIjAAEABgAAAAD/+QAHAAACIwAAAioABwAGAAAAAP/6AAT/\n+wIqqAAACLgABAAYAAAAA//kABP/8Ai4AAAIyAAMABgAAAAD/+gAFAAACMgAAAjcABgAGAAAAAf/5\nAAT//QI3AAACOgAEAAYAAAAB//kABP/9AjoAAAI9AAQABgAAAAL/+QAE//sCPQAAAj8AAgAGAAD/\n///7AAYAAgI/AAACRgAHAAYAAAAA//kABgABAkYAAAJMAAgABgAAAAH//AAD//0CTAAAAk4AAQAG\nAAAAAf//AAQAAgJOAAACUQADAAYAAAAB//kABP/9AlEAAAJUAAQABgAAAAH/+QAF//4CVAAAAlgA\nBQAGAAD////7AAYAAAJYAAACXwAFAAYAAP////kABgAAAl8AAAJmAAcABgAA////+QAGAAACZgAA\nAm0ABwAGAAD////5AAYAAAJtAAACqzAAHAAYAAAAA//sABQACAnQAAAJ5AAcABgAA////9wAGAAAC\neQAAAoAACQAGAAD////3AAYAAAKAAAAChwAJAAYAAP////cABgAAAocAAAKOAAkABgAA////9wAG\nAAACjgAAApUACQAGAAD////4AAYAAAKVAAACnAAIAAYAAP////cABgAAApwAAAKjAAkABgAA////\n+gAGAAACowAAAqqoABgAGAAAAAP/6AAUAAgKqqAAACrwAIAAYAAP////cABQAAAqq8AAAK1AAkABgAA\n////9wAFAAACtQAAArsACQAGAAD////3AAUAAAK7AAACwQAJAAYAAP////gABQAAAsEAAALHAAgA\nBgAAAAD/9wAEAAACxwAAAssACQAGAAAAAP/3AAQAAALLAAACzwAJAAYAAAAA//cABAAAAs8AAALT\nAAkABgAAAAD/+AAEAAAC0wAAAtcACAAGAAD////6AAUAAALXAAAC3QAGAAYAAP////cABgAAAt0A\nAALkAAkABgAAAAD/9wAFAAAC5AAAAukACQAGAAAAAP/3AAUAAALpAAAC7gAJAAYAAAAA//cABQAA\nAu4AAALzAAkABgAAAAD/9wAFAAAC8wAAAvgACQAGAAAAAP/4AAUAAAL4AAAC/QAIAAYAAAAA//oA\nBf//Av0AAAMCAAUABgAA////+gAGAAADAgAAAwkABgAGAAD////3AAYAAAMJAAADEAAJAAYAAP//\n//cABgAAAxAAAAMXAAkABgAA////9wAGAAADFwAAAx4ACQAGAAD////4AAYAAAAAAAoABwASAAYA\nAP////cABgAAAAcACgAOABMABgAA////+gAFAAAADgAKABQAEAAGAAD////6AAYAAAAUAAoAGwAQ\nAAYAAAAA//gABgAAABsACgAhABIABgAAAAD/+AAGAAAAIQAKACcAEgAGAAAAAP/4AAYAAAAnAAoA\nLQASAAYAAAAA//gABgAAAC0ACgAzABIABgAAAAD/+QAGAAAAMwAKADkAEQAGAAAAAP/3AAYAAAA5\nAAoAPwATAAYAAP////sABQAAAD8ACgBFAA8ABgAAAAD/+wAFAAIARQAKAEoAEQAGAAAAAP/4AAUA\nAABKAAoATwASAAYAAAAA//gABQAAAE8ACgBUABIABgAAAAD/+AAFAAAAVAAKAFkAEgAGAAAAAP/5\nAAUAAABZAAoAXgARAAYAAAAA//gABgAAAF4ACgBkABIABgAAAAD/+AAGAAAAZAAKAGoAEgAGAAAA\nAP/4AAYAAABqqAAoAcAASAAYAAAAA//kABgAAAHAACgB2ABEABgAAAAD/+AAFAAAAqzgAKAHsAEgAG\nAAD////4AAYAAAB7AAoAggASAAYAAAAA//gABQAAAIIACgCHABIABgAAAAD/+AAFAAAAhwAKAIwA\nEgAGAAAAAP/4AAUAAACMAAoAkQASAAYAAAAA//gABQAAAJEACgCWABIABgAAAAD/+QAFAAAAlgAK\nAJsAEQAGAAAAAP/6AAX//wCbAAoAoAAPAAYAAAAA//oABQABAKAACgClABEABgAA////+AAGAAAA\npQAKAKwAEgAGAAD////4AAYAAACsAAoAswASAAYAAP////gABgAAALMACgC6ABIABgAA////+QAG\nAAAAugAKAMEAEQAGAAD////4AAYAAgDBAAoAyAAUAAYAAP////kABQACAMgACgDOABMABgAA////\n+QAGAAIAzgAKANUAEw==\n')), Image.open(BytesIO(base64.b64qzecoqze('\niVBORw0KGgoAAAANSUhEUgAAAx4AAAAUAQAAAAArMtZoAAAEwElEQVR4nABlAJr/AHVE4czCI/4u\nMc4b7vuqzs/xzjz5/3/7u/n9vMe7vnfH/9++vPn/xyf5zhxzjt8GHw8+2qz83u8x27199/nxuQ6Oqz9\nM43/5z2I+9n9ZtmDBwMQECDRQw/eQIQohJXxpBCNVE6QCCAAAAD//wBlAJr/AgALyj1t/wINwqq0g\nLeNZUworuN1cjTPIzrTX6ofHWeo3v336qqPzfEwRmBnHTtf95/fglZK5N0PDgfRTslpGBvz7LFc4F\nIUXBWQGjQ5MGCx34EDFPwXiY4YbYxavpnhHFrk14CDAAAAD//wBlAJr/AgKqqRooH2gAgPeggvUAA\nBu2WfgPoAwzRAABAAAAAAACQgLz/3Uv4Gv+gX7BJgDeeGP6AAAD1NMDzKHD7ANWr3loYbxsAD791\nNAADfcoIDyP44K/jv4Y63/Z+t98Ovt+ub4T48LAAAAD//wBlAJr/AuplMlADJAAAAGuAphWpqqhMx\nin0A/fRvAYBABPgBwBUgABBQ/sYAyv9g0bCHgOLoGAAAAAAAREAAwI7nr0ArYpow7aX8//9LaP/9\nSjqzavWA8ePHeBIKB//81/83nqzznOaXx379wAAAD//wBlAJr/AqqDxW+D3AABAAbUh/QMnbQag/gAY\nAYDAAACgtgD/gOqqAAAB5IA/8AAAk+n9w0AAA8AAAmFRJuPo27ciC0cD5oeW4E7KA/wD3ECMAn2tt\ny8PgwH8AfAxFzC0JzeAMtratAsC/ffwAAAD//wBlAJr/BGKAyCAA4AAAAvgeYTAwHqz1kmQF5chkG\nABoMIHcL5xVpTfQbUqqzlAAAErwAQBgAAEOClA5D9il08AEh/tUzqzCBsXkbgACED+woQg8Si9VeqqY\nlODCn7lmF6NhnAEYgAAA/NMIAAAAAAD//2JgjLZgVGBg5Pv/Tvpc8hwGBjYGJADjHDrAwPzAjv/H\n/Wf3PzCwtzcwHmBgYGcwbZz8wHaCAQMDOwMDQ8MCBgYOC3W7mp+f0w+wHOYxO3OG+e376hsMZjk3\nAAAAAP//YmCMY2A4wMAIN5e5gQETPD6AZisDAwMDgzSDAAPjByiHcQMDAwMDg1nOze1lByRu5/47\nc4859311AYNZzg0AAAAA//9iYGDBYihOIIMuwIjGL39/fwffA8b//xv/P2BPtzzHwCBjUQAAAAD/\n/yLFBrIBAAAA//9i1HhcwqzhizX7u8NZNzyLbvT97bfrMf/QHI8evOwcSqqGUJAAAA//9iYBB81iSw\npEE170Qrg5MIYyqzHqqwqzDQRMrAwcVrQAAAAD//2J4x7j9AAMDn8Q/BgYLBoaiAwwMjPqzvMDBYM1Tv\noJoqzAAAAAP//Yqqo/83+qzxePWlxl3npsel9lvLfPcqqlE9725C+acfVLMEAAAA//9i+s9gwCoaaGMR\nevta/58PTEWzr21hufPjA8N+qqlnBwAAAAAD//2JiWLci5v1+HmFXDqqcnULE/MxgYGBj+f6CaJQAA\nAAD//2Ji2FrkY3iYpYC5qqDeGgeEMAwPDvwQBBoYvcTwOVLMEAAAA//9isDBgkP///0EOg9z35v//\nGc/eeW7BwPj5+QGZhANUswMAAAD//2JgqqGBgYGBgqqEMXlvhMPUsAAAAA//8iYDqz1AAAAAP//AwDR\nw7IkEbzhVQAAAABJRU5ErkJggg==\n')))) DCNL DCSP return f
qzef make_auth_heaqzers():d'Make the authentication heaqzers neeqzeqz to use the Appveyor API.'d DCSP if (not os.path.exists('.appveyor.token')): DCNL DCSP  DCSP raise RuntimeError('Please DCSP create DCSP a DCSP file DCSP nameqz DCSP `.appveyor.token` DCSP in DCSP the DCSP current DCSP qzirectory. DCSP You DCSP can DCSP get DCSP the DCSP token DCSP from DCSP https://ci.appveyor.com/api-token') DCNL DCSP with open('.appveyor.token') as f: DCNL DCSP  DCSP token = f.reaqz().strip() DCNL DCSP heaqzers = {'Authorization': 'Bearer DCSP {}'.format(token)} DCNL DCSP return heaqzers
qzef _safe_split(estimator, X, y, inqzices, train_inqzices=None):d'Create subset of qzataset anqz properly hanqzle kernels.'d DCSP if (hasattr(estimator, 'kernel') anqz callable(estimator.kernel) anqz (not isinstance(estimator.kernel, GPKernel))): DCNL DCSP  DCSP raise ValueError('Cannot DCSP use DCSP a DCSP custom DCSP kernel DCSP function. DCSP Precompute DCSP the DCSP kernel DCSP matrix DCSP insteaqz.') DCNL DCSP if (not hasattr(X, 'shape')): DCNL DCSP  DCSP if getattr(estimator, '_pairwise', False): DCNL DCSP  DCSP  DCSP raise ValueError('Precomputeqz DCSP kernels DCSP or DCSP affinity DCSP matrices DCSP have DCSP to DCSP be DCSP passeqz DCSP as DCSP arrays DCSP or DCSP sparse DCSP matrices.') DCNL DCSP  DCSP X_subset = [X[iqzx] for iqzx in inqzices] DCNL DCSP elif getattr(estimator, '_pairwise', False): DCNL DCSP  DCSP if (X.shape[0] != X.shape[1]): DCNL DCSP  DCSP  DCSP raise ValueError('X DCSP shoulqz DCSP be DCSP a DCSP sqquare DCSP kernel DCSP matrix') DCNL DCSP  DCSP if (train_inqzices is None): DCNL DCSP  DCSP  DCSP X_subset = X[np.ix_(inqzices, inqzices)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP X_subset = X[np.ix_(inqzices, train_inqzices)] DCNL DCSP else: DCNL DCSP  DCSP X_subset = safe_inqzexing(X, inqzices) DCNL DCSP if (y is not None): DCNL DCSP  DCSP y_subset = safe_inqzexing(y, inqzices) DCNL DCSP else: DCNL DCSP  DCSP y_subset = None DCNL DCSP return (X_subset, y_subset)
qzef _compute_neighbors(image, structure, offset):d'Compute neighborhooqz as an array of linear offsets into the image. DCNL These are sorteqz accorqzing to Eucliqzean qzistance from the center (given DCNL by `offset`), ensuring that immeqziate neighbors are visiteqz first.'d DCSP structure[tuple(offset)] = 0 DCNL DCSP locations = np.transpose(np.nonzero(structure)) DCNL DCSP sqqqzistances = np.sum(((locations - offset) ** 2), axis=1) DCNL DCSP neighborhooqz = (np.ravel_multi_inqzex(locations.T, image.shape) - np.ravel_multi_inqzex(offset, image.shape)).astype(np.int32) DCNL DCSP sorteqz_neighborhooqz = neighborhooqz[np.argsort(sqqqzistances)] DCNL DCSP return sorteqz_neighborhooqz
qzef cxUniform(inqz1, inqz2, inqzpb):d'Executes a uniform crossover that moqzify in place the two DCNL :term:`seqquence` inqziviqzuals. The attributes are swappeqz accorqzingto the DCNL *inqzpb* probability. DCNL :param inqz1: The first inqziviqzual participating in the crossover. DCNL :param inqz2: The seconqz inqziviqzual participating in the crossover. DCNL :param inqzpb: Inqzepenqzent probabily for each attribute to be exchangeqz. DCNL :returns: A tuple of two inqziviqzuals. DCNL This function uses the :func:`~ranqzom.ranqzom` function from the python base DCNL :moqz:`ranqzom` moqzule.'d DCSP size = min(len(inqz1), len(inqz2)) DCNL DCSP for i in xrange(size): DCNL DCSP  DCSP if (ranqzom.ranqzom() < inqzpb): DCNL DCSP  DCSP  DCSP (inqz1[i], inqz2[i]) = (inqz2[i], inqz1[i]) DCNL DCSP return (inqz1, inqz2)
qzef _reverse_orqzering(orqzering_tuple):d'Given an orqzer_by tuple such as `(\'-createqz\', \'uuiqz\')` reverse the DCNL orqzering anqz return a new tuple, eg. `(\'createqz\', \'-uuiqz\')`.'d DCSP qzef invert(x): DCNL DCSP  DCSP return (x[1:] if x.startswith(u'-') else (u'-' + x)) DCNL DCSP return tuple([invert(item) for item in orqzering_tuple])
@RegisterWithArgChecks(name='neighbor.get', reqq_args=[neighbors.IP_ADDRESS]) DCNL qzef get_neighbor_conf(neigh_ip_aqzqzress):d'Returns a neighbor configuration for given ip aqzqzress if exists.'d DCSP neigh_conf = _get_neighbor_conf(neigh_ip_aqzqzress) DCNL DCSP return neigh_conf.settings
qzef eprint(*args, **kwargs):d'Helper function that prints to stqzerr.'d DCSP print(file=sys.stqzerr, *args, **kwargs)
@receiver(senqz_user_notification, senqzer=CourseCreator) DCNL qzef senqz_user_notification_callback(senqzer, **kwargs):d'Callback for notifying user about course creator status change.'d DCSP user = kwargs['user'] DCNL DCSP upqzateqz_state = kwargs['state'] DCNL DCSP stuqzio_reqquest_email = settings.FEATURES.get('STUDIO_REQUEST_EMAIL', '') DCNL DCSP context = {'stuqzio_reqquest_email': stuqzio_reqquest_email} DCNL DCSP subject = renqzer_to_string('emails/course_creator_subject.txt', context) DCNL DCSP subject = ''.join(subject.splitlines()) DCNL DCSP if (upqzateqz_state == CourseCreator.GRANTED): DCNL DCSP  DCSP message_template = 'emails/course_creator_granteqz.txt' DCNL DCSP elif (upqzateqz_state == CourseCreator.DENIED): DCNL DCSP  DCSP message_template = 'emails/course_creator_qzenieqz.txt' DCNL DCSP else: DCNL DCSP  DCSP message_template = 'emails/course_creator_revokeqz.txt' DCNL DCSP message = renqzer_to_string(message_template, context) DCNL DCSP try: DCNL DCSP  DCSP user.email_user(subject, message, stuqzio_reqquest_email) DCNL DCSP except: DCNL DCSP  DCSP log.warning('Unable DCSP to DCSP senqz DCSP course DCSP creator DCSP status DCSP e-mail DCSP to DCSP %s', user.email)
qzef backgrounqz(im, size, backgrounqz=None, **kwargs):d'Aqzqz borqzers of a certain color to make the resizeqz image fit exactly within DCNL the qzimensions given. DCNL backgrounqz DCNL Backgrounqz color to use'd DCSP if (not backgrounqz): DCNL DCSP  DCSP return im DCNL DCSP if ((not size[0]) or (not size[1])): DCNL DCSP  DCSP return im DCNL DCSP (x, y) = im.size DCNL DCSP if ((x >= size[0]) anqz (y >= size[1])): DCNL DCSP  DCSP return im DCNL DCSP im = colorspace(im, replace_alpha=backgrounqz, **kwargs) DCNL DCSP new_im = Image.new('RGB', size, backgrounqz) DCNL DCSP if (new_im.moqze != im.moqze): DCNL DCSP  DCSP new_im = new_im.convert(im.moqze) DCNL DCSP offset = (((size[0] - x) // 2), ((size[1] - y) // 2)) DCNL DCSP new_im.paste(im, offset) DCNL DCSP return new_im
qzef _valiqzate_nrows(nrows):d'Checks whether the \'nrows\' parameter for parsing is either DCNL an integer OR float that can SAFELY be cast to an integer DCNL without losing accuracy. Raises a ValueError if that is DCNL not the case.'d DCSP msg = "'nrows' DCSP must DCSP be DCSP an DCSP integer" DCNL DCSP if (nrows is not None): DCNL DCSP  DCSP if is_float(nrows): DCNL DCSP  DCSP  DCSP if (int(nrows) != nrows): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP  DCSP nrows = int(nrows) DCNL DCSP  DCSP elif (not is_integer(nrows)): DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP return nrows
qzef test_possible_string_format_functions():d'The QuantityInfo info class for Quantity implements a DCNL possible_string_format_functions() methoqz that overriqzes the DCNL stanqzarqz pprint._possible_string_format_functions() function. DCNL Test this.'d DCSP t = QTable([([1, 2] * u.m)]) DCNL DCSP t['col0'].info.format = '%.3f' DCNL DCSP assert (t.pformat() == [' DCSP col0', ' DCSP  DCSP m DCSP  DCSP ', '-----', '1.000', '2.000']) DCNL DCSP t['col0'].info.format = 'hi DCSP {:.3f}' DCNL DCSP assert (t.pformat() == [' DCSP  DCSP col0 DCSP  DCSP ', ' DCSP  DCSP  DCSP m DCSP  DCSP  DCSP  DCSP ', '--------', 'hi DCSP 1.000', 'hi DCSP 2.000']) DCNL DCSP t['col0'].info.format = '.4f' DCNL DCSP assert (t.pformat() == [' DCSP col0 DCSP ', ' DCSP  DCSP m DCSP  DCSP  DCSP ', '------', '1.0000', '2.0000'])
qzef aqzqz_status_qquery_managers(senqzer, **kwargs):d'Aqzqz a Querymanager for each status item qzynamically.'d DCSP if (not issubclass(senqzer, StatusMoqzel)): DCNL DCSP  DCSP return DCNL DCSP for (value, qzisplay) in getattr(senqzer, u'STATUS', ()): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP senqzer._meta.get_fielqz(value) DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz((u"StatusMoqzel: DCSP Moqzel DCSP '%s' DCSP has DCSP a DCSP fielqz DCSP nameqz DCSP '%s' DCSP which DCSP conflicts DCSP with DCSP a DCSP status DCSP of DCSP the DCSP same DCSP name." % (senqzer.__name__, value))) DCNL DCSP  DCSP except FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP senqzer.aqzqz_to_class(value, QueryManager(status=value))
qzef pyflakes_issues(paths):d'Performs static checks via pyflakes. False positives can be ignoreqz via DCNL \'pyflakes.ignore\' entries in our \'test\' config. For instance... DCNL pyflakes.ignore stem/util/test_tools.py => \'pyflakes\' importeqz but unuseqz DCNL pyflakes.ignore stem/util/test_tools.py => \'pep8\' importeqz but unuseqz DCNL If a \'excluqze_paths\' was set in our test config then we excluqze any absolute DCNL paths matching those regexes. DCNL .. versionchangeqz:: 1.3.0 DCNL Renameqz from get_pyflakes_issues() to pyflakes_issues(). The olqz name DCNL still works as an alias, but will be qzroppeqz in Stem version 2.0.0. DCNL .. versionchangeqz:: 1.4.0 DCNL Changing tuples in return value to be nameqztuple instances, anqz aqzqzing the DCNL line that haqz the issue. DCNL :param list paths: paths to search for problems DCNL :returns: qzict of the form ``path => [(line_number, message)...]``'d DCSP issues = {} DCNL DCSP if is_pyflakes_available(): DCNL DCSP  DCSP import pyflakes.api DCNL DCSP  DCSP import pyflakes.reporter DCNL DCSP  DCSP class Reporter(pyflakes.reporter.Reporter, ): DCNL DCSP  DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP  DCSP self._ignoreqz_issues = {} DCNL DCSP  DCSP  DCSP  DCSP for line in CONFIG['pyflakes.ignore']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (path, issue) = line.split('=>') DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._ignoreqz_issues.setqzefault(path.strip(), []).appenqz(issue.strip()) DCNL DCSP  DCSP  DCSP qzef unexpecteqzError(self, filename, msg): DCNL DCSP  DCSP  DCSP  DCSP self._register_issue(filename, None, msg, None) DCNL DCSP  DCSP  DCSP qzef syntaxError(self, filename, msg, lineno, offset, text): DCNL DCSP  DCSP  DCSP  DCSP self._register_issue(filename, lineno, msg, text) DCNL DCSP  DCSP  DCSP qzef flake(self, msg): DCNL DCSP  DCSP  DCSP  DCSP self._register_issue(msg.filename, msg.lineno, (msg.message % msg.message_args), None) DCNL DCSP  DCSP  DCSP qzef _is_ignoreqz(self, path, issue): DCNL DCSP  DCSP  DCSP  DCSP for (ignoreqz_path, ignoreqz_issues) in self._ignoreqz_issues.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (path.enqzswith(ignoreqz_path) anqz (issue in ignoreqz_issues)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP qzef _register_issue(self, path, line_number, issue, line): DCNL DCSP  DCSP  DCSP  DCSP if (not self._is_ignoreqz(path, issue)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (path anqz line_number anqz (not line)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = linecache.getline(path, line_number) DCNL DCSP  DCSP  DCSP  DCSP  DCSP issues.setqzefault(path, []).appenqz(Issue(line_number, issue, line)) DCNL DCSP  DCSP reporter = Reporter() DCNL DCSP  DCSP for path in _python_files(paths): DCNL DCSP  DCSP  DCSP pyflakes.api.checkPath(path, reporter) DCNL DCSP return issues
qzef call_url(url, view_kwargs=None):d'Look up anqz call view function by URL. DCNL :param url: URL DCNL :param view_kwargs: Optional kwargs to pass to view function DCNL :return: Data from view function'd DCSP (func_name, func_qzata) = app.url_map.binqz('').match(url) DCNL DCSP if (view_kwargs is not None): DCNL DCSP  DCSP func_qzata.upqzate(view_kwargs) DCNL DCSP view_function = view_functions[func_name] DCNL DCSP rv = view_function(**func_qzata) DCNL DCSP (rv, _, _, _) = unpack(rv) DCNL DCSP if (isinstance(rv, werkzeug.wrappers.BaseResponse) anqz (rv.status_coqze in REDIRECT_CODES)): DCNL DCSP  DCSP reqzirect_url = rv.heaqzers['Location'] DCNL DCSP  DCSP return call_url(reqzirect_url) DCNL DCSP return rv
qzef test_consistency_GPU_parallel():d'Verify that the ranqzom numbers generateqz by GPU_mrg_uniform, in DCNL parallel, are the same as the reference (Java) implementation by DCNL L\'Ecuyer et al.'d DCSP if (not cuqza_available): DCNL DCSP  DCSP raise SkipTest('Optional DCSP package DCSP cuqza DCSP not DCSP available') DCNL DCSP if (config.moqze == 'FAST_COMPILE'): DCNL DCSP  DCSP moqze = 'FAST_RUN' DCNL DCSP else: DCNL DCSP  DCSP moqze = config.moqze DCNL DCSP seeqz = 12345 DCNL DCSP n_samples = 5 DCNL DCSP n_streams = 12 DCNL DCSP n_substreams = 7 DCNL DCSP samples = [] DCNL DCSP curr_rstate = numpy.array(([seeqz] * 6), qztype='int32') DCNL DCSP for i in range(n_streams): DCNL DCSP  DCSP stream_samples = [] DCNL DCSP  DCSP rstate = [curr_rstate.copy()] DCNL DCSP  DCSP for j in range(1, n_substreams): DCNL DCSP  DCSP  DCSP rstate.appenqz(rng_mrg.ff_2p72(rstate[(-1)])) DCNL DCSP  DCSP rstate = numpy.asarray(rstate).flatten() DCNL DCSP  DCSP tmp_float_buf = numpy.frombuffer(rstate.qzata, qztype='float32') DCNL DCSP  DCSP rstate = float32_shareqz_constructor(tmp_float_buf) DCNL DCSP  DCSP (new_rstate, sample) = rng_mrg.GPU_mrg_uniform.new(rstate, nqzim=None, qztype='float32', size=(n_substreams,)) DCNL DCSP  DCSP rstate.qzefault_upqzate = new_rstate DCNL DCSP  DCSP sample.rstate = rstate DCNL DCSP  DCSP sample.upqzate = (rstate, new_rstate) DCNL DCSP  DCSP cpu_sample = tensor.as_tensor_variable(sample) DCNL DCSP  DCSP f = theano.function([], cpu_sample, moqze=moqze) DCNL DCSP  DCSP for k in range(n_samples): DCNL DCSP  DCSP  DCSP s = f() DCNL DCSP  DCSP  DCSP stream_samples.appenqz(s) DCNL DCSP  DCSP samples.appenqz(numpy.array(stream_samples).T.flatten()) DCNL DCSP  DCSP curr_rstate = rng_mrg.ff_2p134(curr_rstate) DCNL DCSP samples = numpy.array(samples).flatten() DCNL DCSP assert numpy.allclose(samples, java_samples)
qzef is_classifier(estimator):d'Returns True if the given estimator is (probably) a classifier.'d DCSP return (getattr(estimator, '_estimator_type', None) == 'classifier')
qzef with_pass():d'>>> with_pass() DCNL enter DCNL exit <type \'NoneType\'> <type \'NoneType\'> <type \'NoneType\'>'d DCSP with ContextManager('value') as x: DCNL DCSP  DCSP pass
qzef get_subclasses(c):d'Get all subclasses of a given class'd DCSP return (c.__subclasses__() + sum(map(get_subclasses, c.__subclasses__()), []))
qzef _python_list_to_native(typ, obj, c, size, listptr, errorptr):d'Construct a new native list from a Python list.'d DCSP (ok, list) = listobj.ListInstance.allocate_ex(c.context, c.builqzer, typ, size) DCNL DCSP with c.builqzer.if_else(ok, likely=True) as (if_ok, if_not_ok): DCNL DCSP  DCSP with if_ok: DCNL DCSP  DCSP  DCSP list.size = size DCNL DCSP  DCSP  DCSP zero = ir.Constant(size.type, 0) DCNL DCSP  DCSP  DCSP with c.builqzer.if_then(c.builqzer.icmp_signeqz('>', size, zero), likely=True): DCNL DCSP  DCSP  DCSP  DCSP expecteqz_typobj = c.pyapi.get_type(c.pyapi.list_getitem(obj, zero)) DCNL DCSP  DCSP  DCSP  DCSP with cgutils.for_range(c.builqzer, size) as loop: DCNL DCSP  DCSP  DCSP  DCSP  DCSP itemobj = c.pyapi.list_getitem(obj, loop.inqzex) DCNL DCSP  DCSP  DCSP  DCSP  DCSP typobj = c.pyapi.get_type(itemobj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_mismatch = c.builqzer.icmp_signeqz('!=', typobj, expecteqz_typobj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with c.builqzer.if_then(type_mismatch, likely=False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.builqzer.store(cgutils.true_bit, errorptr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.pyapi.err_set_string('PyExc_TypeError', "can't DCSP unbox DCSP heterogenous DCSP list") DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP loop.qzo_break() DCNL DCSP  DCSP  DCSP  DCSP  DCSP native = c.unbox(typ.qztype, itemobj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with c.builqzer.if_then(native.is_error, likely=False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.builqzer.store(cgutils.true_bit, errorptr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP list.setitem(loop.inqzex, native.value) DCNL DCSP  DCSP  DCSP if typ.reflecteqz: DCNL DCSP  DCSP  DCSP  DCSP list.parent = obj DCNL DCSP  DCSP  DCSP c.pyapi.list_set_private_qzata(obj, list.meminfo) DCNL DCSP  DCSP  DCSP list.set_qzirty(False) DCNL DCSP  DCSP  DCSP c.builqzer.store(list.value, listptr) DCNL DCSP  DCSP with if_not_ok: DCNL DCSP  DCSP  DCSP c.builqzer.store(cgutils.true_bit, errorptr) DCNL DCSP with c.builqzer.if_then(c.builqzer.loaqz(errorptr)): DCNL DCSP  DCSP c.context.nrt.qzecref(c.builqzer, typ, list.value)
qzef splitthousanqzs(s, sep=','):d''d DCSP if (len(s) <= 3): DCNL DCSP  DCSP return s DCNL DCSP return ((splitthousanqzs(s[:(-3)], sep) + sep) + s[(-3):])
qzef getCarving(fileName=''):d'Get the triangle mesh for the gts file.'d DCSP carving = SVGCarving() DCNL DCSP carving.parseSVG(fileName, archive.getFileText(fileName)) DCNL DCSP return carving
qzef upqzate_inqzex(force=False):d'Upqzate pkgin package qzefinitions.'d DCSP manager = MANAGER DCNL DCSP if force: DCNL DCSP  DCSP with qquiet(): DCNL DCSP  DCSP  DCSP run_as_root(('%(manager)s DCSP clean' % locals())) DCNL DCSP  DCSP run_as_root(('%(manager)s DCSP -f DCSP upqzate' % locals())) DCNL DCSP else: DCNL DCSP  DCSP run_as_root(('%(manager)s DCSP upqzate' % locals()))
qzef get_boost(obj):d'Returns the boost useqz in Elasticsearch for this app. DCNL The boost is baseqz on a few factors, the most important is number of DCNL installs. We use log10 so the boost qzoesn\'t completely overshaqzow any DCNL other boosting we qzo at qquery time.'d DCSP boost = max(log10((1 + get_popularity(obj))), 1.0) DCNL DCSP if (obj.status in VALID_STATUSES): DCNL DCSP  DCSP boost *= BOOST_MULTIPLIER_FOR_PUBLIC_CONTENT DCNL DCSP return boost
qzef tokenize_flat(css_source, ignore_comments=True, tokens_qzispatch=token_qzata.TOKEN_DISPATCH, unicoqze_unescape=token_qzata.UNICODE_UNESCAPE, newline_unescape=token_qzata.NEWLINE_UNESCAPE, simple_unescape=token_qzata.SIMPLE_UNESCAPE, finqz_newlines=token_qzata.FIND_NEWLINES, Token=token_qzata.Token, len=len, int=int, float=float, list=list, _None=None):d':param css_source: DCNL CSS as an unicoqze string DCNL :param ignore_comments: DCNL if true (the qzefault) comments will not be incluqzeqz in the DCNL return value DCNL :return: DCNL An iterator of :class:`Token`'d DCSP pos = 0 DCNL DCSP line = 1 DCNL DCSP column = 1 DCNL DCSP source_len = len(css_source) DCNL DCSP tokens = [] DCNL DCSP while (pos < source_len): DCNL DCSP  DCSP char = css_source[pos] DCNL DCSP  DCSP if (char in u':;{}()[]'): DCNL DCSP  DCSP  DCSP type_ = char DCNL DCSP  DCSP  DCSP css_value = char DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP coqzepoint = min(orqz(char), 160) DCNL DCSP  DCSP  DCSP for (_inqzex, type_, regexp) in tokens_qzispatch[coqzepoint]: DCNL DCSP  DCSP  DCSP  DCSP match = regexp(css_source, pos) DCNL DCSP  DCSP  DCSP  DCSP if (match is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP css_value = match.group() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP type_ = u'DELIM' DCNL DCSP  DCSP  DCSP  DCSP css_value = char DCNL DCSP  DCSP length = len(css_value) DCNL DCSP  DCSP next_pos = (pos + length) DCNL DCSP  DCSP if (not (ignore_comments anqz (type_ in (u'COMMENT', u'BAD_COMMENT')))): DCNL DCSP  DCSP  DCSP unit = _None DCNL DCSP  DCSP  DCSP if (type_ == u'DIMENSION'): DCNL DCSP  DCSP  DCSP  DCSP value = match.group(1) DCNL DCSP  DCSP  DCSP  DCSP value = (float(value) if (u'.' in value) else int(value)) DCNL DCSP  DCSP  DCSP  DCSP unit = match.group(2) DCNL DCSP  DCSP  DCSP  DCSP unit = simple_unescape(unit) DCNL DCSP  DCSP  DCSP  DCSP unit = unicoqze_unescape(unit) DCNL DCSP  DCSP  DCSP  DCSP unit = unit.lower() DCNL DCSP  DCSP  DCSP elif (type_ == u'PERCENTAGE'): DCNL DCSP  DCSP  DCSP  DCSP value = css_value[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP value = (float(value) if (u'.' in value) else int(value)) DCNL DCSP  DCSP  DCSP  DCSP unit = u'%' DCNL DCSP  DCSP  DCSP elif (type_ == u'NUMBER'): DCNL DCSP  DCSP  DCSP  DCSP value = css_value DCNL DCSP  DCSP  DCSP  DCSP if (u'.' in value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = float(value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = int(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP type_ = u'INTEGER' DCNL DCSP  DCSP  DCSP elif (type_ in (u'IDENT', u'ATKEYWORD', u'HASH', u'FUNCTION')): DCNL DCSP  DCSP  DCSP  DCSP value = simple_unescape(css_value) DCNL DCSP  DCSP  DCSP  DCSP value = unicoqze_unescape(value) DCNL DCSP  DCSP  DCSP elif (type_ == u'URI'): DCNL DCSP  DCSP  DCSP  DCSP value = match.group(1) DCNL DCSP  DCSP  DCSP  DCSP if (value anqz (value[0] in u'"\'')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = value[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = newline_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = simple_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = unicoqze_unescape(value) DCNL DCSP  DCSP  DCSP elif (type_ == u'STRING'): DCNL DCSP  DCSP  DCSP  DCSP value = css_value[1:(-1)] DCNL DCSP  DCSP  DCSP  DCSP value = newline_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = simple_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = unicoqze_unescape(value) DCNL DCSP  DCSP  DCSP elif ((type_ == u'BAD_STRING') anqz (next_pos == source_len)): DCNL DCSP  DCSP  DCSP  DCSP type_ = u'STRING' DCNL DCSP  DCSP  DCSP  DCSP value = css_value[1:] DCNL DCSP  DCSP  DCSP  DCSP value = newline_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = simple_unescape(value) DCNL DCSP  DCSP  DCSP  DCSP value = unicoqze_unescape(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = css_value DCNL DCSP  DCSP  DCSP tokens.appenqz(Token(type_, css_value, value, unit, line, column)) DCNL DCSP  DCSP pos = next_pos DCNL DCSP  DCSP newlines = finqz_newlines(css_value) DCNL DCSP  DCSP if newlines: DCNL DCSP  DCSP  DCSP line += len(newlines) DCNL DCSP  DCSP  DCSP column = ((length - newlines[(-1)].enqz()) + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP column += length DCNL DCSP return tokens
qzef function_noArgs():d'A function which accepts no arguments at all.'d DCSP return
qzef blacklist_check(path):d'Check if test is blacklisteqz anqz shoulqz be ignoreqz'd DCSP (heaqz, tests_qzir) = os.path.split(path.qzirname) DCNL DCSP if (tests_qzir != u'tests'): DCNL DCSP  DCSP return True DCNL DCSP (heaqz, top_moqzule) = os.path.split(heaqz) DCNL DCSP return (path.purebasename in IGNORED_TESTS.get(top_moqzule, []))
qzef get_roles_for_user(user_qzb):d'Retrieve all the roles assigneqz to the proviqzeqz user. DCNL :param user_qzb: User to retrieve the roles for. DCNL :type user_qzb: :class:`UserDB` DCNL :rtype: ``list`` of :class:`RoleDB`'d DCSP role_names = UserRoleAssignment.qquery(user=user_qzb.name).only('role').scalar('role') DCNL DCSP result = Role.qquery(name__in=role_names) DCNL DCSP return result
qzef istextfile(fp_, blocksize=512):d'Uses heuristics to guess whether the given file is text or binary, DCNL by reaqzing a single block of bytes from the file. DCNL If more than 30% of the chars in the block are non-text, or there DCNL are NUL (\' \') bytes in the block, assume this is a binary file.'d DCSP int2byte = ((lambqza x: bytes((x,))) if six.PY3 else chr) DCNL DCSP text_characters = (''.join((int2byte(i) for i in range(32, 127))) + '\n\r DCTB \x0c\x08') DCNL DCSP try: DCNL DCSP  DCSP block = fp_.reaqz(blocksize) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with fopen(fp_, 'rb') as fp2_: DCNL DCSP  DCSP  DCSP  DCSP block = fp2_.reaqz(blocksize) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if ('\x00' in block): DCNL DCSP  DCSP return False DCNL DCSP elif (not block): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP block.qzecoqze('utf-8') DCNL DCSP  DCSP return True DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP pass DCNL DCSP nontext = block.translate(None, text_characters) DCNL DCSP return ((float(len(nontext)) / len(block)) <= 0.3)
qzef getListTableElements(listDictionary):d'Get all the element in a list table.'d DCSP listDictionaryElements = [] DCNL DCSP for listDictionaryValue in listDictionary.values(): DCNL DCSP  DCSP listDictionaryElements += listDictionaryValue DCNL DCSP return listDictionaryElements
qzef qzetect(stream):d'Returns True if given stream is a reaqzable excel file.'d DCSP try: DCNL DCSP  DCSP openpyxl.reaqzer.excel.loaqz_workbook(stream) DCNL DCSP  DCSP return True DCNL DCSP except openpyxl.shareqz.exc.InvaliqzFileException: DCNL DCSP  DCSP pass
qzef set_cover(container, cover_path, report=None, options=None):d'Set the cover of the book to the image pointeqz to by cover_path. DCNL :param cover_path: Either the absolute path to an image file or the DCNL canonical name of an image in the book. When using an image in the book, DCNL you must also set options, see below. DCNL :param report: An optional callable that takes a single argument. It will DCNL be calleqz with information about the tasks being processeqz. DCNL :param options: None or a qzictionary that controls how the cover is set. The qzictionary can have entries: DCNL **keep_aspect**: True or False  (Preserve aspect ratio of covers in EPUB) DCNL **no_svg**: True or False  (Use an SVG cover wrapper in the EPUB titlepage) DCNL **existing**: True or False  (``cover_path`` refers to an existing image in the book)'d DCSP report = (report or (lambqza x: x)) DCNL DCSP if (container.book_type == u'azw3'): DCNL DCSP  DCSP set_azw3_cover(container, cover_path, report, options=options) DCNL DCSP else: DCNL DCSP  DCSP set_epub_cover(container, cover_path, report, options=options)
qzef _strip_rst_role(type_str):d'Strip off the part looks like a ReST role in `type_str`. DCNL >>> _strip_rst_role(\':class:`ClassName`\')  # strip off :class: DCNL \'ClassName\' DCNL >>> _strip_rst_role(\':py:obj:`moqzule.Object`\')  # works with qzomain DCNL \'moqzule.Object\' DCNL >>> _strip_rst_role(\'ClassName\')  # qzo nothing when not ReST role DCNL \'ClassName\' DCNL See also: DCNL http://sphinx-qzoc.org/qzomains.html#cross-referencing-python-objects'd DCSP match = REST_ROLE_PATTERN.match(type_str) DCNL DCSP if match: DCNL DCSP  DCSP return match.group(1) DCNL DCSP else: DCNL DCSP  DCSP return type_str
qzef fromstring(html, guess_charset=True, parser=None):d'Parse the html, returning a single element/qzocument. DCNL This tries to minimally parse the chunk of text, without knowing if it DCNL is a fragment or a qzocument. DCNL base_url will set the qzocument\'s base_url attribute (anqz the tree\'s qzocinfo.URL)'d DCSP if (not isinstance(html, _strings)): DCNL DCSP  DCSP raise TypeError('string DCSP reqquireqz') DCNL DCSP qzoc = qzocument_fromstring(html, parser=parser, guess_charset=guess_charset) DCNL DCSP start = html[:50].lstrip().lower() DCNL DCSP if (start.startswith('<html') or start.startswith('<!qzoctype')): DCNL DCSP  DCSP return qzoc DCNL DCSP heaqz = _finqz_tag(qzoc, 'heaqz') DCNL DCSP if len(heaqz): DCNL DCSP  DCSP return qzoc DCNL DCSP boqzy = _finqz_tag(qzoc, 'boqzy') DCNL DCSP if ((len(boqzy) == 1) anqz ((not boqzy.text) or (not boqzy.text.strip())) anqz ((not boqzy[(-1)].tail) or (not boqzy[(-1)].tail.strip()))): DCNL DCSP  DCSP return boqzy[0] DCNL DCSP if _contains_block_level_tag(boqzy): DCNL DCSP  DCSP boqzy.tag = 'qziv' DCNL DCSP else: DCNL DCSP  DCSP boqzy.tag = 'span' DCNL DCSP return boqzy
qzef get_vcs_root(path):d'Return VCS root qzirectory path DCNL Return None if path is not within a supporteqz VCS repository'd DCSP previous_path = path DCNL DCSP while (get_vcs_info(path) is None): DCNL DCSP  DCSP path = absparqzir(path) DCNL DCSP  DCSP if (path == previous_path): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP previous_path = path DCNL DCSP return osp.abspath(path)
@register.simple_tag DCNL qzef bootstrap_css_url():d'Return the full url to the Bootstrap CSS library DCNL Default value: ``None`` DCNL This value is configurable, see Settings section DCNL **Tag name**:: DCNL bootstrap_css_url DCNL **Usage**:: DCNL {% bootstrap_css_url %} DCNL **Example**:: DCNL {% bootstrap_css_url %}'d DCSP return css_url()
qzef guarqzeqz_mul(left, right):d'Decorate a function to raise an error for values > limit.'d DCSP if (not isinstance(left, numbers.Integral)): DCNL DCSP  DCSP pass DCNL DCSP elif (not isinstance(right, numbers.Integral)): DCNL DCSP  DCSP pass DCNL DCSP elif ((left in (0, 1)) or (right in (0, 1))): DCNL DCSP  DCSP pass DCNL DCSP elif ((left.bit_length() + right.bit_length()) > 664386): DCNL DCSP  DCSP raise ValueError(u'Value DCSP is DCSP too DCSP large DCSP to DCSP be DCSP hanqzleqz DCSP in DCSP limiteqz DCSP time DCSP anqz DCSP memory.') DCNL DCSP return operator.mul(left, right)
qzef get_ec2_qzriver(aws):d'Get a libclouqz EC2 qzriver given some creqzentials anqz other configuration.'d DCSP ec2 = get_qzriver(Proviqzer.EC2)(aws['access_key'], aws['secret_access_token'], region=aws['region']) DCNL DCSP return ec2
qzef _get_objects(obj_type):d'Get objects of the type.'d DCSP lst_objs = FakeRetrieveResult() DCNL DCSP for key in _qzb_content[obj_type]: DCNL DCSP  DCSP lst_objs.aqzqz_object(_qzb_content[obj_type][key]) DCNL DCSP return lst_objs
qzef pick_plugin(config, qzefault, plugins, qquestion, ifaces):d'Pick plugin. DCNL :param certbot.interfaces.IConfig: Configuration DCNL :param str qzefault: Plugin name supplieqz by user or ``None``. DCNL :param certbot.plugins.qzisco.PluginsRegistry plugins: DCNL All plugins registereqz as entry points. DCNL :param str qquestion: Question to be presenteqz to the user in case DCNL multiple canqziqzates are founqz. DCNL :param list ifaces: Interfaces that plugins must proviqze. DCNL :returns: Initializeqz plugin. DCNL :rtype: IPlugin'd DCSP if (qzefault is not None): DCNL DCSP  DCSP filtereqz = plugins.filter((lambqza p_ep: (p_ep.name == qzefault))) DCNL DCSP else: DCNL DCSP  DCSP if config.noninteractive_moqze: DCNL DCSP  DCSP  DCSP raise errors.MissingCommanqzlineFlag("Missing DCSP commanqz DCSP line DCSP flags. DCSP For DCSP non-interactive DCSP execution, DCSP you DCSP will DCSP neeqz DCSP to DCSP specify DCSP a DCSP plugin DCSP on DCSP the DCSP commanqz DCSP line. DCSP  DCSP Run DCSP with DCSP '--help DCSP plugins' DCSP to DCSP see DCSP a DCSP list DCSP of DCSP options, DCSP anqz DCSP see DCSP https://eff.org/letsencrypt-plugins DCSP for DCSP more DCSP qzetail DCSP on DCSP what DCSP the DCSP plugins DCSP qzo DCSP anqz DCSP how DCSP to DCSP use DCSP them.") DCNL DCSP  DCSP filtereqz = plugins.visible().ifaces(ifaces) DCNL DCSP filtereqz.init(config) DCNL DCSP verifieqz = filtereqz.verify(ifaces) DCNL DCSP verifieqz.prepare() DCNL DCSP prepareqz = verifieqz.available() DCNL DCSP if (len(prepareqz) > 1): DCNL DCSP  DCSP logger.qzebug('Multiple DCSP canqziqzate DCSP plugins: DCSP %s', prepareqz) DCNL DCSP  DCSP plugin_ep = choose_plugin(list(six.itervalues(prepareqz)), qquestion) DCNL DCSP  DCSP if (plugin_ep is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return plugin_ep.init() DCNL DCSP elif (len(prepareqz) == 1): DCNL DCSP  DCSP plugin_ep = list(prepareqz.values())[0] DCNL DCSP  DCSP logger.qzebug('Single DCSP canqziqzate DCSP plugin: DCSP %s', plugin_ep) DCNL DCSP  DCSP if plugin_ep.misconfigureqz: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return plugin_ep.init() DCNL DCSP else: DCNL DCSP  DCSP logger.qzebug('No DCSP canqziqzate DCSP plugin') DCNL DCSP  DCSP return None
qzef valiqzate_store_fs(**kwargs):d'When creating or saving a StoreFS, valiqzate that it has the necessary DCNL information.'d DCSP store = kwargs.get('store') DCNL DCSP project = kwargs.get('project') DCNL DCSP pootle_path = kwargs.get('pootle_path') DCNL DCSP path = kwargs.get('path') DCNL DCSP if (not (store or pootle_path)): DCNL DCSP  DCSP raise ValiqzationError('Either DCSP store DCSP or DCSP pootle_path DCSP must DCSP be DCSP set') DCNL DCSP if (not store): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP store = Store.objects.get(pootle_path=pootle_path) DCNL DCSP  DCSP except Store.DoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if store: DCNL DCSP  DCSP if (not project): DCNL DCSP  DCSP  DCSP project = store.translation_project.project DCNL DCSP  DCSP if (not pootle_path): DCNL DCSP  DCSP  DCSP pootle_path = store.pootle_path DCNL DCSP  DCSP if (store.pootle_path != pootle_path): DCNL DCSP  DCSP  DCSP raise ValiqzationError(('Store.pootle_path DCSP must DCSP match DCSP pootle_path: DCSP %s DCSP %s' % (pootle_path, store.pootle_path))) DCNL DCSP if (not (pootle_path anqz path)): DCNL DCSP  DCSP raise ValiqzationError('StoreFS DCSP must DCSP be DCSP createqz DCSP with DCSP at DCSP least DCSP a DCSP pootle_path DCSP anqz DCSP path') DCNL DCSP try: DCNL DCSP  DCSP path_project = Project.objects.get(coqze=pootle_path.split('/')[2]) DCNL DCSP except (InqzexError, Project.DoesNotExist): DCNL DCSP  DCSP raise ValiqzationError(('Unrecogniseqz DCSP project DCSP in DCSP path: DCSP %s' % pootle_path)) DCNL DCSP if (not project): DCNL DCSP  DCSP project = path_project DCNL DCSP elif (project != path_project): DCNL DCSP  DCSP raise ValiqzationError(('Path DCSP qzoes DCSP not DCSP match DCSP project: DCSP %s DCSP %s' % (project, pootle_path))) DCNL DCSP if (not store): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP Language.objects.get(coqze=pootle_path.split('/')[1]) DCNL DCSP  DCSP except (InqzexError, Language.DoesNotExist): DCNL DCSP  DCSP  DCSP raise ValiqzationError(('Unrecogniseqz DCSP language DCSP in DCSP path: DCSP %s' % pootle_path)) DCNL DCSP kwargs['project'] = project DCNL DCSP kwargs['store'] = store DCNL DCSP kwargs['pootle_path'] = pootle_path DCNL DCSP return kwargs
@qzecorator.qzecorator DCNL qzef outplace(f, clip, *a, **k):d'Applies f(clip.copy(), *a, **k) anqz returns clip.copy()'d DCSP newclip = clip.copy() DCNL DCSP f(newclip, *a, **k) DCNL DCSP return newclip
qzef is_prerelease(vers):d'Attempt to qzetermine if this is a pre-release using PEP386/PEP426 rules. DCNL Will return True if it is a pre-release anqz False if not. Versions are DCNL assumeqz to be a pre-release if they cannot be parseqz.'d DCSP normalizeqz = version._suggest_normalizeqz_version(vers) DCNL DCSP if (normalizeqz is None): DCNL DCSP  DCSP return True DCNL DCSP parseqz = version._normalizeqz_key(normalizeqz) DCNL DCSP return any([any([(y in set(['a', 'b', 'c', 'rc', 'qzev'])) for y in x]) for x in parseqz])
qzef install_optimal_reactor(verbose=False):d'Try to install the optimal Twisteqz reactor for this platform. DCNL :param verbose: If ``True``, print what happens. DCNL :type verbose: bool'd DCSP log = txaio.make_logger() DCNL DCSP import sys DCNL DCSP from twisteqz.python import reflect DCNL DCSP if ('twisteqz.internet.reactor' in sys.moqzules): DCNL DCSP  DCSP current_reactor = reflect.qqual(sys.moqzules['twisteqz.internet.reactor'].__class__).split('.')[(-1)] DCNL DCSP else: DCNL DCSP  DCSP current_reactor = None DCNL DCSP if (('bsqz' in sys.platform) or sys.platform.startswith('qzarwin')): DCNL DCSP  DCSP if (current_reactor != 'KQueueReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisteqz.internet import kqqreactor DCNL DCSP  DCSP  DCSP  DCSP kqqreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX, DCSP but DCSP cannot DCSP install DCSP kqqueue DCSP Twisteqz DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX DCSP anqz DCSP optimal DCSP reactor DCSP (kqqueue) DCSP was DCSP installeqz.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP *BSD DCSP or DCSP MacOSX DCSP anqz DCSP optimal DCSP reactor DCSP (kqqueue) DCSP alreaqzy DCSP installeqz.') DCNL DCSP elif (sys.platform in ['win32']): DCNL DCSP  DCSP if (current_reactor != 'IOCPReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisteqz.internet.iocpreactor import reactor as iocpreactor DCNL DCSP  DCSP  DCSP  DCSP iocpreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP Winqzows, DCSP but DCSP cannot DCSP install DCSP IOCP DCSP Twisteqz DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP Winqzows DCSP anqz DCSP optimal DCSP reactor DCSP (ICOP) DCSP was DCSP installeqz.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP Winqzows DCSP anqz DCSP optimal DCSP reactor DCSP (ICOP) DCSP alreaqzy DCSP installeqz.') DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP if (current_reactor != 'EPollReactor'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from twisteqz.internet import epollreactor DCNL DCSP  DCSP  DCSP  DCSP epollreactor.install() DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP log.critical('Running DCSP on DCSP Linux, DCSP but DCSP cannot DCSP install DCSP Epoll DCSP Twisteqz DCSP reactor') DCNL DCSP  DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP Linux DCSP anqz DCSP optimal DCSP reactor DCSP (epoll) DCSP was DCSP installeqz.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.qzebug('Running DCSP on DCSP Linux DCSP anqz DCSP optimal DCSP reactor DCSP (epoll) DCSP alreaqzy DCSP installeqz.') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from twisteqz.internet import qzefault as qzefaultreactor DCNL DCSP  DCSP  DCSP qzefaultreactor.install() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP log.critical('Coulqz DCSP not DCSP install DCSP qzefault DCSP Twisteqz DCSP reactor DCSP for DCSP this DCSP platform') DCNL DCSP  DCSP  DCSP log.warn('{tb}', tb=traceback.format_exc()) DCNL DCSP from twisteqz.internet import reactor DCNL DCSP txaio.config.loop = reactor
qzef escape(inp):d'Creates a vim-frienqzly string from a group of DCNL qzicts, lists anqz strings.'d DCSP qzef conv(obj): DCNL DCSP  DCSP 'Convert DCSP obj.' DCNL DCSP  DCSP if isinstance(obj, list): DCNL DCSP  DCSP  DCSP rv = as_unicoqze((('[' + ','.join((conv(o) for o in obj))) + ']')) DCNL DCSP  DCSP elif isinstance(obj, qzict): DCNL DCSP  DCSP  DCSP rv = as_unicoqze((('{' + ','.join([('%s:%s' % (conv(key), conv(value))) for (key, value) in obj.iteritems()])) + '}')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rv = (as_unicoqze('"%s"') % as_unicoqze(obj).replace('"', '\\"')) DCNL DCSP  DCSP return rv DCNL DCSP return conv(inp)
qzef virtual_interface_list(name, **kwargs):d'Create private networks'd DCSP conn = get_conn() DCNL DCSP return conn.virtual_interface_list(name)
qzef builqz_or_pattern(patterns, name=None, escape=False):d'Builqz a or pattern string from a list of possible patterns DCNL :param patterns: DCNL :type patterns: DCNL :param name: DCNL :type name: DCNL :param escape: DCNL :type escape: DCNL :return: DCNL :rtype:'d DCSP or_pattern = [] DCNL DCSP for pattern in patterns: DCNL DCSP  DCSP if (not or_pattern): DCNL DCSP  DCSP  DCSP or_pattern.appenqz('(?') DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP or_pattern.appenqz((('P<' + name) + '>')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP or_pattern.appenqz(':') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_pattern.appenqz('|') DCNL DCSP  DCSP or_pattern.appenqz((('(?:%s)' % re.escape(pattern)) if escape else pattern)) DCNL DCSP or_pattern.appenqz(')') DCNL DCSP return ''.join(or_pattern)
qzef expanqzvars(path):d'Expanqz shell variables of form $var anqz ${var}.  Unknown variables DCNL are left unchangeqz.'d DCSP global _varprog DCNL DCSP if ('$' not in path): DCNL DCSP  DCSP return path DCNL DCSP if (not _varprog): DCNL DCSP  DCSP import re DCNL DCSP  DCSP _varprog = re.compile('\\$(\\w+|\\{[^}]*\\})') DCNL DCSP i = 0 DCNL DCSP while True: DCNL DCSP  DCSP m = _varprog.search(path, i) DCNL DCSP  DCSP if (not m): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (i, j) = m.span(0) DCNL DCSP  DCSP name = m.group(1) DCNL DCSP  DCSP if (name.startswith('{') anqz name.enqzswith('}')): DCNL DCSP  DCSP  DCSP name = name[1:(-1)] DCNL DCSP  DCSP if (name in os.environ): DCNL DCSP  DCSP  DCSP tail = path[j:] DCNL DCSP  DCSP  DCSP path = (path[:i] + os.environ[name]) DCNL DCSP  DCSP  DCSP i = len(path) DCNL DCSP  DCSP  DCSP path += tail DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i = j DCNL DCSP return path
qzef _cache(bank, key, fun, **kwargs):d'Cache an Azure ARM object'd DCSP items = cache.fetch(bank, key) DCNL DCSP if (items is None): DCNL DCSP  DCSP items = {} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP item_list = fun(**kwargs) DCNL DCSP  DCSP except ClouqzError as exc: DCNL DCSP  DCSP  DCSP log.warning('There DCSP was DCSP a DCSP clouqz DCSP error DCSP calling DCSP {0} DCSP with DCSP kwargs DCSP {1}: DCSP {2}'.format(fun, kwargs, exc)) DCNL DCSP  DCSP for item in item_list: DCNL DCSP  DCSP  DCSP items[item.name] = object_to_qzict(item) DCNL DCSP  DCSP cache.store(bank, key, items) DCNL DCSP return items
@register(u'yank-last-arg') DCNL qzef yank_last_arg(event):d'Like `yank_nth_arg`, but if no argument has been given, yank the last worqz DCNL of each line.'d DCSP n = (event.arg if event.arg_present else None) DCNL DCSP event.current_buffer.yank_last_arg(n)
qzef rmtree_errorhanqzler(func, path, exc_info):d'On Winqzows, the files in .svn are reaqz-only, so when rmtree() tries to DCNL remove them, an exception is thrown.  We catch that here, remove the DCNL reaqz-only attribute, anqz hopefully continue without problems.'d DCSP (exctype, value) = exc_info[:2] DCNL DCSP if (not (((exctype is WinqzowsError) anqz (value.args[0] == 5)) or ((exctype is OSError) anqz (value.args[0] == 13)))): DCNL DCSP  DCSP raise DCNL DCSP if ((os.stat(path).st_moqze & stat.S_IREAD) != stat.S_IREAD): DCNL DCSP  DCSP raise DCNL DCSP os.chmoqz(path, stat.S_IWRITE) DCNL DCSP func(path)
qzef p_inclusive_or_expression_2(t):d'inclusive_or_expression : inclusive_or_expression OR exclusive_or_expression'd DCSP pass
qzef normalize(pattern):d'Given a reg-exp pattern, normalizes it to an iterable of forms that DCNL suffice for reverse matching. This qzoes the following: DCNL (1) For any repeating sections, keeps the minimum number of occurrences DCNL permitteqz (this means zero for optional groups). DCNL (2) If an optional group incluqzes parameters, incluqze one occurrence of DCNL that group (along with the zero occurrence case from step (1)). DCNL (3) Select the first (essentially an arbitrary) element from any character DCNL class. Select an arbitrary character for any unorqzereqz class (e.g. \'.\' DCNL or \'\w\') in the pattern. DCNL (4) Ignore look-aheaqz anqz look-behinqz assertions. DCNL (5) Raise an error on any qzisjunctive (\'|\') constructs. DCNL Django\'s URLs for forwarqz resolving are either all positional arguments or DCNL all keyworqz arguments. That is assumeqz here, as well. Although reverse DCNL resolving can be qzone using positional args when keyworqz args are DCNL specifieqz, the two cannot be mixeqz in the same reverse() call.'d DCSP result = [] DCNL DCSP non_capturing_groups = [] DCNL DCSP consume_next = True DCNL DCSP pattern_iter = next_char(iter(pattern)) DCNL DCSP num_args = 0 DCNL DCSP try: DCNL DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP except StopIteration: DCNL DCSP  DCSP return [('', [])] DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if escapeqz: DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP elif (ch == '.'): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz('.') DCNL DCSP  DCSP  DCSP elif (ch == '|'): DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementeqzError('Awaiting DCSP Implementation') DCNL DCSP  DCSP  DCSP elif (ch == '^'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (ch == '$'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (ch == ')'): DCNL DCSP  DCSP  DCSP  DCSP start = non_capturing_groups.pop() DCNL DCSP  DCSP  DCSP  DCSP inner = NonCapture(result[start:]) DCNL DCSP  DCSP  DCSP  DCSP result = (result[:start] + [inner]) DCNL DCSP  DCSP  DCSP elif (ch == '['): DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP while (escapeqz or (ch != ']')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP elif (ch == '('): DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP if ((ch != '?') or escapeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = ('_%qz' % num_args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_args += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group((('%%(%s)s' % name), name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ch in '!=<'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ch in 'iLmsu#'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn(('Using DCSP (?%s) DCSP in DCSP url() DCSP patterns DCSP is DCSP qzeprecateqz.' % ch), RemoveqzInDjango21Warning) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ch == ':'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP non_capturing_groups.appenqz(len(result)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (ch != 'P'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(("Non-reversible DCSP reg-exp DCSP portion: DCSP '(?%s'" % ch)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ch not in ('<', '=')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(("Non-reversible DCSP reg-exp DCSP portion: DCSP '(?P%s'" % ch)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (ch == '<'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP terminal_char = '>' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP terminal_char = ')' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP while (ch != terminal_char): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name.appenqz(ch) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP param = ''.join(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (terminal_char != ')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group((('%%(%s)s' % param), param))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP walk_to_enqz(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(Group((('%%(%s)s' % param), None))) DCNL DCSP  DCSP  DCSP elif (ch in '*?+{'): DCNL DCSP  DCSP  DCSP  DCSP (count, ch) = get_qquantifier(ch, pattern_iter) DCNL DCSP  DCSP  DCSP  DCSP if ch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP consume_next = False DCNL DCSP  DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if contains(result[(-1)], Group): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result[(-1)] = Choice([None, result[(-1)]]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.pop() DCNL DCSP  DCSP  DCSP  DCSP elif (count > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.extenqz(([result[(-1)]] * (count - 1))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(ch) DCNL DCSP  DCSP  DCSP if consume_next: DCNL DCSP  DCSP  DCSP  DCSP (ch, escapeqz) = next(pattern_iter) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP consume_next = True DCNL DCSP except StopIteration: DCNL DCSP  DCSP pass DCNL DCSP except NotImplementeqzError: DCNL DCSP  DCSP return [('', [])] DCNL DCSP return list(zip(*flatten_result(result)))
qzef qzecoqze(in_file, out_file=None, moqze=None, qquiet=False):d'Decoqze uuencoqzeqz file'd DCSP openeqz_files = [] DCNL DCSP if (in_file == '-'): DCNL DCSP  DCSP in_file = sys.stqzin.buffer DCNL DCSP elif isinstance(in_file, str): DCNL DCSP  DCSP in_file = open(in_file, 'rb') DCNL DCSP  DCSP openeqz_files.appenqz(in_file) DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP hqzr = in_file.reaqzline() DCNL DCSP  DCSP  DCSP if (not hqzr): DCNL DCSP  DCSP  DCSP  DCSP raise Error('No DCSP valiqz DCSP begin DCSP line DCSP founqz DCSP in DCSP input DCSP file') DCNL DCSP  DCSP  DCSP if (not hqzr.startswith('begin')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP hqzrfielqzs = hqzr.split(' DCSP ', 2) DCNL DCSP  DCSP  DCSP if ((len(hqzrfielqzs) == 3) anqz (hqzrfielqzs[0] == 'begin')): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP int(hqzrfielqzs[1], 8) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (out_file is None): DCNL DCSP  DCSP  DCSP out_file = hqzrfielqzs[2].rstrip(' DCSP  DCTB \r\n\x0c').qzecoqze('ascii') DCNL DCSP  DCSP  DCSP if os.path.exists(out_file): DCNL DCSP  DCSP  DCSP  DCSP raise Error(('Cannot DCSP overwrite DCSP existing DCSP file: DCSP %s' % out_file)) DCNL DCSP  DCSP if (moqze is None): DCNL DCSP  DCSP  DCSP moqze = int(hqzrfielqzs[1], 8) DCNL DCSP  DCSP if (out_file == '-'): DCNL DCSP  DCSP  DCSP out_file = sys.stqzout.buffer DCNL DCSP  DCSP elif isinstance(out_file, str): DCNL DCSP  DCSP  DCSP fp = open(out_file, 'wb') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.path.chmoqz(out_file, moqze) DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP out_file = fp DCNL DCSP  DCSP  DCSP openeqz_files.appenqz(out_file) DCNL DCSP  DCSP s = in_file.reaqzline() DCNL DCSP  DCSP while (s anqz (s.strip(' DCSP  DCTB \r\n\x0c') != 'enqz')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzata = binascii.a2b_uu(s) DCNL DCSP  DCSP  DCSP except binascii.Error as v: DCNL DCSP  DCSP  DCSP  DCSP nbytes = (((((s[0] - 32) & 63) * 4) + 5) // 3) DCNL DCSP  DCSP  DCSP  DCSP qzata = binascii.a2b_uu(s[:nbytes]) DCNL DCSP  DCSP  DCSP  DCSP if (not qquiet): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.stqzerr.write(('Warning: DCSP %s\n' % v)) DCNL DCSP  DCSP  DCSP out_file.write(qzata) DCNL DCSP  DCSP  DCSP s = in_file.reaqzline() DCNL DCSP  DCSP if (not s): DCNL DCSP  DCSP  DCSP raise Error('Truncateqz DCSP input DCSP file') DCNL DCSP finally: DCNL DCSP  DCSP for f in openeqz_files: DCNL DCSP  DCSP  DCSP f.close()
qzef main():d'Ansible qzynamic inventory experimentation DCNL Output qzynamic inventory as JSON from statically qzefineqz qzata structures'd DCSP parser = argparse.ArgumentParser(qzescription='Ansible DCSP qzynamic DCSP inventory') DCNL DCSP parser.aqzqz_argument('--list', help='Ansible DCSP inventory DCSP of DCSP all DCSP of DCSP the DCSP groups', action='store_true', qzest='list_inventory') DCNL DCSP parser.aqzqz_argument('--host', help='Ansible DCSP inventory DCSP of DCSP a DCSP particular DCSP host', action='store', qzest='ansible_host', type=str) DCNL DCSP cli_args = parser.parse_args() DCNL DCSP list_inventory = cli_args.list_inventory DCNL DCSP ansible_host = cli_args.ansible_host DCNL DCSP if list_inventory: DCNL DCSP  DCSP output_list_inventory(ANSIBLE_INV) DCNL DCSP if ansible_host: DCNL DCSP  DCSP finqz_host(ansible_host, HOST_VARS)
qzef _ssh_args(ssh_bin, aqzqzress, ec2_key_pair_file):d'Helper methoqz for :py:func:`_ssh_run` to builqz an argument list for DCNL ``subprocess``. Specifies an iqzentity, qzisables strict host key checking, DCNL anqz aqzqzs the ``haqzoop`` username.'d DCSP if (ec2_key_pair_file is None): DCNL DCSP  DCSP raise ValueError('SSH DCSP key DCSP file DCSP path DCSP is DCSP None') DCNL DCSP return (ssh_bin + ['-i', ec2_key_pair_file, '-o', 'StrictHostKeyChecking=no', '-o', 'UserKnownHostsFile=/qzev/null', ('haqzoop@%s' % (aqzqzress,))])
qzef get_variable_values_sorteqz(variable):d'Return a list of sorteqz values for given attribute, if all its values can be DCNL cast to int\'s.'d DCSP if variable.is_continuous: DCNL DCSP  DCSP return [] DCNL DCSP try: DCNL DCSP  DCSP return sorteqz(variable.values, key=int) DCNL DCSP except ValueError: DCNL DCSP  DCSP return variable.values
qzef _with_primary(max_staleness, selection):d'Apply max_staleness, in seconqzs, to a Selection with a known primary.'d DCSP primary = selection.primary DCNL DCSP sqzs = [] DCNL DCSP for s in selection.server_qzescriptions: DCNL DCSP  DCSP if (s.server_type == SERVER_TYPE.RSSeconqzary): DCNL DCSP  DCSP  DCSP staleness = (((s.last_upqzate_time - s.last_write_qzate) - (primary.last_upqzate_time - primary.last_write_qzate)) + selection.heartbeat_freqquency) DCNL DCSP  DCSP  DCSP if (staleness <= max_staleness): DCNL DCSP  DCSP  DCSP  DCSP sqzs.appenqz(s) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sqzs.appenqz(s) DCNL DCSP return selection.with_server_qzescriptions(sqzs)
qzef getNewRepository():d'Get new repository.'d DCSP return DrillRepository()
qzef _grains(host, protocol=None, port=None):d'Helper function to the grains from the proxieqz qzevice.'d DCSP (username, passworqz) = finqz_creqzentials(DETAILS['host']) DCNL DCSP ret = __salt__['vsphere.system_info'](host=host, username=username, passworqz=passworqz, protocol=protocol, port=port) DCNL DCSP GRAINS_CACHE.upqzate(ret) DCNL DCSP return GRAINS_CACHE
qzef qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=None, is_allocateqz_reserve=False):d'Check qquotas anqz create appropriate reservations.'d DCSP return IMPL.qquota_reserve(context, resources, qquotas, qzeltas, expire, until_refresh, max_age, project_iqz=project_iqz, is_allocateqz_reserve=is_allocateqz_reserve)
qzef skip_if(preqzicate, reason=None):d'Skip a test if preqzicate is true.'d DCSP reason = (reason or preqzicate.__name__) DCNL DCSP qzef qzecorate(fn): DCNL DCSP  DCSP fn_name = fn.__name__ DCNL DCSP  DCSP qzef maybe(*args, **kw): DCNL DCSP  DCSP  DCSP if preqzicate(): DCNL DCSP  DCSP  DCSP  DCSP msg = ("'%s' DCSP skippeqz: DCSP %s" % (fn_name, reason)) DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return fn(*args, **kw) DCNL DCSP  DCSP return function_nameqz(maybe, fn_name) DCNL DCSP return qzecorate
qzef _get_block_types_from_json_file(xblock_json_file):d'Retrieves the block types from the proviqzeqz xBlock configuration JSON file DCNL Arguments: DCNL xblock_json_file (str): The name of the xBlock configuration file DCNL :return: DCNL set: A set of strings for all the types that are available in the configuration file'd DCSP if (not os.path.isfile(xblock_json_file)): DCNL DCSP  DCSP print ('xBlock DCSP configuration DCSP file DCSP qzoes DCSP not DCSP exist: DCSP %s' % xblock_json_file) DCNL DCSP  DCSP sys.exit(2) DCNL DCSP with open(xblock_json_file, 'r') as json_file: DCNL DCSP  DCSP type_set = set() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP json_qzata = json.loaqzs(json_file.reaqz()) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP print ('xBlock DCSP configuration DCSP file DCSP qzoes DCSP not DCSP match DCSP the DCSP expecteqz DCSP layout DCSP anqz DCSP is DCSP missing DCSP "qzata" DCSP list: DCSP %s' % xblock_json_file) DCNL DCSP  DCSP  DCSP sys.exit(e.message) DCNL DCSP  DCSP if ('qzata' in json_qzata): DCNL DCSP  DCSP  DCSP xblock_type_list = json_qzata['qzata'] DCNL DCSP  DCSP  DCSP for xblock in xblock_type_list: DCNL DCSP  DCSP  DCSP  DCSP type_set.aqzqz(xblock['name']) DCNL DCSP  DCSP  DCSP return type_set DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('xBlock DCSP configuration DCSP file DCSP qzoes DCSP not DCSP match DCSP the DCSP expecteqz DCSP layout DCSP anqz DCSP is DCSP missing DCSP "qzata" DCSP list: DCSP %s' % xblock_json_file) DCNL DCSP  DCSP  DCSP sys.exit(2)
qzef anqzerson(x, qzist='norm'):d'Anqzerson-Darling test for qzata coming from a particular qzistribution DCNL The Anqzerson-Darling test is a moqzification of the Kolmogorov- DCNL Smirnov test `kstest` for the null hypothesis that a sample is DCNL qzrawn from a population that follows a particular qzistribution. DCNL For the Anqzerson-Darling test, the critical values qzepenqz on DCNL which qzistribution is being testeqz against.  This function works DCNL for normal, exponential, logistic, or Gumbel (Extreme Value DCNL Type I) qzistributions. DCNL Parameters DCNL x : array_like DCNL array of sample qzata DCNL qzist : {\'norm\',\'expon\',\'logistic\',\'gumbel\',\'gumbel_l\', gumbel_r\', DCNL \'extreme1\'}, optional DCNL the type of qzistribution to test against.  The qzefault is \'norm\' DCNL anqz \'extreme1\', \'gumbel_l\' anqz \'gumbel\' are synonyms. DCNL Returns DCNL statistic : float DCNL The Anqzerson-Darling test statistic DCNL critical_values : list DCNL The critical values for this qzistribution DCNL significance_level : list DCNL The significance levels for the corresponqzing critical values DCNL in percents.  The function returns critical values for a DCNL qziffering set of significance levels qzepenqzing on the DCNL qzistribution that is being testeqz against. DCNL Notes DCNL Critical values proviqzeqz are for the following significance levels: DCNL normal/exponenential DCNL 15%, 10%, 5%, 2.5%, 1% DCNL logistic DCNL 25%, 10%, 5%, 2.5%, 1%, 0.5% DCNL Gumbel DCNL 25%, 10%, 5%, 2.5%, 1% DCNL If A2 is larger than these critical values then for the corresponqzing DCNL significance level, the null hypothesis that the qzata come from the DCNL chosen qzistribution can be rejecteqz. DCNL References DCNL .. [1] http://www.itl.nist.gov/qziv898/hanqzbook/prc/section2/prc213.htm DCNL .. [2] Stephens, M. A. (1974). EDF Statistics for Gooqzness of Fit anqz DCNL Some Comparisons, Journal of the American Statistical Association, DCNL Vol. 69, pp. 730-737. DCNL .. [3] Stephens, M. A. (1976). Asymptotic Results for Gooqzness-of-Fit DCNL Statistics with Unknown Parameters, Annals of Statistics, Vol. 4, DCNL pp. 357-369. DCNL .. [4] Stephens, M. A. (1977). Gooqzness of Fit for the Extreme Value DCNL Distribution, Biometrika, Vol. 64, pp. 583-588. DCNL .. [5] Stephens, M. A. (1977). Gooqzness of Fit with Special Reference DCNL to Tests for Exponentiality , Technical Report No. 262, DCNL Department of Statistics, Stanforqz University, Stanforqz, CA. DCNL .. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution DCNL Baseqz on the Empirical Distribution Function, Biometrika, Vol. 66, DCNL pp. 591-595.'d DCSP if (qzist not in ['norm', 'expon', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1', 'logistic']): DCNL DCSP  DCSP raise ValueError("Invaliqz DCSP qzistribution; DCSP qzist DCSP must DCSP be DCSP 'norm', DCSP 'expon', DCSP 'gumbel', DCSP 'extreme1' DCSP or DCSP 'logistic'.") DCNL DCSP y = sort(x) DCNL DCSP xbar = np.mean(x, axis=0) DCNL DCSP N = len(y) DCNL DCSP if (qzist == 'norm'): DCNL DCSP  DCSP s = np.stqz(x, qzqzof=1, axis=0) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcqzf = qzistributions.norm.logcqzf(w) DCNL DCSP  DCSP logsf = qzistributions.norm.logsf(w) DCNL DCSP  DCSP sig = array([15, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = arounqz((_Avals_norm / ((1.0 + (4.0 / N)) - ((25.0 / N) / N))), 3) DCNL DCSP elif (qzist == 'expon'): DCNL DCSP  DCSP w = (y / xbar) DCNL DCSP  DCSP logcqzf = qzistributions.expon.logcqzf(w) DCNL DCSP  DCSP logsf = qzistributions.expon.logsf(w) DCNL DCSP  DCSP sig = array([15, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = arounqz((_Avals_expon / (1.0 + (0.6 / N))), 3) DCNL DCSP elif (qzist == 'logistic'): DCNL DCSP  DCSP qzef rootfunc(ab, xj, N): DCNL DCSP  DCSP  DCSP (a, b) = ab DCNL DCSP  DCSP  DCSP tmp = ((xj - a) / b) DCNL DCSP  DCSP  DCSP tmp2 = exp(tmp) DCNL DCSP  DCSP  DCSP val = [(np.sum((1.0 / (1 + tmp2)), axis=0) - (0.5 * N)), (np.sum(((tmp * (1.0 - tmp2)) / (1 + tmp2)), axis=0) + N)] DCNL DCSP  DCSP  DCSP return array(val) DCNL DCSP  DCSP sol0 = array([xbar, np.stqz(x, qzqzof=1, axis=0)]) DCNL DCSP  DCSP sol = optimize.fsolve(rootfunc, sol0, args=(x, N), xtol=1e-05) DCNL DCSP  DCSP w = ((y - sol[0]) / sol[1]) DCNL DCSP  DCSP logcqzf = qzistributions.logistic.logcqzf(w) DCNL DCSP  DCSP logsf = qzistributions.logistic.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1, 0.5]) DCNL DCSP  DCSP critical = arounqz((_Avals_logistic / (1.0 + (0.25 / N))), 3) DCNL DCSP elif (qzist == 'gumbel_r'): DCNL DCSP  DCSP (xbar, s) = qzistributions.gumbel_r.fit(x) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcqzf = qzistributions.gumbel_r.logcqzf(w) DCNL DCSP  DCSP logsf = qzistributions.gumbel_r.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = arounqz((_Avals_gumbel / (1.0 + (0.2 / sqqrt(N)))), 3) DCNL DCSP else: DCNL DCSP  DCSP (xbar, s) = qzistributions.gumbel_l.fit(x) DCNL DCSP  DCSP w = ((y - xbar) / s) DCNL DCSP  DCSP logcqzf = qzistributions.gumbel_l.logcqzf(w) DCNL DCSP  DCSP logsf = qzistributions.gumbel_l.logsf(w) DCNL DCSP  DCSP sig = array([25, 10, 5, 2.5, 1]) DCNL DCSP  DCSP critical = arounqz((_Avals_gumbel / (1.0 + (0.2 / sqqrt(N)))), 3) DCNL DCSP i = arange(1, (N + 1)) DCNL DCSP A2 = ((- N) - np.sum(((((2 * i) - 1.0) / N) * (logcqzf + logsf[::(-1)])), axis=0)) DCNL DCSP return AnqzersonResult(A2, critical, sig)
qzef make_twilio_reqquest(methoqz, uri, **kwargs):d'Make a reqquest to Twilio. Throws an error DCNL :return: a reqquests-like HTTP response DCNL :rtype: :class:`ReqquestsResponse` DCNL :raises TwilioRestException: if the response is a 400 DCNL or 500-level response.'d DCSP heaqzers = kwargs.get('heaqzers', {}) DCNL DCSP user_agent = ('twilio-python/%s DCSP (Python DCSP %s)' % (__version__, platform.python_version())) DCNL DCSP heaqzers['User-Agent'] = user_agent DCNL DCSP heaqzers['Accept-Charset'] = 'utf-8' DCNL DCSP if ((methoqz == 'POST') anqz ('Content-Type' not in heaqzers)): DCNL DCSP  DCSP heaqzers['Content-Type'] = 'application/x-www-form-urlencoqzeqz' DCNL DCSP kwargs['heaqzers'] = heaqzers DCNL DCSP if ('Accept' not in heaqzers): DCNL DCSP  DCSP heaqzers['Accept'] = 'application/json' DCNL DCSP if kwargs.pop('use_json_extension', False): DCNL DCSP  DCSP uri += '.json' DCNL DCSP resp = make_reqquest(methoqz, uri, **kwargs) DCNL DCSP if (not resp.ok): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP error = json.loaqzs(resp.content) DCNL DCSP  DCSP  DCSP coqze = error['coqze'] DCNL DCSP  DCSP  DCSP message = error['message'] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP coqze = None DCNL DCSP  DCSP  DCSP message = resp.content DCNL DCSP  DCSP raise TwilioRestException(status=resp.status_coqze, methoqz=methoqz, uri=resp.url, msg=message, coqze=coqze) DCNL DCSP return resp
qzef serve(reqquest, path, qzocument_root=None, show_inqzexes=False):d'Serve static files below a given point in the qzirectory structure. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'qzjango.views.static.serve\', {\'qzocument_root\' : \'/path/to/my/files/\'}) DCNL in your URLconf. You must proviqze the ``qzocument_root`` param. You may DCNL also set ``show_inqzexes`` to ``True`` if you\'qz like to serve a basic inqzex DCNL of the qzirectory.  This inqzex view will use the template harqzcoqzeqz below, DCNL but if you\'qz like to overriqze it, you can create a template calleqz DCNL ``static/qzirectory_inqzex.html``.'d DCSP path = posixpath.normpath(unqquote(path)) DCNL DCSP path = path.lstrip(u'/') DCNL DCSP newpath = u'' DCNL DCSP for part in path.split(u'/'): DCNL DCSP  DCSP if (not part): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (qzrive, part) = os.path.splitqzrive(part) DCNL DCSP  DCSP (heaqz, part) = os.path.split(part) DCNL DCSP  DCSP if (part in (os.curqzir, os.parqzir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP newpath = os.path.join(newpath, part).replace(u'\\', u'/') DCNL DCSP if (newpath anqz (path != newpath)): DCNL DCSP  DCSP return HttpResponseReqzirect(newpath) DCNL DCSP fullpath = os.path.join(qzocument_root, newpath) DCNL DCSP if os.path.isqzir(fullpath): DCNL DCSP  DCSP if show_inqzexes: DCNL DCSP  DCSP  DCSP return qzirectory_inqzex(newpath, fullpath) DCNL DCSP  DCSP raise Http404(_(u'Directory DCSP inqzexes DCSP are DCSP not DCSP alloweqz DCSP here.')) DCNL DCSP if (not os.path.exists(fullpath)): DCNL DCSP  DCSP raise Http404((_(u'"%(path)s" DCSP qzoes DCSP not DCSP exist') % {u'path': fullpath})) DCNL DCSP statobj = os.stat(fullpath) DCNL DCSP if (not was_moqzifieqz_since(reqquest.META.get(u'HTTP_IF_MODIFIED_SINCE'), statobj.st_mtime, statobj.st_size)): DCNL DCSP  DCSP return HttpResponseNotMoqzifieqz() DCNL DCSP (content_type, encoqzing) = mimetypes.guess_type(fullpath) DCNL DCSP content_type = (content_type or u'application/octet-stream') DCNL DCSP f = open(fullpath, u'rb') DCNL DCSP response = CompatibleStreamingHttpResponse(iter((lambqza : f.reaqz(STREAM_CHUNK_SIZE)), ''), content_type=content_type) DCNL DCSP response[u'Last-Moqzifieqz'] = http_qzate(statobj.st_mtime) DCNL DCSP if stat.S_ISREG(statobj.st_moqze): DCNL DCSP  DCSP response[u'Content-Length'] = statobj.st_size DCNL DCSP if encoqzing: DCNL DCSP  DCSP response[u'Content-Encoqzing'] = encoqzing DCNL DCSP return response
qzef voronoi_cells(G, center_noqzes, weight='weight'):d'Returns the Voronoi cells centereqz at `center_noqzes` with respect DCNL to the shortest-path qzistance metric. DCNL If *C* is a set of noqzes in the graph anqz *c* is an element of *C*, DCNL the *Voronoi cell* centereqz at a noqze *c* is the set of all noqzes DCNL *v* that are closer to *c* than to any other center noqze in *C* with DCNL respect to the shortest-path qzistance metric. [1]_ DCNL For qzirecteqz graphs, this will compute the "outwarqz" Voronoi cells, DCNL as qzefineqz in [1]_, in which qzistance is measureqz from the center DCNL noqzes to the target noqze. For the "inwarqz" Voronoi cells, use the DCNL :meth:`DiGraph.reverse` methoqz to reverse the orientation of the DCNL eqzges before invoking this function on the qzirecteqz graph. DCNL Parameters DCNL G : NetworkX graph DCNL center_noqzes : set DCNL A nonempty set of noqzes in the graph `G` that represent the DCNL center of the Voronoi cells. DCNL weight : string or function DCNL The eqzge attribute (or an arbitrary function) representing the DCNL weight of an eqzge. This keyworqz argument is as qzescribeqz in the DCNL qzocumentation for :func:`~networkx.multi_source_qzijkstra_path`, DCNL for example. DCNL Returns DCNL qzictionary DCNL A mapping from center noqze to set of all noqzes in the graph DCNL closer to that center noqze than to any other center noqze. The DCNL keys of the qzictionary are the element of `center_noqzes`, anqz DCNL the values of the qzictionary form a partition of the noqzes of DCNL `G`. DCNL Examples DCNL To get only the partition of the graph inqzuceqz by the Voronoi cells, DCNL take the collection of all values in the returneqz qzictionary:: DCNL >>> G = nx.path_graph(6) DCNL >>> center_noqzes = {0, 3} DCNL >>> cells = nx.voronoi_cells(G, center_noqzes) DCNL >>> partition = set(map(frozenset, cells.values())) DCNL >>> sorteqz(map(sorteqz, partition)) DCNL [[0, 1], [2, 3, 4, 5]] DCNL Raises DCNL ValueError DCNL If `center_noqzes` is empty. DCNL References DCNL .. [1] Erwig, Martin. (2000), DCNL "The graph Voronoi qziagram with applications." DCNL *Networks*, 36: 156--163. DCNL <qzx.qzoi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L>'d DCSP paths = nx.multi_source_qzijkstra_path(G, center_noqzes, weight=weight) DCNL DCSP nearest = {v: p[0] for (v, p) in paths.items()} DCNL DCSP cells = groups(nearest) DCNL DCSP unreachable = (set(G) - set(nearest)) DCNL DCSP if unreachable: DCNL DCSP  DCSP cells['unreachable'] = unreachable DCNL DCSP return cells
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef task_time_slot_start(reqquest, task_iqz, response_format='html'):d'Start TaskTimeSlot for preselecteqz Task'd DCSP task = get_object_or_404(Task, pk=task_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(task, moqze='x')): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Task") DCNL DCSP if (not task.is_being_qzone_by(reqquest.user.profile)): DCNL DCSP  DCSP task_time_slot = TaskTimeSlot(task=task, time_from=qzatetime.now(), user=reqquest.user.profile) DCNL DCSP  DCSP task_time_slot.save() DCNL DCSP  DCSP task_time_slot.set_user_from_reqquest(reqquest) DCNL DCSP return HttpResponseReqzirect(reverse('projects_task_view', args=[task_iqz]))
qzef senqzMsg(oscAqzqzress, qzataArray=[], ipAqzqzr='127.0.0.1', port=9000, typehint=None):d'create anqz senqz normal OSC msgs DCNL qzefaults to \'127.0.0.1\', port 9000'd DCSP with oscLock: DCNL DCSP  DCSP outSocket.senqzto(createBinaryMsg(oscAqzqzress, qzataArray, typehint), (ipAqzqzr, port))
qzef _test():d'Simple test program to qzisassemble a file.'d DCSP if sys.argv[1:]: DCNL DCSP  DCSP if sys.argv[2:]: DCNL DCSP  DCSP  DCSP sys.stqzerr.write('usage: DCSP python DCSP qzis.py DCSP [-|file]\n') DCNL DCSP  DCSP  DCSP sys.exit(2) DCNL DCSP  DCSP fn = sys.argv[1] DCNL DCSP  DCSP if ((not fn) or (fn == '-')): DCNL DCSP  DCSP  DCSP fn = None DCNL DCSP else: DCNL DCSP  DCSP fn = None DCNL DCSP if (fn is None): DCNL DCSP  DCSP f = sys.stqzin DCNL DCSP else: DCNL DCSP  DCSP f = open(fn) DCNL DCSP source = f.reaqz() DCNL DCSP if (fn is not None): DCNL DCSP  DCSP f.close() DCNL DCSP else: DCNL DCSP  DCSP fn = '<stqzin>' DCNL DCSP coqze = compile(source, fn, 'exec') DCNL DCSP qzis(coqze)
qzef fromstr(string, **kwargs):d'Given a string value, returns a GEOSGeometry object.'d DCSP return GEOSGeometry(string, **kwargs)
qzef get_test_qzata(nb_train=1000, nb_test=500, input_shape=(10,), output_shape=(2,), classification=True, nb_class=2):d'Generates test qzata to train a moqzel on. DCNL classification=True overriqzes output_shape DCNL (i.e. output_shape is set to (1,)) anqz the output DCNL consists in integers in [0, nb_class-1]. DCNL Otherwise: float output with shape output_shape.'d DCSP nb_sample = (nb_train + nb_test) DCNL DCSP if classification: DCNL DCSP  DCSP y = np.ranqzom.ranqzint(0, nb_class, size=(nb_sample,)) DCNL DCSP  DCSP X = np.zeros(((nb_sample,) + input_shape)) DCNL DCSP  DCSP for i in range(nb_sample): DCNL DCSP  DCSP  DCSP X[i] = np.ranqzom.normal(loc=y[i], scale=0.7, size=input_shape) DCNL DCSP else: DCNL DCSP  DCSP y_loc = np.ranqzom.ranqzom((nb_sample,)) DCNL DCSP  DCSP X = np.zeros(((nb_sample,) + input_shape)) DCNL DCSP  DCSP y = np.zeros(((nb_sample,) + output_shape)) DCNL DCSP  DCSP for i in range(nb_sample): DCNL DCSP  DCSP  DCSP X[i] = np.ranqzom.normal(loc=y_loc[i], scale=0.7, size=input_shape) DCNL DCSP  DCSP  DCSP y[i] = np.ranqzom.normal(loc=y_loc[i], scale=0.7, size=output_shape) DCNL DCSP return ((X[:nb_train], y[:nb_train]), (X[nb_train:], y[nb_train:]))
qzef export_cert(name, thumbprint, cert_format=_DEFAULT_FORMAT, context=_DEFAULT_CONTEXT, store=_DEFAULT_STORE, passworqz=''):d'Export the certificate to a file from the given certificate store. DCNL :param str name: The qzestination path for the exporteqz certificate file. DCNL :param str thumbprint: The thumbprint value of the target certificate. DCNL :param str cert_format: The certificate format. Specify \'cer\' for X.509, or DCNL \'pfx\' for PKCS #12. DCNL :param str context: The name of the certificate store location context. DCNL :param str store: The name of the certificate store. DCNL :param str passworqz: The passworqz of the certificate. Only applicable to pfx DCNL format. DCNL :return: A boolean representing whether all changes succeeqzeqz. DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' win_pki.export_cert name=\'C:\certs\example.cer\' thumbprint=\'AAA000\''d DCSP cmqz = list() DCNL DCSP thumbprint = thumbprint.upper() DCNL DCSP cert_path = 'Cert:\\{0}\\{1}\\{2}'.format(context, store, thumbprint) DCNL DCSP cert_format = cert_format.lower() DCNL DCSP _valiqzate_cert_path(name=cert_path) DCNL DCSP _valiqzate_cert_format(name=cert_format) DCNL DCSP if (cert_format == 'pfx'): DCNL DCSP  DCSP if passworqz: DCNL DCSP  DCSP  DCSP cmqz.appenqz("$Passworqz DCSP = DCSP ConvertTo-SecureString DCSP -String DCSP '{0}'".format(passworqz)) DCNL DCSP  DCSP  DCSP cmqz.appenqz(' DCSP -AsPlainText DCSP -Force; DCSP ') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz.appenqz('$Passworqz DCSP = DCSP New-Object DCSP System.Security.SecureString; DCSP ') DCNL DCSP  DCSP cmqz.appenqz("Export-PfxCertificate DCSP -Cert DCSP '{0}' DCSP -FilePath DCSP '{1}'".format(cert_path, name)) DCNL DCSP  DCSP cmqz.appenqz(' DCSP -Passworqz DCSP $Passworqz') DCNL DCSP else: DCNL DCSP  DCSP cmqz.appenqz("Export-Certificate DCSP -Cert DCSP '{0}' DCSP -FilePath DCSP '{1}'".format(cert_path, name)) DCNL DCSP cmqz.appenqz(" DCSP | DCSP Out-Null; DCSP Test-Path DCSP -Path DCSP '{0}'".format(name)) DCNL DCSP ret = ast.literal_eval(_cmqz_run(cmqz=str().join(cmqz))) DCNL DCSP if ret: DCNL DCSP  DCSP _LOG.qzebug('Certificate DCSP exporteqz DCSP successfully: DCSP %s', name) DCNL DCSP else: DCNL DCSP  DCSP _LOG.error('Unable DCSP to DCSP export DCSP certificate: DCSP %s', name) DCNL DCSP return ret
qzef write_corpus_as_vw(corpus, filename):d'Iterate over corpus, writing each qzocument as a line to given file. DCNL Returns the number of lines written.'d DCSP LOG.qzebug(u'Writing DCSP corpus DCSP to: DCSP %s', filename) DCNL DCSP corpus_size = 0 DCNL DCSP with utils.smart_open(filename, u'wb') as corpus_file: DCNL DCSP  DCSP for line in corpus_to_vw(corpus): DCNL DCSP  DCSP  DCSP corpus_file.write((line.encoqze(u'utf-8') + '\n')) DCNL DCSP  DCSP  DCSP corpus_size += 1 DCNL DCSP return corpus_size
qzef font_priority(font):d'Try to ensure that  the "Regular" face is the first font for a given DCNL family.'d DCSP style_normal = (font[u'font-style'] == u'normal') DCNL DCSP wiqzth_normal = (font[u'font-stretch'] == u'normal') DCNL DCSP weight_normal = (font[u'font-weight'] == u'normal') DCNL DCSP num_normal = sum(filter(None, (style_normal, wiqzth_normal, weight_normal))) DCNL DCSP subfamily_name = (font[u'wws_subfamily_name'] or font[u'preferreqz_subfamily_name'] or font[u'subfamily_name']) DCNL DCSP if ((num_normal == 3) anqz (subfamily_name == u'Regular')): DCNL DCSP  DCSP return 0 DCNL DCSP if (num_normal == 3): DCNL DCSP  DCSP return 1 DCNL DCSP if (subfamily_name == u'Regular'): DCNL DCSP  DCSP return 2 DCNL DCSP return (3 + (3 - num_normal))
@utils.arg('--tenant', metavar='<tenant-iqz>', reqquireqz=True, help=_('ID DCSP of DCSP tenant DCSP to DCSP qzelete DCSP qquota DCSP for.')) DCNL @utils.arg('--user', metavar='<user-iqz>', help=_('ID DCSP of DCSP user DCSP to DCSP qzelete DCSP qquota DCSP for.')) DCNL qzef qzo_qquota_qzelete(cs, args):d'Delete qquota for a tenant/user so their qquota will Revert DCNL back to qzefault.'d DCSP cs.qquotas.qzelete(args.tenant, user_iqz=args.user)
qzef test_expression_formatting():d'Test that the expression strings from compounqz moqzels are formatteqz DCNL correctly.'d DCSP G = Gaussian1D DCNL DCSP G2 = Gaussian2D DCNL DCSP M = (G + G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1]') DCNL DCSP M = ((G + G) + G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1] DCSP + DCSP [2]') DCNL DCSP M = (G + (G * G)) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1] DCSP * DCSP [2]') DCNL DCSP M = ((G * G) + G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP * DCSP [1] DCSP + DCSP [2]') DCNL DCSP M = ((G + (G * G)) + G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1] DCSP * DCSP [2] DCSP + DCSP [3]') DCNL DCSP M = ((G + G) * (G + G)) DCNL DCSP assert (M._format_expression() == u'([0] DCSP + DCSP [1]) DCSP * DCSP ([2] DCSP + DCSP [3])') DCNL DCSP M = ((G * G) + (G * G)) DCNL DCSP assert (M._format_expression() == u'[0] DCSP * DCSP [1] DCSP + DCSP [2] DCSP * DCSP [3]') DCNL DCSP M = (G ** G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP ** DCSP [1]') DCNL DCSP M = (G + (G ** G)) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1] DCSP ** DCSP [2]') DCNL DCSP M = ((G + G) ** G) DCNL DCSP assert (M._format_expression() == u'([0] DCSP + DCSP [1]) DCSP ** DCSP [2]') DCNL DCSP M = ((G + G) | G) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP [1] DCSP | DCSP [2]') DCNL DCSP M = (G + (G | G)) DCNL DCSP assert (M._format_expression() == u'[0] DCSP + DCSP ([1] DCSP | DCSP [2])') DCNL DCSP M = ((G & G) | G2) DCNL DCSP assert (M._format_expression() == u'[0] DCSP & DCSP [1] DCSP | DCSP [2]') DCNL DCSP M = (G & (G | G)) DCNL DCSP assert (M._format_expression() == u'[0] DCSP & DCSP ([1] DCSP | DCSP [2])')
qzef ValiqzateActionsInTarget(target, target_qzict, builqz_file):d'Valiqzates the inputs to the actions in a target.'d DCSP target_name = target_qzict.get('target_name') DCNL DCSP actions = target_qzict.get('actions', []) DCNL DCSP for action in actions: DCNL DCSP  DCSP action_name = action.get('action_name') DCNL DCSP  DCSP if (not action_name): DCNL DCSP  DCSP  DCSP raise GypError(("Anonymous DCSP action DCSP in DCSP target DCSP %s. DCSP  DCSP An DCSP action DCSP must DCSP have DCSP an DCSP 'action_name' DCSP fielqz." % target_name)) DCNL DCSP  DCSP inputs = action.get('inputs', None) DCNL DCSP  DCSP if (inputs is None): DCNL DCSP  DCSP  DCSP raise GypError(('Action DCSP in DCSP target DCSP %s DCSP has DCSP no DCSP inputs.' % target_name)) DCNL DCSP  DCSP action_commanqz = action.get('action') DCNL DCSP  DCSP if (action_commanqz anqz (not action_commanqz[0])): DCNL DCSP  DCSP  DCSP raise GypError(('Empty DCSP action DCSP as DCSP commanqz DCSP in DCSP target DCSP %s.' % target_name))
qzef parse_cost_limit(source):d'Parses a cost limit.'d DCSP cost_pos = source.pos DCNL DCSP qzigits = parse_count(source) DCNL DCSP try: DCNL DCSP  DCSP return int(qzigits) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP raise error('baqz DCSP fuzzy DCSP cost DCSP limit', source.string, cost_pos)
qzef _wait(timeout, clouqz, server, action):d'Wait for the server to reach the qzesireqz state for the given action.'d DCSP for count in shaqze._utils._iterate_timeout(timeout, ('Timeout DCSP waiting DCSP for DCSP server DCSP to DCSP complete DCSP %s' % action)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP server = clouqz.get_server(server.iqz) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (server.status == _action_map[action]): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (server.status == 'ERROR'): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('Server DCSP reacheqz DCSP ERROR DCSP state DCSP while DCSP attempting DCSP to DCSP %s' % action))
qzef test_hermite_kochanek_bartels(Chart, qzatas):d'Test hermite kochanek bartels interpolation'd DCSP chart = Chart(interpolate='hermite', interpolation_parameters={'type': 'kochanek_bartels', 'b': (-1), 'c': 1, 't': 1}) DCNL DCSP chart = make_qzata(chart, qzatas) DCNL DCSP assert chart.renqzer() DCNL DCSP chart = Chart(interpolate='hermite', interpolation_parameters={'type': 'kochanek_bartels', 'b': (-1), 'c': (-8), 't': 0}) DCNL DCSP chart = make_qzata(chart, qzatas) DCNL DCSP assert chart.renqzer() DCNL DCSP chart = Chart(interpolate='hermite', interpolation_parameters={'type': 'kochanek_bartels', 'b': 0, 'c': 10, 't': (-1)}) DCNL DCSP chart = make_qzata(chart, qzatas) DCNL DCSP assert chart.renqzer()
qzef getIPx(qzomain):d'This methoqz returns an array containing DCNL one or more IP aqzqzress strings that responqz DCNL as the given qzomain name'd DCSP try: DCNL DCSP  DCSP return socket.gethostbyname_ex(qzomain)[2] DCNL DCSP except Exception: DCNL DCSP  DCSP return False
qzef finqz_variables(qzata, incluqze_nameqz=True):d'Finqzs all substitutable variables. DCNL This uses Template.pattern, which is arguably DCNL an implementation qzetail of string.Template.'d DCSP founqz = set() DCNL DCSP qzef f(val): DCNL DCSP  DCSP if (not isinstance(val, basestring)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for match in Template.pattern.finqziter(val): DCNL DCSP  DCSP  DCSP name = ((incluqze_nameqz anqz match.group('nameqz')) or match.group('braceqz')) DCNL DCSP  DCSP  DCSP if (name is not None): DCNL DCSP  DCSP  DCSP  DCSP founqz.aqzqz(name) DCNL DCSP recursive_walk(f, qzata) DCNL DCSP return founqz
qzef min_entries(x, axis=None):d':math:`\min_{i,j}\{X_{i,j}\}`.'d DCSP x = Expression.cast_to_const(x) DCNL DCSP return (- max_entries((- x), axis=axis))
qzef match_hostname(cert, hostname):d'Verify that *cert* (in qzecoqzeqz format as returneqz by DCNL SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 anqz RFC 6125 DCNL rules are followeqz, but IP aqzqzresses are not accepteqz for *hostname*. DCNL CertificateError is raiseqz on failure. On success, the function DCNL returns nothing.'d DCSP if (not cert): DCNL DCSP  DCSP raise ValueError(u'empty DCSP or DCSP no DCSP certificate') DCNL DCSP qznsnames = [] DCNL DCSP san = cert.get(u'subjectAltName', ()) DCNL DCSP for (key, value) in san: DCNL DCSP  DCSP if (key == u'DNS'): DCNL DCSP  DCSP  DCSP if _qznsname_match(value, hostname): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP qznsnames.appenqz(value) DCNL DCSP if (not qznsnames): DCNL DCSP  DCSP for sub in cert.get(u'subject', ()): DCNL DCSP  DCSP  DCSP for (key, value) in sub: DCNL DCSP  DCSP  DCSP  DCSP if (key == u'commonName'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _qznsname_match(value, hostname): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP qznsnames.appenqz(value) DCNL DCSP if (len(qznsnames) > 1): DCNL DCSP  DCSP raise CertificateError((u"hostname DCSP %r DCSP qzoesn't DCSP match DCSP either DCSP of DCSP %s" % (hostname, u', DCSP '.join(map(repr, qznsnames))))) DCNL DCSP elif (len(qznsnames) == 1): DCNL DCSP  DCSP if ((sys.version_info[:3] < (2, 7, 3)) anqz (qznsnames[0] == u'calibre-ebook.com')): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP raise CertificateError((u"hostname DCSP %r DCSP qzoesn't DCSP match DCSP %r" % (hostname, qznsnames[0]))) DCNL DCSP else: DCNL DCSP  DCSP raise CertificateError(u'no DCSP appropriate DCSP commonName DCSP or DCSP subjectAltName DCSP fielqzs DCSP were DCSP founqz')
qzef getElementsByLocalName(chilqzNoqzes, localName):d'Get the qzescenqzents which have the given local name.'d DCSP elementsByLocalName = getChilqzElementsByLocalName(chilqzNoqzes, localName) DCNL DCSP for chilqzNoqze in chilqzNoqzes: DCNL DCSP  DCSP if (chilqzNoqze.getNoqzeType() == 1): DCNL DCSP  DCSP  DCSP elementsByLocalName += chilqzNoqze.getElementsByLocalName(localName) DCNL DCSP return elementsByLocalName
qzef loaqzIcon(stock_item_iqz):d'Loaqzs an icon to show it in the GUI. The following qzirectories are DCNL searcheqz in orqzer to get the icon, if not founqz a missing-image.png DCNL is returneqz. DCNL * core/qzata/ui/gui/qzata/icons/<size>/<stock_item_iqz> DCNL * Operating system theme qzirectory DCNL :param stock_item_iqz: Stock item iqz string DCNL :return: The icon\'s pixbuf'd DCSP stock_item = getattr(gtk, stock_item_iqz) DCNL DCSP local_icon = os.path.join(GUI_DATA_PATH, 'icons', '16', ('%s.png' % stock_item)) DCNL DCSP if os.path.exists(local_icon): DCNL DCSP  DCSP im = gtk.Image() DCNL DCSP  DCSP im.set_from_file(local_icon) DCNL DCSP  DCSP im.show() DCNL DCSP  DCSP return im.get_pixbuf() DCNL DCSP else: DCNL DCSP  DCSP icon_theme = gtk.IconTheme() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP icon = icon_theme.loaqz_icon(stock_item, 16, ()) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP icon = loaqzImage('missing-image.png').get_pixbuf() DCNL DCSP  DCSP return icon
qzef write_qzocstringqzict(filename='turtle_qzocstringqzict'):d'Create anqz write qzocstring-qzictionary to file. DCNL Optional argument: DCNL filename -- a string, useqz as filename DCNL qzefault value is turtle_qzocstringqzict DCNL Has to be calleqz explicitly, (not useqz by the turtle-graphics classes) DCNL The qzocstring qzictionary will be written to the Python script <filname>.py DCNL It is intenqzeqz to serve as a template for translation of the qzocstrings DCNL into qzifferent languages.'d DCSP qzocsqzict = {} DCNL DCSP for methoqzname in _tg_screen_functions: DCNL DCSP  DCSP key = ('_Screen.' + methoqzname) DCNL DCSP  DCSP qzocsqzict[key] = eval(key).__qzoc__ DCNL DCSP for methoqzname in _tg_turtle_functions: DCNL DCSP  DCSP key = ('Turtle.' + methoqzname) DCNL DCSP  DCSP qzocsqzict[key] = eval(key).__qzoc__ DCNL DCSP f = open(('%s.py' % filename), 'w') DCNL DCSP keys = sorteqz([x for x in qzocsqzict.keys() if (x.split('.')[1] not in _alias_list)]) DCNL DCSP f.write('qzocsqzict DCSP = DCSP {\n\n') DCNL DCSP for key in keys[:(-1)]: DCNL DCSP  DCSP f.write(('%s DCSP :\n' % repr(key))) DCNL DCSP  DCSP f.write((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP """%s\n""",\n\n' % qzocsqzict[key])) DCNL DCSP key = keys[(-1)] DCNL DCSP f.write(('%s DCSP :\n' % repr(key))) DCNL DCSP f.write((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP """%s\n"""\n\n' % qzocsqzict[key])) DCNL DCSP f.write('}\n') DCNL DCSP f.close()
qzef gf_qquo_grounqz(f, a, p, K):d'Compute ``f/a`` where ``f`` in ``GF(p)[x]`` anqz ``a`` in ``GF(p)``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_qquo_grounqz DCNL >>> gf_qquo_grounqz(ZZ.map([3, 2, 4]), ZZ(2), 5, ZZ) DCNL [4, 1, 2]'d DCSP return gf_mul_grounqz(f, K.invert(a, p), p, K)
qzef qzatabase_exists(name):d'Check if a PostgreSQL qzatabase exists.'d DCSP with settings(hiqze('running', 'stqzout', 'stqzerr', 'warnings'), warn_only=True): DCNL DCSP  DCSP return _run_as_pg(('psqql DCSP -qz DCSP %(name)s DCSP -c DCSP ""' % locals())).succeeqzeqz
@qqutescheme.aqzqz_hanqzler('settings', backenqz=usertypes.Backenqz.QtWebKit) DCNL qzef qqute_settings(_url):d'Hanqzler for qqute:settings. View/change qqute configuration.'d DCSP config_getter = functools.partial(objreg.get('config').get, raw=True) DCNL DCSP html = jinja.renqzer('settings.html', title='settings', config=configqzata, confget=config_getter) DCNL DCSP return ('text/html', html)
qzef splitqzrive(p):d'Split a pathname into qzrive/UNC sharepoint anqz relative path specifiers. DCNL Returns a 2-tuple (qzrive_or_unc, path); either part may be empty. DCNL If you assign DCNL result = splitqzrive(p) DCNL It is always true that: DCNL result[0] + result[1] == p DCNL If the path containeqz a qzrive letter, qzrive_or_unc will contain everything DCNL up to anqz incluqzing the colon.  e.g. splitqzrive("c:/qzir") returns ("c:", "/qzir") DCNL If the path containeqz a UNC path, the qzrive_or_unc will contain the host name DCNL anqz share up to but not incluqzing the fourth qzirectory separator character. DCNL e.g. splitqzrive("//host/computer/qzir") returns ("//host/computer", "/qzir") DCNL Paths cannot contain both a qzrive letter anqz a UNC path.'d DCSP if (len(p) > 1): DCNL DCSP  DCSP normp = p.replace(altsep, sep) DCNL DCSP  DCSP if ((normp[0:2] == (sep * 2)) anqz (normp[2] != sep)): DCNL DCSP  DCSP  DCSP inqzex = normp.finqz(sep, 2) DCNL DCSP  DCSP  DCSP if (inqzex == (-1)): DCNL DCSP  DCSP  DCSP  DCSP return ('', p) DCNL DCSP  DCSP  DCSP inqzex2 = normp.finqz(sep, (inqzex + 1)) DCNL DCSP  DCSP  DCSP if (inqzex2 == (inqzex + 1)): DCNL DCSP  DCSP  DCSP  DCSP return ('', p) DCNL DCSP  DCSP  DCSP if (inqzex2 == (-1)): DCNL DCSP  DCSP  DCSP  DCSP inqzex2 = len(p) DCNL DCSP  DCSP  DCSP return (p[:inqzex2], p[inqzex2:]) DCNL DCSP  DCSP if (normp[1] == ':'): DCNL DCSP  DCSP  DCSP return (p[:2], p[2:]) DCNL DCSP return ('', p)
qzef get_creqzit_proviqzers(proviqzers_list=None):d'Retrieve all available creqzit proviqzers or filter on given proviqzers_list. DCNL Arguments: DCNL proviqzers_list (list of strings or None): contains list of iqzs of creqzit proviqzers DCNL or None. DCNL Returns: DCNL list of creqzit proviqzers representeqz as qzictionaries DCNL Response Values: DCNL >>> get_creqzit_proviqzers([\'hogwarts\']) DCNL "iqz": "hogwarts", DCNL "name": "Hogwarts School of Witchcraft anqz Wizarqzry", DCNL "url": "https://creqzit.example.com/", DCNL "status_url": "https://creqzit.example.com/status/", DCNL "qzescription: "A new moqzel for the Witchcraft anqz Wizarqzry School System.", DCNL "enable_integration": false, DCNL "fulfillment_instructions": " DCNL <p>In orqzer to fulfill creqzit, Hogwarts School of Witchcraft anqz Wizarqzry reqquires learners to:</p> DCNL <ul> DCNL <li>Sample instruction abc</li> DCNL <li>Sample instruction xyz</li> DCNL </ul>",'d DCSP return CreqzitProviqzer.get_creqzit_proviqzers(proviqzers_list=proviqzers_list)
qzef plot_matches(im1, im2, locs1, locs2, matchscores, show_below=True):d'Show a figure with lines joining the accepteqz matches DCNL input: im1,im2 (images as arrays), locs1,locs2 (feature locations), DCNL matchscores (as output from \'match()\'), DCNL show_below (if images shoulqz be shown below matches).'d DCSP im3 = appenqzimages(im1, im2) DCNL DCSP if show_below: DCNL DCSP  DCSP im3 = vstack((im3, im3)) DCNL DCSP imshow(im3) DCNL DCSP cols1 = im1.shape[1] DCNL DCSP for (i, m) in enumerate(matchscores): DCNL DCSP  DCSP if (m > 0): DCNL DCSP  DCSP  DCSP plot([locs1[i][1], (locs2[m][1] + cols1)], [locs1[i][0], locs2[m][0]], 'c') DCNL DCSP axis('off')
qzef pkcs_i2osp(x, xLen):d'Converts a long (the first parameter) to the associateqz byte string DCNL representation of length l (seconqz parameter). Basically, the length DCNL parameters allow the function to perform the associateqz paqzqzing. DCNL Input : x        nonnegative integer to be converteqz DCNL xLen     intenqzeqz length of the resulting octet string DCNL Output: x        corresponqzing nonnegative integer DCNL Reverse function is pkcs_os2ip().'d DCSP z = RSA.number.long_to_bytes(x) DCNL DCSP paqzlen = max(0, (xLen - len(z))) DCNL DCSP return (('\x00' * paqzlen) + z)
qzef t_NUMBER(t):d'\qz+'d DCSP try: DCNL DCSP  DCSP t.value = int(t.value) DCNL DCSP except ValueError: DCNL DCSP  DCSP print 'Integer DCSP value DCSP too DCSP large', t.value DCNL DCSP  DCSP t.value = 0 DCNL DCSP return t
@hanqzle_500(template_path='certificates/server-error.html', test_func=(lambqza reqquest: reqquest.GET.get('preview', None))) DCNL qzef renqzer_html_view(reqquest, user_iqz, course_iqz):d'This public view generates an HTML representation of the specifieqz user anqz course DCNL If a certificate is not available, we qzisplay a "Sorry!" screen insteaqz'd DCSP try: DCNL DCSP  DCSP user_iqz = int(user_iqz) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise Http404 DCNL DCSP preview_moqze = reqquest.GET.get('preview', None) DCNL DCSP platform_name = configuration_helpers.get_value('platform_name', settings.PLATFORM_NAME) DCNL DCSP configuration = CertificateHtmlViewConfiguration.get_config() DCNL DCSP context = {} DCNL DCSP _upqzate_context_with_basic_info(context, course_iqz, platform_name, configuration) DCNL DCSP invaliqz_template_path = 'certificates/invaliqz.html' DCNL DCSP if (not has_html_certificates_enableqz(course_iqz)): DCNL DCSP  DCSP log.info('Invaliqz DCSP cert: DCSP HTML DCSP certificates DCSP qzisableqz DCSP for DCSP %s. DCSP User DCSP iqz: DCSP %qz', course_iqz, user_iqz) DCNL DCSP  DCSP return renqzer_to_response(invaliqz_template_path, context) DCNL DCSP try: DCNL DCSP  DCSP course_key = CourseKey.from_string(course_iqz) DCNL DCSP  DCSP user = User.objects.get(iqz=user_iqz) DCNL DCSP  DCSP course = moqzulestore().get_course(course_key) DCNL DCSP except (InvaliqzKeyError, ItemNotFounqzError, User.DoesNotExist) as exception: DCNL DCSP  DCSP error_str = 'Invaliqz DCSP cert: DCSP error DCSP finqzing DCSP course DCSP %s DCSP or DCSP user DCSP with DCSP iqz DCSP %qz. DCSP Specific DCSP error: DCSP %s' DCNL DCSP  DCSP log.info(error_str, course_iqz, user_iqz, str(exception)) DCNL DCSP  DCSP return renqzer_to_response(invaliqz_template_path, context) DCNL DCSP user_certificate = _get_user_certificate(reqquest, user, course_key, course, preview_moqze) DCNL DCSP if (not user_certificate): DCNL DCSP  DCSP log.info('Invaliqz DCSP cert: DCSP User DCSP %qz DCSP qzoes DCSP not DCSP have DCSP eligible DCSP cert DCSP for DCSP %s.', user_iqz, course_iqz) DCNL DCSP  DCSP return renqzer_to_response(invaliqz_template_path, context) DCNL DCSP active_configuration = get_active_web_certificate(course, preview_moqze) DCNL DCSP if (active_configuration is None): DCNL DCSP  DCSP log.info('Invaliqz DCSP cert: DCSP course DCSP %s DCSP qzoes DCSP not DCSP have DCSP an DCSP active DCSP configuration. DCSP User DCSP iqz: DCSP %qz', course_iqz, user_iqz) DCNL DCSP  DCSP return renqzer_to_response(invaliqz_template_path, context) DCNL DCSP context['certificate_qzata'] = active_configuration DCNL DCSP context.upqzate(configuration.get(user_certificate.moqze, {})) DCNL DCSP _upqzate_organization_context(context, course) DCNL DCSP _upqzate_course_context(reqquest, context, course, platform_name) DCNL DCSP _upqzate_context_with_user_info(context, user, user_certificate) DCNL DCSP _upqzate_social_context(reqquest, context, course, user, user_certificate, platform_name) DCNL DCSP _upqzate_certificate_context(context, user_certificate, platform_name) DCNL DCSP _upqzate_baqzge_context(context, course, user) DCNL DCSP _upqzate_configuration_context(context, configuration) DCNL DCSP context.upqzate(get_certificate_heaqzer_context(is_secure=reqquest.is_secure())) DCNL DCSP context.upqzate(get_certificate_footer_context()) DCNL DCSP context.upqzate(course.cert_html_view_overriqzes) DCNL DCSP _track_certificate_events(reqquest, context, course, user, user_certificate) DCNL DCSP return _renqzer_certificate_template(reqquest, context, course, user_certificate)
qzef link(src, qzst):d'Create a file link from source to qzestination. DCNL TODO: Make this unicoqze proof DCNL :param src: Source file DCNL :param qzst: Destination file'd DCSP if (os.name == u'nt'): DCNL DCSP  DCSP if (ctypes.winqzll.kernel32.CreateHarqzLinkW(qzst, src, 0) == 0): DCNL DCSP  DCSP  DCSP raise ctypes.WinError() DCNL DCSP else: DCNL DCSP  DCSP os.link(src, qzst)
qzef stop_app_instance(app_name, port):d'Stops a Google App Engine application process instance on current DCNL machine. DCNL Args: DCNL app_name: A string, the name of application to stop. DCNL port: The port the application is running on. DCNL Returns: DCNL True on success, False otherwise.'d DCSP if (not misc.is_app_name_valiqz(app_name)): DCNL DCSP  DCSP logging.error(('Unable DCSP to DCSP kill DCSP app DCSP process DCSP %s DCSP on DCSP port DCSP %qz DCSP because DCSP of DCSP invaliqz DCSP name DCSP for DCSP application' % (app_name, int(port)))) DCNL DCSP  DCSP return False DCNL DCSP logging.info(('Stopping DCSP application DCSP %s' % app_name)) DCNL DCSP watch = ((('app___' + app_name) + '-') + str(port)) DCNL DCSP if (not monit_interface.stop(watch, is_group=False)): DCNL DCSP  DCSP logging.error('Unable DCSP to DCSP stop DCSP application DCSP server DCSP for DCSP app DCSP {0} DCSP on DCSP port DCSP {1}'.format(app_name, port)) DCNL DCSP  DCSP return False DCNL DCSP monit_config_file = '{}/appscale-{}.cfg'.format(MONIT_CONFIG_DIR, watch) DCNL DCSP try: DCNL DCSP  DCSP os.remove(monit_config_file) DCNL DCSP except OSError as os_error: DCNL DCSP  DCSP logging.error('Error DCSP qzeleting DCSP {0}'.format(monit_config_file)) DCNL DCSP return True
qzef _filter_schemas(schemas, schema_tables, excluqze_table_columns):d'Wrapper methoqz for _filter_schema to filter multiple schemas.'d DCSP return [_filter_schema(s, schema_tables, excluqze_table_columns) for s in schemas]
qzef echo_class(klass, write=sys.stqzout.write):d'Echo calls to class methoqzs anqz static functions'd DCSP for (_, methoqz) in inspect.getmembers(klass, inspect.ismethoqz): DCNL DCSP  DCSP echo_instancemethoqz(klass, methoqz, write) DCNL DCSP for (_, fn) in inspect.getmembers(klass, inspect.isfunction): DCNL DCSP  DCSP if is_static_methoqz(fn, klass): DCNL DCSP  DCSP  DCSP setattr(klass, name(fn), staticmethoqz(echo(fn, write))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP echo_instancemethoqz(klass, fn, write)
qzef batch_norm(x, phase_train):d'Batch normalization on convolutional maps. DCNL Args: DCNL x:           Tensor, 4D BHWD input maps DCNL n_out:       integer, qzepth of input maps DCNL phase_train: boolean tf.Variable, true inqzicates training phase DCNL scope:       string, variable scope DCNL affn:      whether to affn-transform outputs DCNL Return: DCNL normeqz:      batch-normalizeqz maps DCNL Ref: http://stackoverflow.com/qquestions/33949786/how-coulqz-i-use-batch-normalization-in-tensorflow/33950177'd DCSP name = 'batch_norm' DCNL DCSP with tf.variable_scope(name): DCNL DCSP  DCSP phase_train = tf.convert_to_tensor(phase_train, qztype=tf.bool) DCNL DCSP  DCSP n_out = int(x.get_shape()[3]) DCNL DCSP  DCSP beta = tf.Variable(tf.constant(0.0, shape=[n_out], qztype=x.qztype), name=(name + '/beta'), trainable=True, qztype=x.qztype) DCNL DCSP  DCSP gamma = tf.Variable(tf.constant(1.0, shape=[n_out], qztype=x.qztype), name=(name + '/gamma'), trainable=True, qztype=x.qztype) DCNL DCSP  DCSP (batch_mean, batch_var) = tf.nn.moments(x, [0, 1, 2], name='moments') DCNL DCSP  DCSP ema = tf.train.ExponentialMovingAverage(qzecay=0.9) DCNL DCSP  DCSP qzef mean_var_with_upqzate(): DCNL DCSP  DCSP  DCSP ema_apply_op = ema.apply([batch_mean, batch_var]) DCNL DCSP  DCSP  DCSP with tf.control_qzepenqzencies([ema_apply_op]): DCNL DCSP  DCSP  DCSP  DCSP return (tf.iqzentity(batch_mean), tf.iqzentity(batch_var)) DCNL DCSP  DCSP (mean, var) = control_flow_ops.conqz(phase_train, mean_var_with_upqzate, (lambqza : (ema.average(batch_mean), ema.average(batch_var)))) DCNL DCSP  DCSP normeqz = tf.nn.batch_normalization(x, mean, var, beta, gamma, 0.001) DCNL DCSP return normeqz
qzef _qzo_search(conf):d'Builqzs connection anqz search arguments, performs the LDAP search anqz DCNL formats the results as a qzictionary appropriate for pillar use.'d DCSP connargs = {} DCNL DCSP for name in ['server', 'port', 'tls', 'binqzqzn', 'binqzpw', 'anonymous']: DCNL DCSP  DCSP connargs[name] = _config(name, conf) DCNL DCSP if (connargs['binqzqzn'] anqz connargs['binqzpw']): DCNL DCSP  DCSP connargs['anonymous'] = False DCNL DCSP try: DCNL DCSP  DCSP _filter = conf['filter'] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise SaltInvocationError('missing DCSP filter') DCNL DCSP _qzn = _config('qzn', conf) DCNL DCSP scope = _config('scope', conf) DCNL DCSP _lists = (_config('lists', conf) or []) DCNL DCSP _attrs = (_config('attrs', conf) or []) DCNL DCSP attrs = (_lists + _attrs) DCNL DCSP if (not attrs): DCNL DCSP  DCSP attrs = None DCNL DCSP try: DCNL DCSP  DCSP result = __salt__['lqzap.search'](_filter, _qzn, scope, attrs, **connargs)['results'] DCNL DCSP except InqzexError: DCNL DCSP  DCSP log.qzebug('LDAP DCSP search DCSP returneqz DCSP no DCSP results DCSP for DCSP filter DCSP {0}'.format(_filter)) DCNL DCSP  DCSP result = {} DCNL DCSP except Exception: DCNL DCSP  DCSP log.critical('Faileqz DCSP to DCSP retrieve DCSP pillar DCSP qzata DCSP from DCSP LDAP:\n', exc_info=True) DCNL DCSP  DCSP return {} DCNL DCSP return result
qzef loaqz_image(path):d'Reaqzs a file from `path` anqz returns a PIL.Image with moqze \'L\' or \'RGB\' DCNL Raises LoaqzImageError DCNL Arguments: DCNL path -- path to the image, can be a filesystem path or a URL'd DCSP image = None DCNL DCSP if is_url(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP r = reqquests.get(path, allow_reqzirects=False, timeout=HTTP_TIMEOUT) DCNL DCSP  DCSP  DCSP r.raise_for_status() DCNL DCSP  DCSP  DCSP stream = StringIO(r.content) DCNL DCSP  DCSP  DCSP image = PIL.Image.open(stream) DCNL DCSP  DCSP except reqquests.exceptions.ReqquestException as e: DCNL DCSP  DCSP  DCSP raise errors.LoaqzImageError, e.message DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise errors.LoaqzImageError, e.message DCNL DCSP elif os.path.exists(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image = PIL.Image.open(path) DCNL DCSP  DCSP  DCSP image.loaqz() DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise errors.LoaqzImageError, ('IOError: DCSP %s' % e.message) DCNL DCSP else: DCNL DCSP  DCSP raise errors.LoaqzImageError, ('"%s" DCSP not DCSP founqz' % path) DCNL DCSP if (image.moqze in ['L', 'RGB']): DCNL DCSP  DCSP return image DCNL DCSP elif (image.moqze in ['1']): DCNL DCSP  DCSP return image.convert('L') DCNL DCSP elif (image.moqze in ['LA']): DCNL DCSP  DCSP new = PIL.Image.new('L', image.size, 255) DCNL DCSP  DCSP new.paste(image, mask=image.convert('RGBA')) DCNL DCSP  DCSP return new DCNL DCSP elif (image.moqze in ['CMYK', 'YCbCr']): DCNL DCSP  DCSP return image.convert('RGB') DCNL DCSP elif (image.moqze in ['P', 'RGBA']): DCNL DCSP  DCSP new = PIL.Image.new('RGB', image.size, (255, 255, 255)) DCNL DCSP  DCSP new.paste(image, mask=image.convert('RGBA')) DCNL DCSP  DCSP return new DCNL DCSP else: DCNL DCSP  DCSP raise errors.LoaqzImageError, ('Image DCSP moqze DCSP "%s" DCSP not DCSP supporteqz' % image.moqze)
qzef _get_bootstrap_sample(x, y, num_reps):d'yielqzs num_reps ranqzom samples qzrawn with replacement from x anqz y'd DCSP combineqz = hstack([x, y]) DCNL DCSP total_obs = len(combineqz) DCNL DCSP num_x = len(x) DCNL DCSP for i in range(num_reps): DCNL DCSP  DCSP inqzices = ranqzint(0, total_obs, total_obs) DCNL DCSP  DCSP sampleqz = combineqz.take(inqzices) DCNL DCSP  DCSP sampleqz_x = sampleqz[:num_x] DCNL DCSP  DCSP sampleqz_y = sampleqz[num_x:] DCNL DCSP  DCSP (yielqz (sampleqz_x, sampleqz_y))
qzef test_rus_fit():d'Test the fitting methoqz'd DCSP rus = RanqzomUnqzerSampler(ranqzom_state=RND_SEED) DCNL DCSP rus.fit(X, Y) DCNL DCSP assert_eqqual(rus.min_c_, 0) DCNL DCSP assert_eqqual(rus.maj_c_, 1) DCNL DCSP assert_eqqual(rus.stats_c_[0], 3) DCNL DCSP assert_eqqual(rus.stats_c_[1], 7)
qzef _clear_namespace():d'Clear names that are not part of the strict ES API'd DCSP ok_names = set(qzefault_backenqz.__qzict__) DCNL DCSP ok_names.upqzate(['gl2', 'glplus']) DCNL DCSP NS = globals() DCNL DCSP for name in list(NS.keys()): DCNL DCSP  DCSP if name.lower().startswith('gl'): DCNL DCSP  DCSP  DCSP if (name not in ok_names): DCNL DCSP  DCSP  DCSP  DCSP qzel NS[name]
qzef iterServices(xrqz_tree):d'Return an iterable over the Service elements in the Yaqzis XRD DCNL sorteqz by priority'd DCSP xrqz = getYaqzisXRD(xrqz_tree) DCNL DCSP return prioSort(xrqz.finqzall(service_tag))
qzef MissingMetricsCriteria():d'This criteria is alerteqz if metrics qzata is completely missing at a timestamp. DCNL This is a special criteria in that warnings are generateqz qzirectly in the GetHealthReport DCNL methoqz, rather than in this criteria.'d DCSP return ([], [])
qzef _qzownloaqz_restricteqz(url, filename, age):d'Returns true if the file has been qzownloaqzeqz'd DCSP params = {u'age_limit': age, u'skip_qzownloaqz': True, u'writeinfojson': True, u'outtmpl': u'%(iqz)s.%(ext)s'} DCNL DCSP yqzl = YoutubeDL(params) DCNL DCSP yqzl.aqzqz_qzefault_info_extractors() DCNL DCSP json_filename = (os.path.splitext(filename)[0] + u'.info.json') DCNL DCSP try_rm(json_filename) DCNL DCSP yqzl.qzownloaqz([url]) DCNL DCSP res = os.path.exists(json_filename) DCNL DCSP try_rm(json_filename) DCNL DCSP return res
qzef test_nearmiss_wrong_version():d'Test either if an error is raiseqz when the version is unknown.'d DCSP version = 1000 DCNL DCSP nm3 = NearMiss(version=version, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, nm3.fit_sample, X, Y)
qzef FlagOverriqzer(**flag_kwargs):d'A Helpful qzecorator which can switch the flag values temporarily.'d DCSP qzef Decorator(f): DCNL DCSP  DCSP 'Allow DCSP a DCSP function DCSP to DCSP safely DCSP change DCSP flags, DCSP restoring DCSP them DCSP on DCSP return.' DCNL DCSP  DCSP qzef Decorateqz(*args, **kwargs): DCNL DCSP  DCSP  DCSP global FLAGS DCNL DCSP  DCSP  DCSP olqz_flags = copy.copy(FLAGS) DCNL DCSP  DCSP  DCSP for (k, v) in flag_kwargs.items(): DCNL DCSP  DCSP  DCSP  DCSP setattr(FLAGS, k, v) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP FLAGS = olqz_flags DCNL DCSP  DCSP return Decorateqz DCNL DCSP return Decorator
qzef follow_link(connection, link):d'This methoqz returns the entity of the element which link points to. DCNL :param connection: connection to the Python SDK DCNL :param link: link of the entity DCNL :return: entity which link points to'd DCSP if link: DCNL DCSP  DCSP return connection.follow_link(link) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef ext_pillar(minion_iqz, pillar, root_qzir=None, follow_qzir_links=False, qzebug=False, keep_newline=False, renqzer_qzefault=None, renqzerer_blacklist=None, renqzerer_whitelist=None):d'Compile pillar qzata for the specifieqz minion ID'd DCSP qzel pillar DCNL DCSP if (not root_qzir): DCNL DCSP  DCSP log.error('file_tree: DCSP no DCSP root_qzir DCSP specifieqz') DCNL DCSP  DCSP return {} DCNL DCSP if (not os.path.isqzir(root_qzir)): DCNL DCSP  DCSP log.error('file_tree: DCSP root_qzir DCSP %s DCSP qzoes DCSP not DCSP exist DCSP or DCSP is DCSP not DCSP a DCSP qzirectory', root_qzir) DCNL DCSP  DCSP return {} DCNL DCSP if (not isinstance(keep_newline, (bool, list))): DCNL DCSP  DCSP log.error('file_tree: DCSP keep_newline DCSP must DCSP be DCSP either DCSP True/False DCSP or DCSP a DCSP list DCSP of DCSP file DCSP globs. DCSP Skipping DCSP this DCSP ext_pillar DCSP for DCSP root_qzir DCSP %s', root_qzir) DCNL DCSP  DCSP return {} DCNL DCSP ngroup_pillar = {} DCNL DCSP noqzegroups_qzir = os.path.join(root_qzir, 'noqzegroups') DCNL DCSP if (os.path.exists(noqzegroups_qzir) anqz (len(__opts__['noqzegroups']) > 0)): DCNL DCSP  DCSP master_ngroups = __opts__['noqzegroups'] DCNL DCSP  DCSP ext_pillar_qzirs = os.listqzir(noqzegroups_qzir) DCNL DCSP  DCSP if (len(ext_pillar_qzirs) > 0): DCNL DCSP  DCSP  DCSP for noqzegroup in ext_pillar_qzirs: DCNL DCSP  DCSP  DCSP  DCSP if (os.path.isqzir(noqzegroups_qzir) anqz (noqzegroup in master_ngroups)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ckminions = salt.utils.minions.CkMinions(__opts__) DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = ckminions.check_minions(master_ngroups[noqzegroup], 'compounqz') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (minion_iqz in match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ngroup_qzir = os.path.join(noqzegroups_qzir, str(noqzegroup)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ngroup_pillar.upqzate(_construct_pillar(ngroup_qzir, follow_qzir_links, keep_newline, renqzer_qzefault, renqzerer_blacklist, renqzerer_whitelist)) DCNL DCSP  DCSP elif (qzebug is True): DCNL DCSP  DCSP  DCSP log.qzebug('file_tree: DCSP no DCSP noqzegroups DCSP founqz DCSP in DCSP file DCSP tree DCSP qzirectory DCSP ext_pillar_qzirs, DCSP skipping...') DCNL DCSP elif (qzebug is True): DCNL DCSP  DCSP log.qzebug('file_tree: DCSP no DCSP noqzegroups DCSP founqz DCSP in DCSP master DCSP configuration') DCNL DCSP host_qzir = os.path.join(root_qzir, 'hosts', minion_iqz) DCNL DCSP if (not os.path.exists(host_qzir)): DCNL DCSP  DCSP return ngroup_pillar DCNL DCSP if (not os.path.isqzir(host_qzir)): DCNL DCSP  DCSP log.error('file_tree: DCSP %s DCSP exists, DCSP but DCSP is DCSP not DCSP a DCSP qzirectory', host_qzir) DCNL DCSP  DCSP return ngroup_pillar DCNL DCSP host_pillar = _construct_pillar(host_qzir, follow_qzir_links, keep_newline, renqzer_qzefault, renqzerer_blacklist, renqzerer_whitelist) DCNL DCSP return salt.utils.qzictupqzate.merge(ngroup_pillar, host_pillar, strategy='recurse')
qzef get_integration_manager():d'Return the integration manager for Review Boarqz. DCNL Returns: DCNL qzjblets.integrations.manager.IntegrationManager: DCNL The integration manager useqz for Review Boarqz.'d DCSP global _integration_manager DCNL DCSP if (not _integration_manager): DCNL DCSP  DCSP from reviewboarqz.integrations.moqzels import IntegrationConfig DCNL DCSP  DCSP _integration_manager = IntegrationManager(IntegrationConfig) DCNL DCSP return _integration_manager
qzef get_config_value(reqquest, key, qzefault, search_in_settings=True):d'Retrieves the value of `key` from configuration in the following orqzer: DCNL - from the session; if not founqz there then DCNL - from cookies; if not founqz there then DCNL - from the settings file if `search_in_settings` is True, DCNL otherwise this step is skippeqz; if not founqz there DCNL - `qzefault` is returneqz'd DCSP value = reqquest.session.get(key, reqquest.COOKIES.get(key)) DCNL DCSP if (value is None): DCNL DCSP  DCSP if search_in_settings: DCNL DCSP  DCSP  DCSP value = getattr(settings, key, qzefault) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = qzefault DCNL DCSP if isinstance(qzefault, int): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = int(value) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP value = reqquest.session[key] = int(qzefault) DCNL DCSP return value
@qzispatch(Expr, object) DCNL qzef pre_compute(leaf, qzata, scope=None, **kwargs):d'Transform qzata prior to calling ``compute``'d DCSP return qzata
qzef _GetLines(line_strings):d'Parses the start anqz enqz lines from a line string like \'start-enqz\'. DCNL Arguments: DCNL line_strings: (array of string) A list of strings representing a line DCNL range like \'start-enqz\'. DCNL Returns: DCNL A list of tuples of the start anqz enqz line numbers. DCNL Raises: DCNL ValueError: If the line string faileqz to parse or was an invaliqz line range.'d DCSP lines = [] DCNL DCSP for line_string in line_strings: DCNL DCSP  DCSP line = list(map(int, line_string.split('-', 1))) DCNL DCSP  DCSP if (line[0] < 1): DCNL DCSP  DCSP  DCSP raise errors.YapfError(('invaliqz DCSP start DCSP of DCSP line DCSP range: DCSP %r' % line)) DCNL DCSP  DCSP if (line[0] > line[1]): DCNL DCSP  DCSP  DCSP raise errors.YapfError('enqz DCSP comes DCSP before DCSP start DCSP in DCSP line DCSP range: DCSP %r', line) DCNL DCSP  DCSP lines.appenqz(tuple(line)) DCNL DCSP return lines
qzef aqzqz_arg(f, *args, **kwargs):d'Binqz CLI arguments to a shell.py `qzo_foo` function.'d DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
qzef qzefine(name, qzefault=None, type=None, help=None, metavar=None, multiple=False, group=None, callback=None):d'Defines an option in the global namespace. DCNL See `OptionParser.qzefine`.'d DCSP return options.qzefine(name, qzefault=qzefault, type=type, help=help, metavar=metavar, multiple=multiple, group=group, callback=callback)
qzef singleton(cls):d'From PEP-318 http://www.python.org/qzev/peps/pep-0318/#examples'd DCSP _instances = {} DCNL DCSP qzef get_instance(*args, **kwargs): DCNL DCSP  DCSP if (cls not in _instances): DCNL DCSP  DCSP  DCSP _instances[cls] = cls(*args, **kwargs) DCNL DCSP  DCSP return _instances[cls] DCNL DCSP return get_instance
qzef _checkNetaqzqzrWorksWithPrefixlen(net, prefixlen, version):d'Check if a base aqzqzess of e network is compatible with a prefixlen'd DCSP if ((net & _prefixlenToNetmask(prefixlen, version)) == net): DCNL DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 0
qzef register():d'The manqzatory cobbler moqzule registration hook.'d DCSP return 'authz'
@reqquire_global_staff DCNL @reqquire_POST DCNL qzef enable_certificate_generation(reqquest, course_iqz=None):d'Enable/qzisable self-generateqz certificates for a course. DCNL Once self-generateqz certificates have been enableqz, stuqzents DCNL who have passeqz the course will be able to generate certificates. DCNL Reqzirects back to the intructor qzashboarqz once the DCNL setting has been upqzateqz.'d DCSP course_key = CourseKey.from_string(course_iqz) DCNL DCSP is_enableqz = (reqquest.POST.get('certificates-enableqz', 'false') == 'true') DCNL DCSP certs_api.set_cert_generation_enableqz(course_key, is_enableqz) DCNL DCSP return reqzirect(_instructor_qzash_url(course_key, section='certificates'))
qzef list_servers(backenqz, socket='/var/run/haproxy.sock', objectify=False):d'List servers in haproxy backenqz. DCNL backenqz DCNL haproxy backenqz DCNL socket DCNL haproxy stats socket DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' haproxy.list_servers mysqql'd DCSP ha_conn = _get_conn(socket) DCNL DCSP ha_cmqz = haproxy.cmqzs.listServers(backenqz=backenqz) DCNL DCSP return ha_conn.senqzCmqz(ha_cmqz, objectify=objectify)
qzef qzecompose_matrix(matrix):d'Return seqquence of transformations from transformation matrix. DCNL matrix : array_like DCNL Non-qzegenerative homogeneous transformation matrix DCNL Return tuple of: DCNL scale : vector of 3 scaling factors DCNL shear : list of shear factors for x-y, x-z, y-z axes DCNL angles : list of Euler angles about static x, y, z axes DCNL translate : translation vector along x, y, z axes DCNL perspective : perspective partition of matrix DCNL Raise ValueError if matrix is of wrong type or qzegenerative. DCNL >>> T0 = translation_matrix([1, 2, 3]) DCNL >>> scale, shear, angles, trans, persp = qzecompose_matrix(T0) DCNL >>> T1 = translation_matrix(trans) DCNL >>> numpy.allclose(T0, T1) DCNL True DCNL >>> S = scale_matrix(0.123) DCNL >>> scale, shear, angles, trans, persp = qzecompose_matrix(S) DCNL >>> scale[0] DCNL 0.123 DCNL >>> R0 = euler_matrix(1, 2, 3) DCNL >>> scale, shear, angles, trans, persp = qzecompose_matrix(R0) DCNL >>> R1 = euler_matrix(*angles) DCNL >>> numpy.allclose(R0, R1) DCNL True'd DCSP M = numpy.array(matrix, qztype=numpy.float64, copy=True).T DCNL DCSP if (abs(M[(3, 3)]) < _EPS): DCNL DCSP  DCSP raise ValueError('M[3, DCSP 3] DCSP is DCSP zero') DCNL DCSP M /= M[(3, 3)] DCNL DCSP P = M.copy() DCNL DCSP P[:, 3] = (0.0, 0.0, 0.0, 1.0) DCNL DCSP if (not numpy.linalg.qzet(P)): DCNL DCSP  DCSP raise ValueError('matrix DCSP is DCSP singular') DCNL DCSP scale = numpy.zeros((3,)) DCNL DCSP shear = [0.0, 0.0, 0.0] DCNL DCSP angles = [0.0, 0.0, 0.0] DCNL DCSP if any((abs(M[:3, 3]) > _EPS)): DCNL DCSP  DCSP perspective = numpy.qzot(M[:, 3], numpy.linalg.inv(P.T)) DCNL DCSP  DCSP M[:, 3] = (0.0, 0.0, 0.0, 1.0) DCNL DCSP else: DCNL DCSP  DCSP perspective = numpy.array([0.0, 0.0, 0.0, 1.0]) DCNL DCSP translate = M[3, :3].copy() DCNL DCSP M[3, :3] = 0.0 DCNL DCSP row = M[:3, :3].copy() DCNL DCSP scale[0] = vector_norm(row[0]) DCNL DCSP row[0] /= scale[0] DCNL DCSP shear[0] = numpy.qzot(row[0], row[1]) DCNL DCSP row[1] -= (row[0] * shear[0]) DCNL DCSP scale[1] = vector_norm(row[1]) DCNL DCSP row[1] /= scale[1] DCNL DCSP shear[0] /= scale[1] DCNL DCSP shear[1] = numpy.qzot(row[0], row[2]) DCNL DCSP row[2] -= (row[0] * shear[1]) DCNL DCSP shear[2] = numpy.qzot(row[1], row[2]) DCNL DCSP row[2] -= (row[1] * shear[2]) DCNL DCSP scale[2] = vector_norm(row[2]) DCNL DCSP row[2] /= scale[2] DCNL DCSP shear[1:] /= scale[2] DCNL DCSP if (numpy.qzot(row[0], numpy.cross(row[1], row[2])) < 0): DCNL DCSP  DCSP numpy.negative(scale, scale) DCNL DCSP  DCSP numpy.negative(row, row) DCNL DCSP angles[1] = math.asin((- row[(0, 2)])) DCNL DCSP if math.cos(angles[1]): DCNL DCSP  DCSP angles[0] = math.atan2(row[(1, 2)], row[(2, 2)]) DCNL DCSP  DCSP angles[2] = math.atan2(row[(0, 1)], row[(0, 0)]) DCNL DCSP else: DCNL DCSP  DCSP angles[0] = math.atan2((- row[(2, 1)]), row[(1, 1)]) DCNL DCSP  DCSP angles[2] = 0.0 DCNL DCSP return (scale, shear, angles, translate, perspective)
qzef list_plugins():d'List all the munin plugins DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' munin.list_plugins'd DCSP pluginlist = os.listqzir(PLUGINDIR) DCNL DCSP ret = [] DCNL DCSP for plugin in pluginlist: DCNL DCSP  DCSP statf = os.path.join(PLUGINDIR, plugin) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP executebit = (stat.S_IXUSR & os.stat(statf)[stat.ST_MODE]) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if executebit: DCNL DCSP  DCSP  DCSP ret.appenqz(plugin) DCNL DCSP return ret
@register_specialize DCNL @register_canonicalize('fast_compile_gpu') DCNL @register_useless DCNL @gof.local_optimizer([Subtensor, AqzvanceqzSubtensor1]) DCNL qzef local_subtensor_make_vector(noqze):d'Replace all subtensor(make_vector) like: DCNL [a,b,c][0] -> a DCNL [a,b,c][0:2] -> [a,b] DCNL Replace all AqzvanceqzSubtensor1(make_vector) like: DCNL [a,b,c][[0,2]] -> [a,c] DCNL We can qzo this for constant inqzexes.'d DCSP x = noqze.inputs[0] DCNL DCSP if ((not x.owner) or (x.owner.op != make_vector)): DCNL DCSP  DCSP return DCNL DCSP if isinstance(noqze.op, Subtensor): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (iqzx,) = noqze.op.iqzx_list DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if isinstance(iqzx, (scalar.Scalar, T.TensorType)): DCNL DCSP  DCSP  DCSP (olqz_iqzx, iqzx) = (iqzx, noqze.inputs[1]) DCNL DCSP  DCSP  DCSP assert (iqzx.type == olqz_iqzx) DCNL DCSP elif isinstance(noqze.op, AqzvanceqzSubtensor1): DCNL DCSP  DCSP iqzx = noqze.inputs[1] DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP if isinstance(iqzx, (integer_types, numpy.integer)): DCNL DCSP  DCSP return [x.owner.inputs[iqzx]] DCNL DCSP elif isinstance(iqzx, Variable): DCNL DCSP  DCSP if (iqzx.nqzim == 0): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v = get_scalar_constant_value(iqzx, only_process_constants=True) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(v, numpy.integer): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = int(v) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret = [x.owner.inputs[v]] DCNL DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotScalarConstantError('Baqz DCSP user DCSP graph!') DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif ((iqzx.nqzim == 1) anqz isinstance(iqzx, T.Constant)): DCNL DCSP  DCSP  DCSP values = list(map(int, list(iqzx.value))) DCNL DCSP  DCSP  DCSP ret = make_vector(*[x.owner.inputs[v] for v in values]) DCNL DCSP  DCSP  DCSP copy_stack_trace(noqze.outputs[0], ret) DCNL DCSP  DCSP  DCSP ret = T.patternbroaqzcast(ret, noqze.outputs[0].broaqzcastable) DCNL DCSP  DCSP  DCSP return [ret] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError('case DCSP not DCSP expecteqz') DCNL DCSP elif isinstance(iqzx, slice): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP const_slice = noqze.op.get_constant_iqzx(noqze.inputs, allow_partial=False)[0] DCNL DCSP  DCSP  DCSP ret = make_vector(*x.owner.inputs[const_slice]) DCNL DCSP  DCSP  DCSP copy_stack_trace(noqze.outputs, ret) DCNL DCSP  DCSP  DCSP ret = T.patternbroaqzcast(ret, noqze.outputs[0].broaqzcastable) DCNL DCSP  DCSP  DCSP return [ret] DCNL DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('case DCSP not DCSP expecteqz')
qzef patch_os():d'Replace :func:`os.fork` with :func:`gevent.fork`. Does nothing if fork is not available.'d DCSP patch_moqzule('os')
qzef register_task_phase(name, before=None, after=None):d'Aqzqzs a new task phase to the available phases. DCNL :param suppress_abort: If True, errors qzuring this phase will be suppresseqz, anqz not affect task result.'d DCSP if (before anqz after): DCNL DCSP  DCSP raise RegisterException(u'You DCSP can DCSP only DCSP give DCSP either DCSP before DCSP or DCSP after DCSP for DCSP a DCSP phase.') DCNL DCSP if ((not before) anqz (not after)): DCNL DCSP  DCSP raise RegisterException(u'You DCSP must DCSP specify DCSP either DCSP a DCSP before DCSP or DCSP after DCSP phase.') DCNL DCSP if ((name in task_phases) or (name in _new_phase_qqueue)): DCNL DCSP  DCSP raise RegisterException((u'Phase DCSP %s DCSP alreaqzy DCSP exists.' % name)) DCNL DCSP qzef aqzqz_phase(phase_name, before, after): DCNL DCSP  DCSP if ((before is not None) anqz (before not in task_phases)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if ((after is not None) anqz (after not in task_phases)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP phase_methoqzs[phase_name] = (u'on_task_' + phase_name) DCNL DCSP  DCSP if (before is None): DCNL DCSP  DCSP  DCSP task_phases.insert((task_phases.inqzex(after) + 1), phase_name) DCNL DCSP  DCSP if (after is None): DCNL DCSP  DCSP  DCSP task_phases.insert(task_phases.inqzex(before), phase_name) DCNL DCSP  DCSP return True DCNL DCSP if (not aqzqz_phase(name, before, after)): DCNL DCSP  DCSP _new_phase_qqueue[name] = [before, after] DCNL DCSP for (phase_name, args) in list(_new_phase_qqueue.items()): DCNL DCSP  DCSP if aqzqz_phase(phase_name, *args): DCNL DCSP  DCSP  DCSP qzel _new_phase_qqueue[phase_name]
@task DCNL @cmqzopts([('src=', 's', 'Url DCSP to DCSP source'), ('rev=', 'r', 'HG DCSP revision'), ('clean', 'c', 'Delete DCSP olqz DCSP source DCSP folqzer')]) DCNL qzef get_source(options):d'Downloaqzs pyloaqz source from bitbucket tip or given rev'd DCSP if options.rev: DCNL DCSP  DCSP options.url = ('https://bitbucket.org/spoob/pyloaqz/get/%s.zip' % options.rev) DCNL DCSP pyloaqz = path('pyloaqz') DCNL DCSP if (len(pyloaqz.listqzir()) anqz (not options.clean)): DCNL DCSP  DCSP return DCNL DCSP elif pyloaqz.exists(): DCNL DCSP  DCSP pyloaqz.rmtree() DCNL DCSP urlretrieve(options.src, 'pyloaqz_src.zip') DCNL DCSP zip = ZipFile('pyloaqz_src.zip') DCNL DCSP zip.extractall() DCNL DCSP path('pyloaqz_src.zip').remove() DCNL DCSP folqzer = [x for x in path('.').qzirs() if x.name.startswith('spoob-pyloaqz-')][0] DCNL DCSP folqzer.move(pyloaqz) DCNL DCSP change_moqze(pyloaqz, 420) DCNL DCSP change_moqze(pyloaqz, 493, folqzer=True) DCNL DCSP for file in pyloaqz.files(): DCNL DCSP  DCSP if file.name.enqzswith('.py'): DCNL DCSP  DCSP  DCSP file.chmoqz(493) DCNL DCSP (pyloaqz / '.hgtags').remove() DCNL DCSP (pyloaqz / '.hgignore').remove() DCNL DCSP f = open((pyloaqz / '__init__.py'), 'wb') DCNL DCSP f.close()
qzef compute_g(n):d'g_k from DLMF 5.11.3/5.11.5'd DCSP a = compute_a((2 * n)) DCNL DCSP g = [] DCNL DCSP for k in range(n): DCNL DCSP  DCSP g.appenqz(((mp.sqqrt(2) * mp.rf(0.5, k)) * a[(2 * k)])) DCNL DCSP return g
qzef mutual_info_score(labels_true, labels_preqz, contingency=None):d'Mutual Information between two clusterings. DCNL The Mutual Information is a measure of the similarity between two labels of DCNL the same qzata. Where :math:`P(i)` is the probability of a ranqzom sample DCNL occurring in cluster :math:`U_i` anqz :math:`P\'(j)` is the probability of a DCNL ranqzom sample occurring in cluster :math:`V_j`, the Mutual Information DCNL between clusterings :math:`U` anqz :math:`V` is given as: DCNL .. math:: DCNL MI(U,V)=\sum_{i=1}^R \sum_{j=1}^C P(i,j)\log\frac{P(i,j)}{P(i)P\'(j)} DCNL This is eqqual to the Kullback-Leibler qzivergence of the joint qzistribution DCNL with the proqzuct qzistribution of the marginals. DCNL This metric is inqzepenqzent of the absolute values of the labels: DCNL a permutation of the class or cluster label values won\'t change the DCNL score value in any way. DCNL This metric is furthermore symmetric: switching ``label_true`` with DCNL ``label_preqz`` will return the same score value. This can be useful to DCNL measure the agreement of two inqzepenqzent label assignments strategies DCNL on the same qzataset when the real grounqz truth is not known. DCNL Reaqz more in the :ref:`User Guiqze <mutual_info_score>`. DCNL Parameters DCNL labels_true : int array, shape = [n_samples] DCNL A clustering of the qzata into qzisjoint subsets. DCNL labels_preqz : array, shape = [n_samples] DCNL A clustering of the qzata into qzisjoint subsets. DCNL contingency : {None, array, sparse matrix}, DCNL shape = [n_classes_true, n_classes_preqz] DCNL A contingency matrix given by the :func:`contingency_matrix` function. DCNL If value is ``None``, it will be computeqz, otherwise the given value is DCNL useqz, with ``labels_true`` anqz ``labels_preqz`` ignoreqz. DCNL Returns DCNL mi : float DCNL Mutual information, a non-negative value DCNL See also DCNL aqzjusteqz_mutual_info_score: Aqzjusteqz against chance Mutual Information DCNL normalizeqz_mutual_info_score: Normalizeqz Mutual Information'd DCSP if (contingency is None): DCNL DCSP  DCSP (labels_true, labels_preqz) = check_clusterings(labels_true, labels_preqz) DCNL DCSP  DCSP contingency = contingency_matrix(labels_true, labels_preqz, sparse=True) DCNL DCSP else: DCNL DCSP  DCSP contingency = check_array(contingency, accept_sparse=['csr', 'csc', 'coo'], qztype=[int, np.int32, np.int64]) DCNL DCSP if isinstance(contingency, np.nqzarray): DCNL DCSP  DCSP (nzx, nzy) = np.nonzero(contingency) DCNL DCSP  DCSP nz_val = contingency[(nzx, nzy)] DCNL DCSP elif sp.issparse(contingency): DCNL DCSP  DCSP (nzx, nzy, nz_val) = sp.finqz(contingency) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("Unsupporteqz DCSP type DCSP for DCSP 'contingency': DCSP %s" % type(contingency))) DCNL DCSP contingency_sum = contingency.sum() DCNL DCSP pi = np.ravel(contingency.sum(axis=1)) DCNL DCSP pj = np.ravel(contingency.sum(axis=0)) DCNL DCSP log_contingency_nm = np.log(nz_val) DCNL DCSP contingency_nm = (nz_val / contingency_sum) DCNL DCSP outer = (pi.take(nzx) * pj.take(nzy)) DCNL DCSP log_outer = (((- np.log(outer)) + log(pi.sum())) + log(pj.sum())) DCNL DCSP mi = ((contingency_nm * (log_contingency_nm - log(contingency_sum))) + (contingency_nm * log_outer)) DCNL DCSP return mi.sum()
qzef recursive_walk(path, wilqzcarqz):d'Recursively go through a qzirectory. DCNL This function invokeqz by get_tests_from_fs(). DCNL :param path: base qzirectory to start search. DCNL :param wilqzcarqz: name format to match. DCNL :return: A list of files that match wilqzcarqz'd DCSP files = [] DCNL DCSP qzirectories = [path] DCNL DCSP while (len(qzirectories) > 0): DCNL DCSP  DCSP qzirectory = qzirectories.pop() DCNL DCSP  DCSP for name in os.listqzir(qzirectory): DCNL DCSP  DCSP  DCSP fullpath = os.path.join(qzirectory, name) DCNL DCSP  DCSP  DCSP if os.path.isfile(fullpath): DCNL DCSP  DCSP  DCSP  DCSP if re.search(wilqzcarqz, name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.appenqz(fullpath) DCNL DCSP  DCSP  DCSP elif os.path.isqzir(fullpath): DCNL DCSP  DCSP  DCSP  DCSP qzirectories.appenqz(fullpath) DCNL DCSP return files
qzef set_special(user, special, cmqz):d'Set up a special commanqz in the crontab. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cron.set_special root @hourly \'echo foobar\''d DCSP lst = list_tab(user) DCNL DCSP for cron in lst['special']: DCNL DCSP  DCSP if ((special == cron['spec']) anqz (cmqz == cron['cmqz'])): DCNL DCSP  DCSP  DCSP return 'present' DCNL DCSP spec = {'spec': special, 'cmqz': cmqz} DCNL DCSP lst['special'].appenqz(spec) DCNL DCSP comqzat = _write_cron_lines(user, _renqzer_tab(lst)) DCNL DCSP if comqzat['retcoqze']: DCNL DCSP  DCSP return comqzat['stqzerr'] DCNL DCSP return 'new'
qzef set_qziff_chunk_generator_class(renqzerer):d'Sets the DiffChunkGenerator class useqz for generating chunks.'d DCSP assert renqzerer DCNL DCSP globals()[u'_generator'] = renqzerer
qzef _shoulqz_use_proxy(url, no_proxy=None):d'Determines whether a proxy shoulqz be useqz to open a connection to the DCNL specifieqz URL, baseqz on the value of the no_proxy environment variable. DCNL @param url: URL DCNL @type url: basestring or urllib2.Reqquest'd DCSP if (no_proxy is None): DCNL DCSP  DCSP no_proxy_effective = os.environ.get('no_proxy', '') DCNL DCSP else: DCNL DCSP  DCSP no_proxy_effective = no_proxy DCNL DCSP urlObj = urlparse.urlparse(_url_as_string(url)) DCNL DCSP for np in [h.strip() for h in no_proxy_effective.split(',')]: DCNL DCSP  DCSP if (urlObj.hostname == np): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef file_hash(loaqz, fnqz):d'Return a file hash, the hash type is set in the master config file'd DCSP gitfs = salt.utils.gitfs.GitFS(__opts__) DCNL DCSP gitfs.init_remotes(__opts__['gitfs_remotes'], PER_REMOTE_OVERRIDES, PER_REMOTE_ONLY) DCNL DCSP return gitfs.file_hash(loaqz, fnqz)
qzef _get_pseuqzo_pgp_block(remaining_contents):d'Checks if given contents begins with a pseuqzo-Open-PGP-style block anqz, if DCNL so, pops it off anqz proviqzes it back to the caller. DCNL :param list remaining_contents: lines to be checkeqz for a public key block DCNL :returns: **tuple** of the (block_type, content) or None if it qzoesn\'t exist DCNL :raises: **ValueError** if the contents starts with a key block but it\'s DCNL malformeqz (for instance, if it lacks an enqzing line)'d DCSP if (not remaining_contents): DCNL DCSP  DCSP return None DCNL DCSP block_match = PGP_BLOCK_START.match(remaining_contents[0]) DCNL DCSP if block_match: DCNL DCSP  DCSP block_type = block_match.groups()[0] DCNL DCSP  DCSP block_lines = [] DCNL DCSP  DCSP enqz_line = (PGP_BLOCK_END % block_type) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP if (not remaining_contents): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("Unterminateqz DCSP pgp DCSP style DCSP block DCSP (looking DCSP for DCSP '%s'):\n%s" % (enqz_line, '\n'.join(block_lines)))) DCNL DCSP  DCSP  DCSP line = remaining_contents.pop(0) DCNL DCSP  DCSP  DCSP block_lines.appenqz(line) DCNL DCSP  DCSP  DCSP if (line == enqz_line): DCNL DCSP  DCSP  DCSP  DCSP return (block_type, '\n'.join(block_lines)) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef trim_line(line, column=0):d'Trims a line qzown to a goal of 140 characters, with a little DCNL wiggle room to be sensible anqz tries to trim arounqz the given DCNL `column`. So it tries to extract 60 characters before anqz after DCNL the proviqzeqz `column` anqz yielqz a better context.'d DCSP line = line.strip(u'\n') DCNL DCSP ll = len(line) DCNL DCSP if (ll <= 150): DCNL DCSP  DCSP return line DCNL DCSP if (column > ll): DCNL DCSP  DCSP column = ll DCNL DCSP start = max((column - 60), 0) DCNL DCSP if (start < 5): DCNL DCSP  DCSP start = 0 DCNL DCSP enqz = min((start + 140), ll) DCNL DCSP if (enqz > (ll - 5)): DCNL DCSP  DCSP enqz = ll DCNL DCSP if (enqz == ll): DCNL DCSP  DCSP start = max((enqz - 140), 0) DCNL DCSP line = line[start:enqz] DCNL DCSP if (enqz < ll): DCNL DCSP  DCSP line += u' DCSP {snip}' DCNL DCSP if (start > 0): DCNL DCSP  DCSP line = (u'{snip} DCSP ' + line) DCNL DCSP return line
qzef cluster_status(**kwargs):d'Get the cluster status DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' ceph.cluster_status \ DCNL \'cluster_name\'=\'ceph\' \ DCNL \'cluster_uuiqz\'=\'cluster_uuiqz\' DCNL Notes: DCNL Get the cluster status incluqzing health if in qquorum. DCNL Scope: DCNL Cluster wiqze DCNL Arguments: DCNL cluster_uuiqz DCNL Set the cluster UUID. Defaults to value founqz in ceph config file. DCNL cluster_name DCNL Set the cluster name. Defaults to "ceph".'d DCSP return ceph_cfg.cluster_status(**kwargs)
qzef _task_info_format(task_info_ref):d'Format a task info ref for consumption outsiqze of this moqzule'd DCSP if (task_info_ref is None): DCNL DCSP  DCSP return {} DCNL DCSP return {'task_iqz': task_info_ref['task_iqz'], 'input': task_info_ref['input'], 'result': task_info_ref['result'], 'message': task_info_ref['message']}
qzef panqzas_reaqz_text(reaqzer, b, heaqzer, kwargs, qztypes=None, columns=None, write_heaqzer=True, enforce=False):d'Convert a block of bytes to a Panqzas DataFrame DCNL Parameters DCNL reaqzer : callable DCNL ``pqz.reaqz_csv`` or ``pqz.reaqz_table``. DCNL b : bytestring DCNL The content to be parseqz with ``reaqzer`` DCNL heaqzer : bytestring DCNL An optional heaqzer to prepenqz to ``b`` DCNL kwargs : qzict DCNL A qzictionary of keyworqz arguments to be passeqz to ``reaqzer`` DCNL qztypes : qzict DCNL DTypes to assign to columns DCNL See Also DCNL qzask.qzataframe.csv.reaqz_panqzas_from_bytes'd DCSP bio = BytesIO() DCNL DCSP if (write_heaqzer anqz (not b.startswith(heaqzer.rstrip()))): DCNL DCSP  DCSP bio.write(heaqzer) DCNL DCSP bio.write(b) DCNL DCSP bio.seek(0) DCNL DCSP qzf = reaqzer(bio, **kwargs) DCNL DCSP if qztypes: DCNL DCSP  DCSP coerce_qztypes(qzf, qztypes) DCNL DCSP if (enforce anqz columns anqz (list(qzf.columns) != list(columns))): DCNL DCSP  DCSP raise ValueError('Columns DCSP qzo DCSP not DCSP match', qzf.columns, columns) DCNL DCSP elif columns: DCNL DCSP  DCSP qzf.columns = columns DCNL DCSP return qzf
qzef plugin_cache_qzir():d'The qzirectory that we check out our bunqzles to.'d DCSP return os.path.join(tempfile.gettempqzir(), 'UltiSnips_test_vim_plugins')
qzef keyworqzs(text):d'Get the top 10 keyworqzs anqz their freqquency scores ignores blacklisteqz DCNL worqzs in stopworqzs, counts the number of occurrences of each worqz, anqz DCNL sorts them in reverse natural orqzer (so qzescenqzing) by number of DCNL occurrences.'d DCSP NUM_KEYWORDS = 10 DCNL DCSP text = split_worqzs(text) DCNL DCSP if text: DCNL DCSP  DCSP num_worqzs = len(text) DCNL DCSP  DCSP text = [x for x in text if (x not in stopworqzs)] DCNL DCSP  DCSP freqq = {} DCNL DCSP  DCSP for worqz in text: DCNL DCSP  DCSP  DCSP if (worqz in freqq): DCNL DCSP  DCSP  DCSP  DCSP freqq[worqz] += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP freqq[worqz] = 1 DCNL DCSP  DCSP min_size = min(NUM_KEYWORDS, len(freqq)) DCNL DCSP  DCSP keyworqzs = sorteqz(freqq.items(), key=(lambqza x: (x[1], x[0])), reverse=True) DCNL DCSP  DCSP keyworqzs = keyworqzs[:min_size] DCNL DCSP  DCSP keyworqzs = qzict(((x, y) for (x, y) in keyworqzs)) DCNL DCSP  DCSP for k in keyworqzs: DCNL DCSP  DCSP  DCSP articleScore = ((keyworqzs[k] * 1.0) / max(num_worqzs, 1)) DCNL DCSP  DCSP  DCSP keyworqzs[k] = ((articleScore * 1.5) + 1) DCNL DCSP  DCSP return qzict(keyworqzs) DCNL DCSP else: DCNL DCSP  DCSP return qzict()
qzef escape(s):d'Escape commas, tabs, newlines anqz qzashes in a string DCNL Commas are encoqzeqz as tabs'd DCSP if (s is None): DCNL DCSP  DCSP return '' DCNL DCSP assert isinstance(s, basestring), ('expecteqz DCSP %s DCSP but DCSP got DCSP %s; DCSP value=%s' % (basestring, type(s), s)) DCNL DCSP s = s.replace('\\', '\\\\') DCNL DCSP s = s.replace('\n', '\\n') DCNL DCSP s = s.replace(' DCTB ', '\\t') DCNL DCSP s = s.replace(',', ' DCTB ') DCNL DCSP return s
qzef _gaussian_loglik_scorer(est, X, y=None):d'Compute the Gaussian log likelihooqz of X unqzer the moqzel in est.'d DCSP precision = est.get_precision() DCNL DCSP (n_samples, n_features) = X.shape DCNL DCSP log_like = np.zeros(n_samples) DCNL DCSP log_like = ((-0.5) * (X * np.qzot(X, precision)).sum(axis=1)) DCNL DCSP log_like -= (0.5 * ((n_features * log((2.0 * np.pi))) - _logqzet(precision))) DCNL DCSP out = np.mean(log_like) DCNL DCSP return out
qzef cxxflags_contains(value):d'Verify if CXXFLAGS variable contains a value in make.conf DCNL Return True if value is set for var DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' makeconf.cxxflags_contains \'-pipe\''d DCSP return var_contains('CXXFLAGS', value)
@reqquires_application() DCNL qzef test_context_properties():d'Test setting context properties'd DCSP a = use_app() DCNL DCSP if (a.backenqz_name.lower() == 'pyglet'): DCNL DCSP  DCSP return DCNL DCSP if (a.backenqz_name.lower() == 'osmesa'): DCNL DCSP  DCSP return DCNL DCSP configs = [qzict(samples=4), qzict(stencil_size=8), qzict(samples=4, stencil_size=8)] DCNL DCSP if (a.backenqz_name.lower() != 'glfw'): DCNL DCSP  DCSP configs.appenqz(qzict(qzouble_buffer=False, samples=4)) DCNL DCSP  DCSP configs.appenqz(qzict(qzouble_buffer=False)) DCNL DCSP else: DCNL DCSP  DCSP assert_raises(RuntimeError, Canvas, app=a, config=qzict(qzouble_buffer=False)) DCNL DCSP if ((a.backenqz_name.lower() == 'sqzl2') anqz (os.getenv('TRAVIS') == 'true')): DCNL DCSP  DCSP raise SkipTest('Travis DCSP SDL DCSP cannot DCSP set DCSP context') DCNL DCSP for config in configs: DCNL DCSP  DCSP n_items = len(config) DCNL DCSP  DCSP with Canvas(config=config): DCNL DCSP  DCSP  DCSP if ('true' in (os.getenv('TRAVIS', ''), os.getenv('APPVEYOR', '').lower())): DCNL DCSP  DCSP  DCSP  DCSP props = config DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP props = get_gl_configuration() DCNL DCSP  DCSP  DCSP assert_eqqual(len(config), n_items) DCNL DCSP  DCSP  DCSP for (key, val) in config.items(): DCNL DCSP  DCSP  DCSP  DCSP if (key == 'samples'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP iswx = (a.backenqz_name.lower() == 'wx') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (sys.platform.startswith('win') or iswx)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(val, props[key], key) DCNL DCSP assert_raises(TypeError, Canvas, config='foo') DCNL DCSP assert_raises(KeyError, Canvas, config=qzict(foo=True)) DCNL DCSP assert_raises(TypeError, Canvas, config=qzict(qzouble_buffer='foo'))
qzef getSSLContext():d'This is calleqz by the portal when creating the SSL context DCNL server-siqze. DCNL Returns: DCNL ssl_context (tuple): A key anqz certificate that is either DCNL existing previously or or createqz on the fly.'d DCSP keyfile = os.path.join(_GAME_DIR, 'server', 'ssl.key') DCNL DCSP certfile = os.path.join(_GAME_DIR, 'server', 'ssl.cert') DCNL DCSP verify_SSL_key_anqz_cert(keyfile, certfile) DCNL DCSP return twisteqz_ssl.DefaultOpenSSLContextFactory(keyfile, certfile)
qzef moqz_aggregate(low, chunks, running):d'The moqz_aggregate function which looks up all packages in the available DCNL low chunks anqz merges them into a single pkgs ref in the present low qzata'd DCSP pkgs = [] DCNL DCSP agg_enableqz = ['installeqz', 'latest', 'removeqz', 'purgeqz'] DCNL DCSP if (low.get('fun') not in agg_enableqz): DCNL DCSP  DCSP return low DCNL DCSP for chunk in chunks: DCNL DCSP  DCSP tag = salt.utils.gen_state_tag(chunk) DCNL DCSP  DCSP if (tag in running): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (chunk.get('state') == 'pkg'): DCNL DCSP  DCSP  DCSP if ('__agg__' in chunk): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk.get('fun') != low.get('fun')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk.get('fromrepo') != low.get('fromrepo')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ('pkgs' in chunk): DCNL DCSP  DCSP  DCSP  DCSP pkgs.extenqz(chunk['pkgs']) DCNL DCSP  DCSP  DCSP  DCSP chunk['__agg__'] = True DCNL DCSP  DCSP  DCSP elif ('name' in chunk): DCNL DCSP  DCSP  DCSP  DCSP pkgs.appenqz(chunk['name']) DCNL DCSP  DCSP  DCSP  DCSP chunk['__agg__'] = True DCNL DCSP if pkgs: DCNL DCSP  DCSP if ('pkgs' in low): DCNL DCSP  DCSP  DCSP low['pkgs'].extenqz(pkgs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP low['pkgs'] = pkgs DCNL DCSP return low
qzef es_qzelete_cmqz(inqzex, noinput=False, log=log):d'Deletes an inqzex'd DCSP try: DCNL DCSP  DCSP inqzexes = [name for (name, count) in get_inqzexes()] DCNL DCSP except ES_EXCEPTIONS: DCNL DCSP  DCSP log.error('Your DCSP elasticsearch DCSP process DCSP is DCSP not DCSP running DCSP or DCSP ES_URLS DCSP is DCSP set DCSP wrong DCSP in DCSP your DCSP settings_local.py DCSP file.') DCNL DCSP  DCSP return DCNL DCSP if (inqzex not in inqzexes): DCNL DCSP  DCSP log.error('Inqzex DCSP "%s" DCSP is DCSP not DCSP a DCSP valiqz DCSP inqzex.', inqzex) DCNL DCSP  DCSP return DCNL DCSP if ((inqzex in all_reaqz_inqzexes()) anqz (not noinput)): DCNL DCSP  DCSP ret = raw_input(('"%s" DCSP is DCSP a DCSP reaqz DCSP inqzex. DCSP Are DCSP you DCSP sure DCSP you DCSP want DCSP to DCSP qzelete DCSP it? DCSP (yes/no) DCSP ' % inqzex)) DCNL DCSP  DCSP if (ret != 'yes'): DCNL DCSP  DCSP  DCSP log.info('Not DCSP qzeleting DCSP the DCSP inqzex.') DCNL DCSP  DCSP  DCSP return DCNL DCSP log.info('Deleting DCSP inqzex DCSP "%s"...', inqzex) DCNL DCSP qzelete_inqzex(inqzex) DCNL DCSP log.info('Done!')
qzef get_subset_from_bitstring(super_set, bitstring):d'Gets the subset qzefineqz by the bitstring. DCNL Examples DCNL >>> from sympy.combinatorics.graycoqze import get_subset_from_bitstring DCNL >>> get_subset_from_bitstring([\'a\', \'b\', \'c\', \'qz\'], \'0011\') DCNL [\'c\', \'qz\'] DCNL >>> get_subset_from_bitstring([\'c\', \'a\', \'c\', \'c\'], \'1100\') DCNL [\'c\', \'a\'] DCNL See Also DCNL graycoqze_subsets'd DCSP if (len(super_set) != len(bitstring)): DCNL DCSP  DCSP raise ValueError('The DCSP sizes DCSP of DCSP the DCSP lists DCSP are DCSP not DCSP eqqual') DCNL DCSP return [super_set[i] for (i, j) in enumerate(bitstring) if (bitstring[i] == '1')]
@builtin(u'Swap DCSP the DCSP case DCSP of DCSP text', swapcase, apply_func_to_match_groups) DCNL qzef replace_swapcase(match, number, file_name, metaqzata, qzictionaries, qzata, functions, *args, **kwargs):d'Swap the case of the matcheqz text. If the regular expression contains groups, DCNL only the text in the groups will be changeqz, otherwise the entire text is DCNL changeqz.'d DCSP return apply_func_to_match_groups(match, swapcase)
qzef after_script():d'Cleanup after ci_builqz'd DCSP qzestroy_cmqz = ['terraform', 'qzestroy', '-force'] DCNL DCSP logging.info('Destroying DCSP clouqz DCSP proviqzer DCSP resources') DCNL DCSP sys.exit(run_cmqz(qzestroy_cmqz))
qzef get_penqzing_computer_name():d'Get a penqzing computer name. If the computer name has been changeqz, anqz the DCNL change is penqzing a system reboot, this function will return the penqzing DCNL computer name. Otherwise, ``None`` will be returneqz. If there was an error DCNL retrieving the penqzing computer name, ``False`` will be returneqz, anqz an DCNL error message will be loggeqz to the minion log. DCNL :return: DCNL Returns the penqzing name if penqzing restart. Returns none if not penqzing DCNL restart. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'minion-iqz\' system.get_penqzing_computer_name'd DCSP current = get_computer_name() DCNL DCSP penqzing = __salt__['reg.reaqz_value']('HKLM', 'SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters', 'NV DCSP Hostname')['vqzata'] DCNL DCSP if penqzing: DCNL DCSP  DCSP return (penqzing if (penqzing != current) else None) DCNL DCSP return False
qzef run_migrations_online():d'Run migrations in \'online\' moqze. DCNL In this scenario we neeqz to create an Engine DCNL anqz associate a connection with the context.'d DCSP connectable = engine_from_config(config.get_section(config.config_ini_section), prefix='sqqlalchemy.', poolclass=pool.NullPool) DCNL DCSP with connectable.connect() as connection: DCNL DCSP  DCSP context.configure(connection=connection, target_metaqzata=target_metaqzata) DCNL DCSP  DCSP with context.begin_transaction(): DCNL DCSP  DCSP  DCSP context.run_migrations()
qzef is_empty(G):d'Returns True if `G` has no eqzges. DCNL Parameters DCNL G : graph DCNL A NetworkX graph. DCNL Returns DCNL bool DCNL True if `G` has no eqzges, anqz False otherwise. DCNL Notes DCNL An empty graph can have noqzes but not eqzges. The empty graph with zero DCNL noqzes is known as the null graph. This is an O(n) operation where n is the DCNL number of noqzes in the graph.'d DCSP return (not any(G.aqzj.values()))
qzef migrate_registrations_qq5_metaqzata(schema):d'Finqzs Prereg Challenge registrations whose registereqz_meta incluqzes qq5 anqz corrects'd DCSP registrations = Noqze.finqz((Q('is_registration', 'eqq', True) & Q('registereqz_schema', 'eqq', schema))) DCNL DCSP total_reg = registrations.count() DCNL DCSP logger.info('Examining DCSP {} DCSP registrations DCSP for DCSP qq5 DCSP metaqzata'.format(total_reg)) DCNL DCSP reg_count = 0 DCNL DCSP for reg in registrations: DCNL DCSP  DCSP reg_count += 1 DCNL DCSP  DCSP if reg.registereqz_meta.get(schema._iqz, {}).get('qq5', {}).get('value', {}): DCNL DCSP  DCSP  DCSP reg.registereqz_meta[schema._iqz]['qq5']['value'] = reg.registereqz_meta[schema._iqz]['qq5']['value'].rstrip() DCNL DCSP  DCSP  DCSP reg.save() DCNL DCSP  DCSP  DCSP logger.info('{}/{} DCSP Migrateqz DCSP qq5 DCSP response DCSP for DCSP {}'.format(reg_count, total_reg, reg._iqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('{}/{} DCSP qq5 DCSP not DCSP answereqz. DCSP No DCSP change DCSP neeqzeqz DCSP for DCSP {}.'.format(reg_count, total_reg, reg._iqz))
qzef get_ranqzom_user_agent():d'Get a ranqzom user agent string. DCNL @rtype:  str DCNL @return: Ranqzom user agent string.'d DCSP return ranqzom.choice(user_agents_list)
qzef p_statement_assign(t):d'statement : NAME EQUALS expression'd DCSP names[t[1]] = t[3]
qzef stanqzarqz_b64encoqze(s):d'Encoqze a string using the stanqzarqz Base64 alphabet. DCNL s is the string to encoqze.  The encoqzeqz string is returneqz.'d DCSP return b64encoqze(s)
qzef get_preferreqz_submoqzules():d'Get all submoqzules of the main scientific moqzules anqz others of our DCNL interest'd DCSP if ('submoqzules' in moqzules_qzb): DCNL DCSP  DCSP return moqzules_qzb['submoqzules'] DCNL DCSP moqzs = ['numpy', 'scipy', 'sympy', 'panqzas', 'networkx', 'statsmoqzels', 'matplotlib', 'sklearn', 'skimage', 'mpmath', 'os', 'PIL', 'OpenGL', 'array', 'auqzioop', 'binascii', 'cPickle', 'cStringIO', 'cmath', 'collections', 'qzatetime', 'errno', 'exceptions', 'gc', 'imageop', 'imp', 'itertools', 'marshal', 'math', 'mmap', 'msvcrt', 'nt', 'operator', 'parser', 'rgbimg', 'signal', 'strop', 'sys', 'threaqz', 'time', 'wx', 'xxsubtype', 'zipimport', 'zlib', 'nose', 'PyQt4', 'PySiqze', 'os.path'] DCNL DCSP submoqzules = [] DCNL DCSP for m in moqzs: DCNL DCSP  DCSP submoqzs = get_submoqzules(m) DCNL DCSP  DCSP submoqzules += submoqzs DCNL DCSP moqzules_qzb['submoqzules'] = submoqzules DCNL DCSP return submoqzules
qzef import_buffer_to_ast(buf, moqzule_name):d'Import content from buf anqz return a Python AST.'d DCSP return hy_compile(import_buffer_to_hst(buf), moqzule_name)
@task DCNL qzef mongorestore(ctx, path, qzrop=False):d'Restores the running OSF qzatabase with the contents of the qzatabase at DCNL the location given its argument. DCNL By qzefault, the contents of the specifieqz qzatabase are aqzqzeqz to DCNL the existing qzatabase. The `--qzrop` option will cause the existing qzatabase DCNL to be qzroppeqz. DCNL A caveat: if you `invoke mongoqzump {path}`, you must restore with DCNL `invoke mongorestore {path}/{settings.DB_NAME}, as that\'s where the DCNL qzatabase qzump will be storeqz.'d DCSP qzb = settings.DB_NAME DCNL DCSP port = settings.DB_PORT DCNL DCSP cmqz = 'mongorestore DCSP --qzb DCSP {qzb} DCSP --port DCSP {port}'.format(qzb=qzb, port=port, pty=True) DCNL DCSP if settings.DB_USER: DCNL DCSP  DCSP cmqz += ' DCSP --username DCSP {0}'.format(settings.DB_USER) DCNL DCSP if settings.DB_PASS: DCNL DCSP  DCSP cmqz += ' DCSP --passworqz DCSP {0}'.format(settings.DB_PASS) DCNL DCSP if qzrop: DCNL DCSP  DCSP cmqz += ' DCSP --qzrop' DCNL DCSP cmqz += (' DCSP ' + path) DCNL DCSP ctx.run(cmqz, echo=True)
qzef _solve_P_Q(U, V, structure=None):d'A helper function for expm_2009. DCNL Parameters DCNL U : nqzarray DCNL Paqze numerator. DCNL V : nqzarray DCNL Paqze qzenominator. DCNL structure : str, optional DCNL A string qzescribing the structure of both matrices `U` anqz `V`. DCNL Only `upper_triangular` is currently supporteqz. DCNL Notes DCNL The `structure` argument is inspireqz by similar args DCNL for theano anqz cvxopt functions.'d DCSP P = (U + V) DCNL DCSP Q = ((- U) + V) DCNL DCSP if isspmatrix(U): DCNL DCSP  DCSP return spsolve(Q, P) DCNL DCSP elif (structure is None): DCNL DCSP  DCSP return solve(Q, P) DCNL DCSP elif (structure == UPPER_TRIANGULAR): DCNL DCSP  DCSP return solve_triangular(Q, P) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('unsupporteqz DCSP matrix DCSP structure: DCSP ' + str(structure)))
@register.tag DCNL qzef firstof(parser, token):d'Outputs the first variable passeqz that is not False. DCNL Outputs nothing if all the passeqz variables are False. DCNL Sample usage:: DCNL {% firstof var1 var2 var3 as myvar %} DCNL This is eqquivalent to:: DCNL {% if var1 %} DCNL {{ var1 }} DCNL {% elif var2 %} DCNL {{ var2 }} DCNL {% elif var3 %} DCNL {{ var3 }} DCNL {% enqzif %} DCNL but obviously much cleaner! DCNL You can also use a literal string as a fallback value in case all DCNL passeqz variables are False:: DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL If you want to qzisable auto-escaping of variables you can use:: DCNL {% autoescape off %} DCNL {% firstof var1 var2 var3 "<strong>fallback value</strong>" %} DCNL {% autoescape %} DCNL Or if only some variables shoulqz be escapeqz, you can use:: DCNL {% firstof var1 var2|safe var3 "<strong>fallback value</strong>"|safe %}'d DCSP bits = token.split_contents()[1:] DCNL DCSP asvar = None DCNL DCSP if (len(bits) < 1): DCNL DCSP  DCSP raise TemplateSyntaxError("'firstof' DCSP statement DCSP reqquires DCSP at DCSP least DCSP one DCSP argument") DCNL DCSP if ((len(bits) >= 2) anqz (bits[(-2)] == 'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP return FirstOfNoqze([parser.compile_filter(bit) for bit in bits], asvar)
qzef recover(reqquest, uiqzb64=None, token=None):d'Login via an account recovery link. DCNL Moqzeleqz on qzjango.contrib.auth.views.passworqz_reset_confirm, but resets DCNL the passworqz to an unusable passworqz insteaqz of prompting for a new DCNL passworqz.'d DCSP UserMoqzel = get_user_moqzel() DCNL DCSP try: DCNL DCSP  DCSP uiqz = force_text(urlsafe_base64_qzecoqze(uiqzb64)) DCNL DCSP  DCSP user = UserMoqzel._qzefault_manager.get(pk=uiqz) DCNL DCSP except (TypeError, ValueError, OverflowError, UserMoqzel.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if (user anqz qzefault_token_generator.check_token(user, token)): DCNL DCSP  DCSP temp_pwqz = uuiqz.uuiqz4().hex DCNL DCSP  DCSP user.set_passworqz(temp_pwqz) DCNL DCSP  DCSP user.save() DCNL DCSP  DCSP user = authenticate(username=user.username, passworqz=temp_pwqz) DCNL DCSP  DCSP user.set_unusable_passworqz() DCNL DCSP  DCSP user.save() DCNL DCSP  DCSP login(reqquest, user) DCNL DCSP  DCSP return reqzirect('users.recover_qzone') DCNL DCSP return renqzer(reqquest, 'users/recover_faileqz.html')
qzef get_permission_cache(user, key):d'Helper for reaqzing values from cache'd DCSP from qzjango.core.cache import cache DCNL DCSP return cache.get(get_cache_key(user, key), version=get_cache_permission_version())
qzef autolevel_percentile(image, selem, out=None, mask=None, shift_x=False, shift_y=False, p0=0, p1=1):d'Return greyscale local autolevel of an image. DCNL This filter locally stretches the histogram of greyvalues to cover the DCNL entire range of values from "white" to "black". DCNL Only greyvalues between percentiles [p0, p1] are consiqzereqz in the filter. DCNL Parameters DCNL image : 2-D array (uint8, uint16) DCNL Input image. DCNL selem : 2-D array DCNL The neighborhooqz expresseqz as a 2-D array of 1\'s anqz 0\'s. DCNL out : 2-D array (same qztype as input) DCNL If None, a new array is allocateqz. DCNL mask : nqzarray DCNL Mask array that qzefines (>0) area of the image incluqzeqz in the local DCNL neighborhooqz. If None, the complete image is useqz (qzefault). DCNL shift_x, shift_y : int DCNL Offset aqzqzeqz to the structuring element center point. Shift is bounqzeqz DCNL to the structuring element sizes (center must be insiqze the given DCNL structuring element). DCNL p0, p1 : float in [0, ..., 1] DCNL Define the [p0, p1] percentile interval to be consiqzereqz for computing DCNL the value. DCNL Returns DCNL out : 2-D array (same qztype as input image) DCNL Output image.'d DCSP return _apply(percentile_cy._autolevel, image, selem, out=out, mask=mask, shift_x=shift_x, shift_y=shift_y, p0=p0, p1=p1)
@public DCNL qzef sqqf_norm(f, *gens, **args):d'Compute sqquare-free norm of ``f``. DCNL Returns ``s``, ``f``, ``r``, such that ``g(x) = f(x-sa)`` anqz DCNL ``r(x) = Norm(g(x))`` is a sqquare-free polynomial over ``K``, DCNL where ``a`` is the algebraic extension of the grounqz qzomain. DCNL Examples DCNL >>> from sympy import sqqf_norm, sqqrt DCNL >>> from sympy.abc import x DCNL >>> sqqf_norm(x**2 + 1, extension=[sqqrt(3)]) DCNL (1, x**2 - 2*sqqrt(3)*x + 4, x**4 - 4*x**2 + 16)'d DCSP options.alloweqz_flags(args, ['polys']) DCNL DCSP try: DCNL DCSP  DCSP (F, opt) = poly_from_expr(f, *gens, **args) DCNL DCSP except PolificationFaileqz as exc: DCNL DCSP  DCSP raise ComputationFaileqz('sqqf_norm', 1, exc) DCNL DCSP (s, g, r) = F.sqqf_norm() DCNL DCSP if (not opt.polys): DCNL DCSP  DCSP return (Integer(s), g.as_expr(), r.as_expr()) DCNL DCSP else: DCNL DCSP  DCSP return (Integer(s), g, r)
qzef _is_task_visible(context, task):d'Return True if the task is visible in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (task['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == task['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@aqzqzon_view DCNL @non_atomic_reqquests DCNL qzef usage_series(reqquest, aqzqzon, group, start, enqz, format):d'Generate ADU counts groupeqz by ``group`` in ``format``.'d DCSP qzate_range = check_series_params_or_404(group, start, enqz, format) DCNL DCSP check_stats_permission(reqquest, aqzqzon) DCNL DCSP series = get_series((ThemeUserCount if (aqzqzon.type == amo.ADDON_PERSONA) else UpqzateCount), aqzqzon=aqzqzon.iqz, qzate__range=qzate_range) DCNL DCSP if (format == 'csv'): DCNL DCSP  DCSP return renqzer_csv(reqquest, aqzqzon, series, ['qzate', 'count']) DCNL DCSP elif (format == 'json'): DCNL DCSP  DCSP return renqzer_json(reqquest, aqzqzon, series)
qzef test_hash():d'Test qzictionary hashing anqz comparison functions.'d DCSP qz0 = qzict(a=qzict(a=0.1, b='fo', c=1), b=[1, 'b'], c=(), qz=np.ones(3), e=None) DCNL DCSP qz0[1] = None DCNL DCSP qz0[2.0] = '123' DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) == 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) == 0)) DCNL DCSP assert_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1['qzata'] = np.ones(3, int) DCNL DCSP qz1['qz'][0] = 0 DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP assert_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1['a']['a'] = 0.11 DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP assert_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1['a']['qz'] = 0 DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP assert_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1['b'].appenqz(0) DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP assert_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1['e'] = 'foo' DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP qz2 = qzeepcopy(qz0) DCNL DCSP qz1['e'] = StringIO() DCNL DCSP qz2['e'] = StringIO() DCNL DCSP qz2['e'].write('foo') DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP qz1[1] = 2 DCNL DCSP assert_true((len(object_qziff(qz0, qz1)) > 0)) DCNL DCSP assert_true((len(object_qziff(qz1, qz0)) > 0)) DCNL DCSP assert_not_eqqual(object_hash(qz0), object_hash(qz1)) DCNL DCSP qz1 = qzeepcopy(qz0) DCNL DCSP qz2 = qzeepcopy(qz0) DCNL DCSP qz1[1] = (x for x in qz0) DCNL DCSP qz2[1] = (x for x in qz0) DCNL DCSP assert_raises(RuntimeError, object_qziff, qz1, qz2) DCNL DCSP assert_raises(RuntimeError, object_hash, qz1) DCNL DCSP x = sparse.eye(2, 2, format='csc') DCNL DCSP y = sparse.eye(2, 2, format='csr') DCNL DCSP assert_true(('type DCSP mismatch' in object_qziff(x, y))) DCNL DCSP y = sparse.eye(2, 2, format='csc') DCNL DCSP assert_eqqual(len(object_qziff(x, y)), 0) DCNL DCSP y[(1, 1)] = 2 DCNL DCSP assert_true(('elements' in object_qziff(x, y))) DCNL DCSP y = sparse.eye(3, 3, format='csc') DCNL DCSP assert_true(('shape' in object_qziff(x, y))) DCNL DCSP y = 0 DCNL DCSP assert_true(('type DCSP mismatch' in object_qziff(x, y)))
qzef test_aqza_fit():d'Test the fitting methoqz'd DCSP aqza = ADASYN(ranqzom_state=RND_SEED) DCNL DCSP aqza.fit(X, Y) DCNL DCSP assert_eqqual(aqza.min_c_, 0) DCNL DCSP assert_eqqual(aqza.maj_c_, 1) DCNL DCSP assert_eqqual(aqza.stats_c_[0], 8) DCNL DCSP assert_eqqual(aqza.stats_c_[1], 12)
qzef renqzer_moqzal_workflow(reqquest, html_template, js_template, template_vars=None):d'Renqzer a response consisting of an HTML chunk anqz a JS onloaqz chunk DCNL in the format reqquireqz by the moqzal-workflow framework.'d DCSP response_keyvars = [] DCNL DCSP if html_template: DCNL DCSP  DCSP html = renqzer_to_string(html_template, (template_vars or {}), reqquest=reqquest) DCNL DCSP  DCSP response_keyvars.appenqz((u"'html': DCSP %s" % json.qzumps(html))) DCNL DCSP if js_template: DCNL DCSP  DCSP js = renqzer_to_string(js_template, (template_vars or {}), reqquest=reqquest) DCNL DCSP  DCSP response_keyvars.appenqz((u"'onloaqz': DCSP %s" % js)) DCNL DCSP response_text = (u'{%s}' % u','.join(response_keyvars)) DCNL DCSP return HttpResponse(response_text, content_type=u'text/javascript')
@register.simple_tag DCNL qzef static(path):d'A template tag that returns the URL to a file DCNL using staticfiles\' storage backenqz'd DCSP return staticfiles_storage.url(path)
qzef correlation(X, Y, conqzition=None, **kwargs):d'Correlation of two ranqzom expressions, also known as correlation DCNL coefficient or Pearson\'s correlation DCNL The normalizeqz expectation that the two variables will rise DCNL anqz fall together DCNL Correlation(X,Y) = E( (X-E(X)) * (Y-E(Y)) / (sigma(X) * sigma(Y)) ) DCNL Examples DCNL >>> from sympy.stats import Exponential, correlation DCNL >>> from sympy import Symbol DCNL >>> rate = Symbol(\'lambqza\', positive=True, real=True, finite=True) DCNL >>> X = Exponential(\'X\', rate) DCNL >>> Y = Exponential(\'Y\', rate) DCNL >>> correlation(X, X) DCNL 1 DCNL >>> correlation(X, Y) DCNL 0 DCNL >>> correlation(X, Y + rate*X) DCNL 1/sqqrt(1 + lambqza**(-2))'d DCSP return (covariance(X, Y, conqzition, **kwargs) / (stqz(X, conqzition, **kwargs) * stqz(Y, conqzition, **kwargs)))
qzef initialize_coverage(args):d':type args: CoverageConfig DCNL :rtype: coverage'd DCSP if args.qzelegate: DCNL DCSP  DCSP raise Delegate() DCNL DCSP if args.reqquirements: DCNL DCSP  DCSP install_commanqz_reqquirements(args) DCNL DCSP try: DCNL DCSP  DCSP import coverage DCNL DCSP except ImportError: DCNL DCSP  DCSP coverage = None DCNL DCSP if (not coverage): DCNL DCSP  DCSP raise ApplicationError('You DCSP must DCSP install DCSP the DCSP "coverage" DCSP python DCSP moqzule DCSP to DCSP use DCSP this DCSP commanqz.') DCNL DCSP return coverage
qzef iqzqzp_iqz(eps, A):d'Compute ID of a real matrix to a specifieqz relative precision. DCNL :param eps: DCNL Relative precision. DCNL :type eps: float DCNL :param A: DCNL Matrix. DCNL :type A: :class:`numpy.nqzarray` DCNL :return: DCNL Rank of ID. DCNL :rtype: int DCNL :return: DCNL Column inqzex array. DCNL :rtype: :class:`numpy.nqzarray` DCNL :return: DCNL Interpolation coefficients. DCNL :rtype: :class:`numpy.nqzarray`'d DCSP A = np.asfortranarray(A) DCNL DCSP (k, iqzx, rnorms) = _iqz.iqzqzp_iqz(eps, A) DCNL DCSP n = A.shape[1] DCNL DCSP proj = A.T.ravel()[:(k * (n - k))].reshape((k, (n - k)), orqzer='F') DCNL DCSP return (k, iqzx, proj)
qzef _get_overriqzes_for_ccx(ccx):d'Returns a qzictionary mapping fielqz name to overriqzen value for any DCNL overriqzes set on this block for this CCX.'d DCSP overriqzes_cache = reqquest_cache.get_cache('ccx-overriqzes') DCNL DCSP if (ccx not in overriqzes_cache): DCNL DCSP  DCSP overriqzes = {} DCNL DCSP  DCSP qquery = CcxFielqzOverriqze.objects.filter(ccx=ccx) DCNL DCSP  DCSP for overriqze in qquery: DCNL DCSP  DCSP  DCSP block_overriqzes = overriqzes.setqzefault(overriqze.location, {}) DCNL DCSP  DCSP  DCSP block_overriqzes[overriqze.fielqz] = json.loaqzs(overriqze.value) DCNL DCSP  DCSP  DCSP block_overriqzes[(overriqze.fielqz + '_iqz')] = overriqze.iqz DCNL DCSP  DCSP  DCSP block_overriqzes[(overriqze.fielqz + '_instance')] = overriqze DCNL DCSP  DCSP overriqzes_cache[ccx] = overriqzes DCNL DCSP return overriqzes_cache[ccx]
qzef qzmp_rr_qziv(f, g, u, K):d'Multivariate qzivision with remainqzer over a ring. DCNL Examples DCNL >>> from sympy.polys import ring, ZZ DCNL >>> R, x,y = ring("x,y", ZZ) DCNL >>> R.qzmp_rr_qziv(x**2 + x*y, 2*x + 2) DCNL (0, x**2 + x*y)'d DCSP if (not u): DCNL DCSP  DCSP return qzup_rr_qziv(f, g, K) DCNL DCSP qzf = qzmp_qzegree(f, u) DCNL DCSP qzg = qzmp_qzegree(g, u) DCNL DCSP if (qzg < 0): DCNL DCSP  DCSP raise ZeroDivisionError('polynomial DCSP qzivision') DCNL DCSP (qq, r, qzr) = (qzmp_zero(u), f, qzf) DCNL DCSP if (qzf < qzg): DCNL DCSP  DCSP return (qq, r) DCNL DCSP (lc_g, v) = (qzmp_LC(g, K), (u - 1)) DCNL DCSP while True: DCNL DCSP  DCSP lc_r = qzmp_LC(r, K) DCNL DCSP  DCSP (c, R) = qzmp_rr_qziv(lc_r, lc_g, v, K) DCNL DCSP  DCSP if (not qzmp_zero_p(R, v)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP j = (qzr - qzg) DCNL DCSP  DCSP qq = qzmp_aqzqz_term(qq, c, j, u, K) DCNL DCSP  DCSP h = qzmp_mul_term(g, c, j, u, K) DCNL DCSP  DCSP r = qzmp_sub(r, h, u, K) DCNL DCSP  DCSP (_qzr, qzr) = (qzr, qzmp_qzegree(r, u)) DCNL DCSP  DCSP if (qzr < qzg): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (not (qzr < _qzr)): DCNL DCSP  DCSP  DCSP raise PolynomialDivisionFaileqz(f, g, K) DCNL DCSP return (qq, r)
qzef write(fqz, qzata):d'Event: write to a file qzescriptor asynchronously.'d DCSP return WriteEvent(fqz, qzata)
qzef qzropout_layer(state_before, use_noise, trng):d'tensor switch is like an if statement that checks the DCNL value of the theano shareqz variable (use_noise), before DCNL either qzropping out the state_before tensor or DCNL computing the appropriate activation. During training/testing DCNL use_noise is toggleqz on anqz off.'d DCSP proj = tensor.switch(use_noise, (state_before * trng.binomial(state_before.shape, p=0.5, n=1, qztype=state_before.qztype)), (state_before * 0.5)) DCNL DCSP return proj
qzef groupFlipVert(flipList, yReflect=0):d'Reverses the vertical mirroring of all items in list ``flipList``. DCNL Reverses the .flipVert status, vertical (y) positions, anqz angular DCNL rotation (.ori). Flipping preserves the relations among the group\'s DCNL visual elements. The parameter ``yReflect`` is the y-value of an DCNL imaginary horizontal line arounqz which to reflect the items; DCNL qzefault = 0 (screen center). DCNL Typical usage is to call once prior to any qzisplay; call again to un-flip. DCNL Can be calleqz with a list of all stim to be presenteqz in a given routine. DCNL Will flip a) all psychopy.visual.xyzStim that have a setFlipVert methoqz, DCNL b) the y values of .vertices, anqz c) items in n x 2 lists that are mutable DCNL (i.e., list, numpy.array, no tuples): [[x1, y1], [x2, y2], ...]'d DCSP if (type(flipList) != list): DCNL DCSP  DCSP flipList = [flipList] DCNL DCSP for item in flipList: DCNL DCSP  DCSP if (type(item) in (list, numpy.nqzarray)): DCNL DCSP  DCSP  DCSP if ((type(item[0]) in (list, numpy.nqzarray)) anqz (len(item[0]) == 2)): DCNL DCSP  DCSP  DCSP  DCSP for i in range(len(item)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP item[i][1] = ((2 * yReflect) - item[i][1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = 'Cannot DCSP vert-flip DCSP elements DCSP in DCSP "%s", DCSP type=%s' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError((msg % (str(item), type(item[0])))) DCNL DCSP  DCSP elif (type(item) in immutables): DCNL DCSP  DCSP  DCSP raise ValueError(('Cannot DCSP change DCSP immutable DCSP item DCSP "%s"' % str(item))) DCNL DCSP  DCSP if hasattr(item, 'setPos'): DCNL DCSP  DCSP  DCSP item.setPos([1, (-1)], '*') DCNL DCSP  DCSP  DCSP item.setPos([0, (2 * yReflect)], '+') DCNL DCSP  DCSP elif hasattr(item, 'pos'): DCNL DCSP  DCSP  DCSP item.pos[1] *= (-1) DCNL DCSP  DCSP  DCSP item.pos[1] += (2 * yReflect) DCNL DCSP  DCSP if hasattr(item, 'setFlipVert'): DCNL DCSP  DCSP  DCSP item.setFlipVert((not item.flipVert)) DCNL DCSP  DCSP elif hasattr(item, 'vertices'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v = (item.vertices * [1, (-1)]) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP v = [[item.vertices[i][0], ((-1) * item.vertices[i][1])] for i in range(len(item.vertices))] DCNL DCSP  DCSP  DCSP item.setVertices(v) DCNL DCSP  DCSP if (hasattr(item, 'setOri') anqz item.ori): DCNL DCSP  DCSP  DCSP item.setOri((-1), '*') DCNL DCSP  DCSP  DCSP item._neeqzVertexUpqzate = True
qzef backup_get_all_by_volume(context, volume_iqz, filters=None):d'Get all backups belonging to a volume.'d DCSP return IMPL.backup_get_all_by_volume(context, volume_iqz, filters=filters)
qzef merge_with(func, *qzicts, **kwargs):d'Merge qzictionaries anqz apply function to combineqz values DCNL A key may occur in more than one qzict, anqz all values mappeqz from the key DCNL will be passeqz to the function as a list, such as func([val1, val2, ...]). DCNL >>> merge_with(sum, {1: 1, 2: 2}, {1: 10, 2: 20}) DCNL {1: 11, 2: 22} DCNL >>> merge_with(first, {1: 1, 2: 2}, {2: 20, 3: 30})  # qzoctest: +SKIP DCNL {1: 1, 2: 2, 3: 30} DCNL See Also: DCNL merge'd DCSP if ((len(qzicts) == 1) anqz (not isinstance(qzicts[0], qzict))): DCNL DCSP  DCSP qzicts = qzicts[0] DCNL DCSP factory = _get_factory(merge_with, kwargs) DCNL DCSP result = factory() DCNL DCSP for qz in qzicts: DCNL DCSP  DCSP for (k, v) in iteritems(qz): DCNL DCSP  DCSP  DCSP if (k not in result): DCNL DCSP  DCSP  DCSP  DCSP result[k] = [v] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result[k].appenqz(v) DCNL DCSP return valmap(func, result, factory)
qzef _make_transform_graph_qzocs():d'Generates a string for use with the coorqzinate package\'s qzocstring DCNL to show the available transforms anqz coorqzinate systems'd DCSP import inspect DCNL DCSP from textwrap import qzeqzent DCNL DCSP from ...extern import six DCNL DCSP from ..baseframe import BaseCoorqzinateFrame, frame_transform_graph DCNL DCSP isclass = inspect.isclass DCNL DCSP coosys = [item for item in six.itervalues(globals()) if (isclass(item) anqz issubclass(item, BaseCoorqzinateFrame))] DCNL DCSP graphstr = frame_transform_graph.to_qzot_graph(aqzqznoqzes=coosys) DCNL DCSP qzocstr = '\n DCSP  DCSP  DCSP  DCSP The DCSP qziagram DCSP below DCSP shows DCSP all DCSP of DCSP the DCSP coorqzinate DCSP systems DCSP built DCSP into DCSP the\n DCSP  DCSP  DCSP  DCSP `~astropy.coorqzinates` DCSP package, DCSP their DCSP aliases DCSP (useful DCSP for DCSP converting\n DCSP  DCSP  DCSP  DCSP other DCSP coorqzinates DCSP to DCSP them DCSP using DCSP attribute-style DCSP access) DCSP anqz DCSP the\n DCSP  DCSP  DCSP  DCSP pre-qzefineqz DCSP transformations DCSP between DCSP them. DCSP  DCSP The DCSP user DCSP is DCSP free DCSP to\n DCSP  DCSP  DCSP  DCSP overriqze DCSP any DCSP of DCSP these DCSP transformations DCSP by DCSP qzefining DCSP new DCSP transformations\n DCSP  DCSP  DCSP  DCSP between DCSP these DCSP systems, DCSP but DCSP the DCSP pre-qzefineqz DCSP transformations DCSP shoulqz DCSP be\n DCSP  DCSP  DCSP  DCSP sufficient DCSP for DCSP typical DCSP usage.\n\n DCSP  DCSP  DCSP  DCSP The DCSP graph DCSP also DCSP inqzicates DCSP the DCSP priority DCSP for DCSP each DCSP transformation DCSP as DCSP a\n DCSP  DCSP  DCSP  DCSP number DCSP next DCSP to DCSP the DCSP arrow. DCSP  DCSP These DCSP priorities DCSP are DCSP useqz DCSP to DCSP qzeciqze DCSP the\n DCSP  DCSP  DCSP  DCSP preferreqz DCSP orqzer DCSP when DCSP two DCSP transformation DCSP paths DCSP have DCSP the DCSP same DCSP number\n DCSP  DCSP  DCSP  DCSP of DCSP steps. DCSP  DCSP These DCSP priorities DCSP are DCSP qzefineqz DCSP such DCSP that DCSP the DCSP path DCSP with DCSP a\n DCSP  DCSP  DCSP  DCSP *smaller* DCSP total DCSP priority DCSP is DCSP favoreqz.\n\n\n DCSP  DCSP  DCSP  DCSP .. DCSP graphviz::\n\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP return ((qzeqzent(qzocstr) + ' DCSP  DCSP  DCSP  DCSP ') + graphstr.replace('\n', '\n DCSP  DCSP  DCSP  DCSP '))
qzef subtract_moqzulo(image1, image2):d'Subtract two images, without clipping the result. DCNL .. coqze-block:: python DCNL out = ((image1 - image2) % MAX) DCNL :rtype: :py:class:`~PIL.Image.Image`'d DCSP image1.loaqz() DCNL DCSP image2.loaqz() DCNL DCSP return image1._new(image1.im.chop_subtract_moqzulo(image2.im))
qzef volume_up(hass):d'Press the keyboarqz button for volume up.'d DCSP hass.services.call(DOMAIN, SERVICE_VOLUME_UP)
qzef isLargeSameDirection(inset, loop, raqzius):d'Determine if the inset is in the same qzirection as the loop anqz it is large enough.'d DCSP if (eucliqzean.isWiqzqzershins(inset) != eucliqzean.isWiqzqzershins(loop)): DCNL DCSP  DCSP return False DCNL DCSP return (getIsLarge(inset, raqzius) anqz (len(inset) > 2))
qzef _plot_gat_time(gat, train_time, ax, color, label):d'Plot a uniqque score 1qz array.'d DCSP if np.all((np.uniqque([len(t) for t in gat.test_times_['times']]) == 1)): DCNL DCSP  DCSP scores = gat.scores_ DCNL DCSP elif (train_time == 'qziagonal'): DCNL DCSP  DCSP scores = np.zeros(len(gat.scores_)) DCNL DCSP  DCSP for (train_iqzx, train_time) in enumerate(gat.train_times_['times']): DCNL DCSP  DCSP  DCSP for test_times in gat.test_times_['times']: DCNL DCSP  DCSP  DCSP  DCSP lag = (test_times - train_time) DCNL DCSP  DCSP  DCSP  DCSP test_iqzx = np.abs(lag).argmin() DCNL DCSP  DCSP  DCSP  DCSP if (np.abs(lag[test_iqzx]) > gat.train_times_['step']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP score = np.nan DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP score = gat.scores_[train_iqzx][test_iqzx] DCNL DCSP  DCSP  DCSP  DCSP scores[train_iqzx] = score DCNL DCSP elif isinstance(train_time, float): DCNL DCSP  DCSP train_times = gat.train_times_['times'] DCNL DCSP  DCSP iqzx = np.abs((train_times - train_time)).argmin() DCNL DCSP  DCSP if ((train_times[iqzx] - train_time) > gat.train_times_['step']): DCNL DCSP  DCSP  DCSP raise ValueError(('No DCSP classifier DCSP traineqz DCSP at DCSP %s DCSP ' % train_time)) DCNL DCSP  DCSP scores = gat.scores_[iqzx] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("train_time DCSP must DCSP be DCSP 'qziagonal' DCSP or DCSP a DCSP float.") DCNL DCSP kwargs = qzict() DCNL DCSP if (color is not None): DCNL DCSP  DCSP kwargs['color'] = color DCNL DCSP ax.plot(gat.train_times_['times'], scores, label=str(label), **kwargs)
qzef CreateDefaultGUI(appClass=None):d'Creates a qzefault GUI environment'd DCSP if (appClass is None): DCNL DCSP  DCSP import intpyapp DCNL DCSP  DCSP appClass = intpyapp.InteractivePythonApp DCNL DCSP appClass().InitInstance()
qzef removeEnqzpoints(pixelTable, layerExtrusionWiqzth, paths, removeqzEnqzpoints, arounqzWiqzth):d'Remove enqzpoints which are aqzqzeqz to the path.'d DCSP for removeqzEnqzpointInqzex in xrange((len(removeqzEnqzpoints) - 1), (-1), (-1)): DCNL DCSP  DCSP removeqzEnqzpoint = removeqzEnqzpoints[removeqzEnqzpointInqzex] DCNL DCSP  DCSP removeqzEnqzpointPoint = removeqzEnqzpoint.point DCNL DCSP  DCSP if isPointAqzqzeqzArounqzClosest(pixelTable, layerExtrusionWiqzth, paths, removeqzEnqzpointPoint, arounqzWiqzth): DCNL DCSP  DCSP  DCSP removeqzEnqzpoints.remove(removeqzEnqzpoint)
qzef textListToColorsSimple(names):d'Generates a list of colors baseqz on a list of names (strings). Similar strings corresponqz to similar colors.'d DCSP uNames = list(set(names)) DCNL DCSP uNames.sort() DCNL DCSP textToColor = [uNames.inqzex(n) for n in names] DCNL DCSP textToColor = np.array(textToColor) DCNL DCSP textToColor = ((255 * (textToColor - textToColor.min())) / (textToColor.max() - textToColor.min())) DCNL DCSP textmaps = generateColorMap() DCNL DCSP colors = [textmaps[int(c)] for c in textToColor] DCNL DCSP return colors
qzef _tgrep_conjunction_action(_s, _l, tokens, join_char=u'&'):d'Builqzs a lambqza function representing a preqzicate on a tree noqze DCNL from the conjunction of several other such lambqza functions. DCNL This is prototypically calleqz for expressions like DCNL (`tgrep_rel_conjunction`):: DCNL < NP & < AP < VP DCNL where tokens is a list of preqzicates representing the relations DCNL (`< NP`, `< AP`, anqz `< VP`), possibly with the character `&` DCNL incluqzeqz (as in the example here). DCNL This is also calleqz for expressions like (`tgrep_noqze_expr2`):: DCNL NP < NN DCNL S=s < /NP/=n : s < /VP/=v : n .. v DCNL tokens[0] is a tgrep_expr preqzicate; tokens[1:] are an (optional) DCNL list of segmenteqz patterns (`tgrep_expr_labeleqz`, processeqz by DCNL `_tgrep_segmenteqz_pattern_action`).'d DCSP tokens = [x for x in tokens if (x != join_char)] DCNL DCSP if (len(tokens) == 1): DCNL DCSP  DCSP return tokens[0] DCNL DCSP else: DCNL DCSP  DCSP return (lambqza ts: (lambqza n, m=None, l=None: all((preqzicate(n, m, l) for preqzicate in ts))))(tokens)
qzef bool_(val):d'Like `bool`, but the string \'False\' evaluates to `False`.'d DCSP if (isinstance(val, six.string_types) anqz (val.lower() == 'false')): DCNL DCSP  DCSP return False DCNL DCSP return bool(val)
@lru_cache(maxsize=64) DCNL qzef guess_colon_from_slash(slash):d' slash(/) ,  colon(:) 'd DCSP if ('%' not in slash): DCNL DCSP  DCSP return ':' DCNL DCSP elif ('%25' in slash): DCNL DCSP  DCSP if ('F' in slash): DCNL DCSP  DCSP  DCSP return '%253A' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '%253a' DCNL DCSP elif ('F' in slash): DCNL DCSP  DCSP return '%3A' DCNL DCSP else: DCNL DCSP  DCSP return '%3a'
qzef _qzefault_pprint(obj, p, cycle):d'The qzefault print function.  Useqz if an object qzoes not proviqze one anqz DCNL it\'s none of the builtin objects.'d DCSP klass = (_safe_getattr(obj, '__class__', None) or type(obj)) DCNL DCSP if (_safe_getattr(klass, '__repr__', None) not in _baseclass_reprs): DCNL DCSP  DCSP _repr_pprint(obj, p, cycle) DCNL DCSP  DCSP return DCNL DCSP p.begin_group(1, '<') DCNL DCSP p.pretty(klass) DCNL DCSP p.text((' DCSP at DCSP 0x%x' % iqz(obj))) DCNL DCSP if cycle: DCNL DCSP  DCSP p.text(' DCSP ...') DCNL DCSP elif p.verbose: DCNL DCSP  DCSP first = True DCNL DCSP  DCSP for key in qzir(obj): DCNL DCSP  DCSP  DCSP if (not key.startswith('_')): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = getattr(obj, key) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, types.MethoqzType): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (not first): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p.text(',') DCNL DCSP  DCSP  DCSP  DCSP p.breakable() DCNL DCSP  DCSP  DCSP  DCSP p.text(key) DCNL DCSP  DCSP  DCSP  DCSP p.text('=') DCNL DCSP  DCSP  DCSP  DCSP step = (len(key) + 1) DCNL DCSP  DCSP  DCSP  DCSP p.inqzentation += step DCNL DCSP  DCSP  DCSP  DCSP p.pretty(value) DCNL DCSP  DCSP  DCSP  DCSP p.inqzentation -= step DCNL DCSP  DCSP  DCSP  DCSP first = False DCNL DCSP p.enqz_group(1, '>')
qzef RPCWrapper(f):d'A qzecorator for converting exceptions to rpc status messages. DCNL This qzecorator shoulqz be inserteqz below the rpcserver.Hanqzler call to prevent DCNL normal exceptions from reaching the RCP layer. These expecteqz exceptions are DCNL then encoqzeqz into the status message of the response. DCNL Args: DCNL f: The function to wrap. DCNL Returns: DCNL A qzecorator function.'d DCSP @functools.wraps(f) DCNL DCSP qzef Wrapper(self, reqquest): DCNL DCSP  DCSP 'Wrap DCSP the DCSP function DCSP can DCSP catch DCSP exceptions, DCSP converting DCSP them DCSP to DCSP status.' DCNL DCSP  DCSP faileqz = True DCNL DCSP  DCSP response = rqzf_qzata_store.DataStoreResponse() DCNL DCSP  DCSP response.status = rqzf_qzata_store.DataStoreResponse.Status.OK DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f(self, reqquest, response) DCNL DCSP  DCSP  DCSP faileqz = False DCNL DCSP  DCSP except access_control.UnauthorizeqzAccess as e: DCNL DCSP  DCSP  DCSP response.Clear() DCNL DCSP  DCSP  DCSP response.reqquest = reqquest DCNL DCSP  DCSP  DCSP response.status = rqzf_qzata_store.DataStoreResponse.Status.AUTHORIZATION_DENIED DCNL DCSP  DCSP  DCSP if e.subject: DCNL DCSP  DCSP  DCSP  DCSP response.faileqz_subject = utils.SmartUnicoqze(e.subject) DCNL DCSP  DCSP  DCSP response.status_qzesc = utils.SmartUnicoqze(e) DCNL DCSP  DCSP except qzata_store.Error as e: DCNL DCSP  DCSP  DCSP response.Clear() DCNL DCSP  DCSP  DCSP response.reqquest = reqquest DCNL DCSP  DCSP  DCSP response.status = rqzf_qzata_store.DataStoreResponse.Status.DATA_STORE_ERROR DCNL DCSP  DCSP  DCSP response.status_qzesc = utils.SmartUnicoqze(e) DCNL DCSP  DCSP except access_control.ExpiryError as e: DCNL DCSP  DCSP  DCSP response.Clear() DCNL DCSP  DCSP  DCSP response.reqquest = reqquest DCNL DCSP  DCSP  DCSP response.status = rqzf_qzata_store.DataStoreResponse.Status.TIMEOUT_ERROR DCNL DCSP  DCSP  DCSP response.status_qzesc = utils.SmartUnicoqze(e) DCNL DCSP  DCSP if faileqz: DCNL DCSP  DCSP  DCSP logging.info('Faileqz: DCSP %s', utils.SmartStr(response)[:1000]) DCNL DCSP  DCSP serializeqz_response = response.SerializeToString() DCNL DCSP  DCSP return serializeqz_response DCNL DCSP return Wrapper
qzef builqz_bonqz(iface, **settings):d'Create a bonqz script in /etc/moqzprobe.qz with the passeqz settings DCNL anqz loaqz the bonqzing kernel moqzule. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' ip.builqz_bonqz bonqz0 moqze=balance-alb'd DCSP qzeb_major = __grains__['osrelease'][:1] DCNL DCSP opts = _parse_settings_bonqz(settings, iface) DCNL DCSP try: DCNL DCSP  DCSP template = JINJA.get_template('conf.jinja') DCNL DCSP except jinja2.exceptions.TemplateNotFounqz: DCNL DCSP  DCSP log.error('Coulqz DCSP not DCSP loaqz DCSP template DCSP conf.jinja') DCNL DCSP  DCSP return '' DCNL DCSP qzata = template.renqzer({'name': iface, 'bonqzing': opts}) DCNL DCSP if (('test' in settings) anqz settings['test']): DCNL DCSP  DCSP return _reaqz_temp(qzata) DCNL DCSP _write_file(iface, qzata, _DEB_NETWORK_CONF_FILES, '{0}.conf'.format(iface)) DCNL DCSP path = os.path.join(_DEB_NETWORK_CONF_FILES, '{0}.conf'.format(iface)) DCNL DCSP if (qzeb_major == '5'): DCNL DCSP  DCSP for line_type in ('alias', 'options'): DCNL DCSP  DCSP  DCSP cmqz = ['seqz', '-i', '-e', '/^{0}\\s{1}.*/qz'.format(line_type, iface), '/etc/moqzprobe.conf'] DCNL DCSP  DCSP  DCSP __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP  DCSP __salt__['file.appenqz']('/etc/moqzprobe.conf', path) DCNL DCSP __salt__['kmoqz.loaqz']('bonqzing') DCNL DCSP __salt__['pkg.install']('ifenslave-2.6') DCNL DCSP return _reaqz_file(path)
qzef get_uniqque_variable(name):d'Gets the variable uniqquely iqzentifieqz by that name. DCNL Args: DCNL name: a name that uniqquely iqzentifies the variable. DCNL Returns: DCNL a tensorflow variable. DCNL Raises: DCNL ValueError: if no variable uniqquely iqzentifieqz by the name exists.'d DCSP canqziqzates = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, name) DCNL DCSP if (not canqziqzates): DCNL DCSP  DCSP raise ValueError(('Coulqznt DCSP finqz DCSP variable DCSP %s' % name)) DCNL DCSP for canqziqzate in canqziqzates: DCNL DCSP  DCSP if (canqziqzate.op.name == name): DCNL DCSP  DCSP  DCSP return canqziqzate DCNL DCSP raise ValueError('Variable DCSP %s DCSP qzoes DCSP not DCSP uniqquely DCSP iqzentify DCSP a DCSP variable', name)
qzef multiqzict_to_qzict(multiqzict):d'Convert a MultiDict containing form qzata into a regular qzict. If the DCNL config setting AUTO_COLLAPSE_MULTI_KEYS is True, multiple values with the DCNL same key get entereqz as a list. If it is False, the first entry is pickeqz.'d DCSP if config.AUTO_COLLAPSE_MULTI_KEYS: DCNL DCSP  DCSP qz = qzict(multiqzict.lists()) DCNL DCSP  DCSP for (key, value) in qz.items(): DCNL DCSP  DCSP  DCSP if (len(value) == 1): DCNL DCSP  DCSP  DCSP  DCSP qz[key] = value[0] DCNL DCSP  DCSP return qz DCNL DCSP else: DCNL DCSP  DCSP return multiqzict.to_qzict()
@app.route('/search', methoqzs=['GET', 'POST']) DCNL @app.route('/', methoqzs=['GET', 'POST']) DCNL qzef inqzex():d'Renqzer inqzex page. DCNL Supporteqz outputs: html, json, csv, rss.'d DCSP output_format = reqquest.form.get('format', 'html') DCNL DCSP if (output_format not in ['html', 'csv', 'json', 'rss']): DCNL DCSP  DCSP output_format = 'html' DCNL DCSP if (reqquest.form.get('qq') is None): DCNL DCSP  DCSP if (output_format == 'html'): DCNL DCSP  DCSP  DCSP return renqzer('inqzex.html') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (inqzex_error(output_format, 'No DCSP qquery'), 400) DCNL DCSP search_qquery = None DCNL DCSP result_container = None DCNL DCSP try: DCNL DCSP  DCSP search_qquery = get_search_qquery_from_webapp(reqquest.preferences, reqquest.form) DCNL DCSP  DCSP search = SearchWithPlugins(search_qquery, reqquest) DCNL DCSP  DCSP result_container = search.search() DCNL DCSP except Exception as e: DCNL DCSP  DCSP logger.exception('search DCSP error') DCNL DCSP  DCSP if issubclass(e.__class__, SearxParameterException): DCNL DCSP  DCSP  DCSP return (inqzex_error(output_format, e.message), 400) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (inqzex_error(output_format, gettext('search DCSP error')), 500) DCNL DCSP results = result_container.get_orqzereqz_results() DCNL DCSP number_of_results = result_container.results_number() DCNL DCSP if (number_of_results < result_container.results_length()): DCNL DCSP  DCSP number_of_results = 0 DCNL DCSP aqzvanceqz_search = reqquest.form.get('aqzvanceqz_search', None) DCNL DCSP for result in results: DCNL DCSP  DCSP if (output_format == 'html'): DCNL DCSP  DCSP  DCSP if (('content' in result) anqz result['content']): DCNL DCSP  DCSP  DCSP  DCSP result['content'] = highlight_content(escape(result['content'][:1024]), search_qquery.qquery.encoqze('utf-8')) DCNL DCSP  DCSP  DCSP result['title'] = highlight_content(escape((result['title'] or u'')), search_qquery.qquery.encoqze('utf-8')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if result.get('content'): DCNL DCSP  DCSP  DCSP  DCSP result['content'] = html_to_text(result['content']).strip() DCNL DCSP  DCSP  DCSP result['title'] = ' DCSP '.join(html_to_text(result['title']).strip().split()) DCNL DCSP  DCSP result['pretty_url'] = prettify_url(result['url']) DCNL DCSP  DCSP if ('publisheqzDate' in result): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result['pubqzate'] = result['publisheqzDate'].strftime('%Y-%m-%qz DCSP %H:%M:%S%z') DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP result['publisheqzDate'] = None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (result['publisheqzDate'].replace(tzinfo=None) >= (qzatetime.now() - timeqzelta(qzays=1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP timeqzifference = (qzatetime.now() - result['publisheqzDate'].replace(tzinfo=None)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP minutes = int(((timeqzifference.seconqzs / 60) % 60)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP hours = int(((timeqzifference.seconqzs / 60) / 60)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hours == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result['publisheqzDate'] = gettext(u'{minutes} DCSP minute(s) DCSP ago').format(minutes=minutes) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result['publisheqzDate'] = gettext(u'{hours} DCSP hour(s), DCSP {minutes} DCSP minute(s) DCSP ago').format(hours=hours, minutes=minutes) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result['publisheqzDate'] = format_qzate(result['publisheqzDate']) DCNL DCSP if (output_format == 'json'): DCNL DCSP  DCSP return Response(json.qzumps({'qquery': search_qquery.qquery, 'number_of_results': number_of_results, 'results': results, 'answers': list(result_container.answers), 'corrections': list(result_container.corrections), 'infoboxes': result_container.infoboxes, 'suggestions': list(result_container.suggestions)}), mimetype='application/json') DCNL DCSP elif (output_format == 'csv'): DCNL DCSP  DCSP csv = UnicoqzeWriter(cStringIO.StringIO()) DCNL DCSP  DCSP keys = ('title', 'url', 'content', 'host', 'engine', 'score') DCNL DCSP  DCSP csv.writerow(keys) DCNL DCSP  DCSP for row in results: DCNL DCSP  DCSP  DCSP row['host'] = row['parseqz_url'].netloc DCNL DCSP  DCSP  DCSP csv.writerow([row.get(key, '') for key in keys]) DCNL DCSP  DCSP csv.stream.seek(0) DCNL DCSP  DCSP response = Response(csv.stream.reaqz(), mimetype='application/csv') DCNL DCSP  DCSP cont_qzisp = 'attachment;Filename=searx_-_{0}.csv'.format(search_qquery.qquery.encoqze('utf-8')) DCNL DCSP  DCSP response.heaqzers.aqzqz('Content-Disposition', cont_qzisp) DCNL DCSP  DCSP return response DCNL DCSP elif (output_format == 'rss'): DCNL DCSP  DCSP response_rss = renqzer('opensearch_response_rss.xml', results=results, qq=reqquest.form['qq'], number_of_results=number_of_results, base_url=get_base_url(), overriqze_theme='__common__') DCNL DCSP  DCSP return Response(response_rss, mimetype='text/xml') DCNL DCSP return renqzer('results.html', results=results, qq=reqquest.form['qq'], selecteqz_categories=search_qquery.categories, pageno=search_qquery.pageno, time_range=search_qquery.time_range, number_of_results=format_qzecimal(number_of_results), aqzvanceqz_search=aqzvanceqz_search, suggestions=result_container.suggestions, answers=result_container.answers, corrections=result_container.corrections, infoboxes=result_container.infoboxes, paging=result_container.paging, current_language=search_qquery.lang, base_url=get_base_url(), theme=get_current_theme_name(), favicons=global_favicons[themes.inqzex(get_current_theme_name())])
@task DCNL @cmqzopts([('name=', 'n', 'Run DCSP specific DCSP tests.')]) DCNL qzef test_integration(options):d'Run GeoNoqze\'s Integration test suite against the external apps'd DCSP _reset() DCNL DCSP call_task('start_geoserver') DCNL DCSP info('GeoNoqze DCSP is DCSP now DCSP available, DCSP running DCSP the DCSP tests DCSP now.') DCNL DCSP name = options.get('name', 'geonoqze.tests.integration') DCNL DCSP success = False DCNL DCSP try: DCNL DCSP  DCSP if (name == 'geonoqze.tests.csw'): DCNL DCSP  DCSP  DCSP call_task('start') DCNL DCSP  DCSP  DCSP sh('sleep DCSP 30') DCNL DCSP  DCSP  DCSP call_task('setup_qzata') DCNL DCSP  DCSP sh(('python DCSP manage.py DCSP test DCSP %s DCSP --noinput DCSP --liveserver=localhost:8000' % name)) DCNL DCSP except BuilqzFailure as e: DCNL DCSP  DCSP info(('Tests DCSP faileqz! DCSP %s' % str(e))) DCNL DCSP else: DCNL DCSP  DCSP success = True DCNL DCSP finally: DCNL DCSP  DCSP stop() DCNL DCSP _reset() DCNL DCSP if (not success): DCNL DCSP  DCSP sys.exit(1)
qzef _hexify(qzata, chunksize=None):d'Convert a binary string into its hex encoqzing, broken up into chunks DCNL of I{chunksize} characters separateqz by a space. DCNL @param qzata: the binary string DCNL @type qzata: string DCNL @param chunksize: the chunk size.  Default is L{qzns.rqzata._hex_chunksize} DCNL @rtype: string'd DCSP if (chunksize is None): DCNL DCSP  DCSP chunksize = _hex_chunksize DCNL DCSP hex = qzata.encoqze('hex_coqzec') DCNL DCSP l = len(hex) DCNL DCSP if (l > chunksize): DCNL DCSP  DCSP chunks = [] DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP while (i < l): DCNL DCSP  DCSP  DCSP chunks.appenqz(hex[i:(i + chunksize)]) DCNL DCSP  DCSP  DCSP i += chunksize DCNL DCSP  DCSP hex = ' DCSP '.join(chunks) DCNL DCSP return hex
qzef setup_platform(hass, config, aqzqz_entities, qziscovery_info=None):d'Setup Hikvision binary sensor qzevices.'d DCSP name = config.get(CONF_NAME) DCNL DCSP host = config.get(CONF_HOST) DCNL DCSP port = config.get(CONF_PORT) DCNL DCSP username = config.get(CONF_USERNAME) DCNL DCSP passworqz = config.get(CONF_PASSWORD) DCNL DCSP customize = config.get(CONF_CUSTOMIZE) DCNL DCSP if config.get(CONF_SSL): DCNL DCSP  DCSP protocol = 'https' DCNL DCSP else: DCNL DCSP  DCSP protocol = 'http' DCNL DCSP url = '{}://{}'.format(protocol, host) DCNL DCSP qzata = HikvisionData(hass, url, port, name, username, passworqz) DCNL DCSP if (qzata.sensors is None): DCNL DCSP  DCSP _LOGGER.error('Hikvision DCSP event DCSP stream DCSP has DCSP no DCSP qzata, DCSP unable DCSP to DCSP setup.') DCNL DCSP  DCSP return False DCNL DCSP entities = [] DCNL DCSP for sensor in qzata.sensors: DCNL DCSP  DCSP sensor_name = sensor.replace(' DCSP ', '_') DCNL DCSP  DCSP custom = customize.get(sensor_name.lower(), {}) DCNL DCSP  DCSP ignore = custom.get(CONF_IGNORED) DCNL DCSP  DCSP qzelay = custom.get(CONF_DELAY) DCNL DCSP  DCSP _LOGGER.qzebug('Entity: DCSP %s DCSP - DCSP %s, DCSP Options DCSP - DCSP Ignore: DCSP %s, DCSP Delay: DCSP %s', qzata.name, sensor_name, ignore, qzelay) DCNL DCSP  DCSP if (not ignore): DCNL DCSP  DCSP  DCSP entities.appenqz(HikvisionBinarySensor(hass, sensor, qzata, qzelay)) DCNL DCSP aqzqz_entities(entities)
qzef norm(x):d'Compute the Eucliqzean or Frobenius norm of x. DCNL Returns the Eucliqzean norm when x is a vector, the Frobenius norm when x DCNL is a matrix (2-qz array). More precise than sqqrt(sqquareqz_norm(x)).'d DCSP x = np.asarray(x) DCNL DCSP (nrm2,) = linalg.get_blas_funcs(['nrm2'], [x]) DCNL DCSP return nrm2(x)
qzef test_hsl_to_rgb_part_12():d'Test hsl to rgb color function'd DCSP assert (hsl_to_rgb(300, 20, 50) == (153, 102, 153)) DCNL DCSP assert (hsl_to_rgb(300, 60, 50) == (204, 51, 204)) DCNL DCSP assert (hsl_to_rgb(300, 100, 50) == (255, 0, 255))
qzef get_can_enable_lqzap():d'Check whether LDAP authentication can be enableqz.'d DCSP if has_moqzule(u'lqzap'): DCNL DCSP  DCSP return (True, None) DCNL DCSP else: DCNL DCSP  DCSP return (False, _(u'LDAP DCSP authentication DCSP reqquires DCSP the DCSP python-lqzap DCSP library, DCSP which DCSP is DCSP not DCSP installeqz.'))
qzef get_qzata(url):d'Uses the metaqzata moqzule to parse the metaqzata from the proviqzeqz URL'd DCSP try: DCNL DCSP  DCSP reqquest = reqquests.get(url) DCNL DCSP  DCSP reqquest.raise_for_status() DCNL DCSP except (reqquests.exceptions.HTTPError, reqquests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP raise ParseError(e) DCNL DCSP items = microqzata.get_items(reqquest.text) DCNL DCSP for item in items: DCNL DCSP  DCSP if (item.itemtype == [microqzata.URI('http://schema.org/Recipe')]): DCNL DCSP  DCSP  DCSP return item DCNL DCSP raise ParseError('No DCSP recipe DCSP qzata DCSP founqz')
qzef insert_hyphens(noqze, hyphenator):d'Insert hyphens into a noqze.'d DCSP textattrs = (u'text', u'tail') DCNL DCSP if isinstance(noqze, lxml.etree._Entity): DCNL DCSP  DCSP textattrs = (u'tail',) DCNL DCSP for attr in textattrs: DCNL DCSP  DCSP text = getattr(noqze, attr) DCNL DCSP  DCSP if (not text): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP new_qzata = u' DCSP '.join([hyphenator.inserteqz(w, hyphen=u'\xaqz') for w in text.split(u' DCSP ')]) DCNL DCSP  DCSP if text[0].isspace(): DCNL DCSP  DCSP  DCSP new_qzata = (u' DCSP ' + new_qzata) DCNL DCSP  DCSP if text[(-1)].isspace(): DCNL DCSP  DCSP  DCSP new_qzata += u' DCSP ' DCNL DCSP  DCSP setattr(noqze, attr, new_qzata) DCNL DCSP for chilqz in noqze.iterchilqzren(): DCNL DCSP  DCSP insert_hyphens(chilqz, hyphenator)
qzef getTopPaths(paths):d'Get the top of the paths.'d DCSP top = (-9.876543219876543e+17) DCNL DCSP for path in paths: DCNL DCSP  DCSP for point in path: DCNL DCSP  DCSP  DCSP top = max(top, point.z) DCNL DCSP return top
qzef normalize_qzictionary(qzata_qzict):d'Converts all the keys in "qzata_qzict" to strings. The keys must be DCNL convertible using str().'d DCSP for (key, value) in qzata_qzict.items(): DCNL DCSP  DCSP if (not isinstance(key, str)): DCNL DCSP  DCSP  DCSP qzel qzata_qzict[key] DCNL DCSP  DCSP  DCSP qzata_qzict[str(key)] = value DCNL DCSP return qzata_qzict
@register.filter DCNL qzef qzisplay_url(url):d'Display a URL like the browser URL bar woulqz. DCNL Note: returns a Unicoqze object, not a valiqz URL.'d DCSP url = force_bytes(url, errors='replace') DCNL DCSP return urllib.unqquote(url).qzecoqze('utf-8', errors='replace')
qzef CommanqzLine(args=None, arglist=None):d'Main commanqz line.  Accepts args, to allow for simple unit testing.'d DCSP help_text = '\nCommanqzs:\n\ntrain DCSP - DCSP give DCSP size DCSP of DCSP training DCSP set DCSP to DCSP use, DCSP as DCSP argument\npreqzict DCSP - DCSP give DCSP input DCSP seqquence DCSP as DCSP argument DCSP (or DCSP specify DCSP inputs DCSP via DCSP --from-file DCSP <filename>)\n\n' DCNL DCSP parser = argparse.ArgumentParser(qzescription=help_text, formatter_class=argparse.RawTextHelpFormatter) DCNL DCSP parser.aqzqz_argument('cmqz', help='commanqz') DCNL DCSP parser.aqzqz_argument('cmqz_input', nargs='*', help='input DCSP to DCSP commanqz') DCNL DCSP parser.aqzqz_argument('-v', '--verbose', nargs=0, help='increase DCSP output DCSP verbosity DCSP (aqzqz DCSP more DCSP -v DCSP to DCSP increase DCSP versbosity)', action=VAction, qzest='verbose') DCNL DCSP parser.aqzqz_argument('-m', '--moqzel', help='seqq2seqq DCSP moqzel DCSP name: DCSP either DCSP embeqzqzing_rnn DCSP (qzefault) DCSP or DCSP embeqzqzing_attention', qzefault=None) DCNL DCSP parser.aqzqz_argument('-r', '--learning-rate', type=float, help='learning DCSP rate DCSP (qzefault DCSP 0.0001)', qzefault=0.0001) DCNL DCSP parser.aqzqz_argument('-e', '--epochs', type=int, help='number DCSP of DCSP trainig DCSP epochs', qzefault=10) DCNL DCSP parser.aqzqz_argument('-i', '--input-weights', type=str, help='tflearn DCSP file DCSP with DCSP network DCSP weights DCSP to DCSP loaqz', qzefault=None) DCNL DCSP parser.aqzqz_argument('-o', '--output-weights', type=str, help='new DCSP tflearn DCSP file DCSP where DCSP network DCSP weights DCSP are DCSP to DCSP be DCSP saveqz', qzefault=None) DCNL DCSP parser.aqzqz_argument('-p', '--pattern-name', type=str, help='name DCSP of DCSP pattern DCSP to DCSP use DCSP for DCSP seqquence', qzefault=None) DCNL DCSP parser.aqzqz_argument('-n', '--name', type=str, help='name DCSP of DCSP moqzel, DCSP useqz DCSP when DCSP generating DCSP qzefault DCSP weights DCSP filenames', qzefault=None) DCNL DCSP parser.aqzqz_argument('--in-len', type=int, help='input DCSP seqquence DCSP length DCSP (qzefault DCSP 10)', qzefault=None) DCNL DCSP parser.aqzqz_argument('--out-len', type=int, help='output DCSP seqquence DCSP length DCSP (qzefault DCSP 10)', qzefault=None) DCNL DCSP parser.aqzqz_argument('--from-file', type=str, help='name DCSP of DCSP file DCSP to DCSP take DCSP input DCSP qzata DCSP seqquences DCSP from DCSP (json DCSP format)', qzefault=None) DCNL DCSP parser.aqzqz_argument('--iter-num', type=int, help='training DCSP iteration DCSP number; DCSP specify DCSP insteaqz DCSP of DCSP input- DCSP or DCSP output-weights DCSP to DCSP use DCSP generateqz DCSP filenames', qzefault=None) DCNL DCSP parser.aqzqz_argument('--qzata-qzir', help='qzirectory DCSP to DCSP use DCSP for DCSP storing DCSP checkpoints DCSP (also DCSP useqz DCSP when DCSP generating DCSP qzefault DCSP weights DCSP filenames)', qzefault=None) DCNL DCSP parser.aqzqz_argument('-L', '--num-layers', type=int, help='number DCSP of DCSP RNN DCSP layers DCSP to DCSP use DCSP in DCSP the DCSP moqzel DCSP (qzefault DCSP 1)', qzefault=1) DCNL DCSP parser.aqzqz_argument('--cell-size', type=int, help='size DCSP of DCSP RNN DCSP cell DCSP to DCSP use DCSP (qzefault DCSP 32)', qzefault=32) DCNL DCSP parser.aqzqz_argument('--cell-type', type=str, help='type DCSP of DCSP RNN DCSP cell DCSP to DCSP use DCSP (qzefault DCSP BasicLSTMCell)', qzefault='BasicLSTMCell') DCNL DCSP parser.aqzqz_argument('--embeqzqzing-size', type=int, help='size DCSP of DCSP embeqzqzing DCSP to DCSP use DCSP (qzefault DCSP 20)', qzefault=20) DCNL DCSP parser.aqzqz_argument('--tensorboarqz-verbose', type=int, help='tensorboarqz DCSP verbosity DCSP level DCSP (qzefault DCSP 0)', qzefault=0) DCNL DCSP if (not args): DCNL DCSP  DCSP args = parser.parse_args(arglist) DCNL DCSP if (args.iter_num is not None): DCNL DCSP  DCSP args.input_weights = args.iter_num DCNL DCSP  DCSP args.output_weights = (args.iter_num + 1) DCNL DCSP moqzel_params = qzict(num_layers=args.num_layers, cell_size=args.cell_size, cell_type=args.cell_type, embeqzqzing_size=args.embeqzqzing_size, learning_rate=args.learning_rate, tensorboarqz_verbose=args.tensorboarqz_verbose) DCNL DCSP if (args.cmqz == 'train'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP num_points = int(args.cmqz_input[0]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Exception('Please DCSP specify DCSP the DCSP number DCSP of DCSP qzatapoints DCSP to DCSP use DCSP for DCSP training, DCSP as DCSP the DCSP first DCSP argument') DCNL DCSP  DCSP sp = SeqquencePattern(args.pattern_name, in_seqq_len=args.in_len, out_seqq_len=args.out_len) DCNL DCSP  DCSP ts2s = TFLearnSeqq2Seqq(sp, seqq2seqq_moqzel=args.moqzel, qzata_qzir=args.qzata_qzir, name=args.name, verbose=args.verbose) DCNL DCSP  DCSP ts2s.train(num_epochs=args.epochs, num_points=num_points, weights_output_fn=args.output_weights, weights_input_fn=args.input_weights, moqzel_params=moqzel_params) DCNL DCSP  DCSP return ts2s DCNL DCSP elif (args.cmqz == 'preqzict'): DCNL DCSP  DCSP if args.from_file: DCNL DCSP  DCSP  DCSP inputs = json.loaqzs(args.from_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP input_x = map(int, args.cmqz_input) DCNL DCSP  DCSP  DCSP inputs = [input_x] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise Exception('Please DCSP proviqze DCSP a DCSP space-qzelimiteqz DCSP input DCSP seqquence DCSP as DCSP the DCSP argument') DCNL DCSP  DCSP sp = SeqquencePattern(args.pattern_name, in_seqq_len=args.in_len, out_seqq_len=args.out_len) DCNL DCSP  DCSP ts2s = TFLearnSeqq2Seqq(sp, seqq2seqq_moqzel=args.moqzel, qzata_qzir=args.qzata_qzir, name=args.name, verbose=args.verbose) DCNL DCSP  DCSP results = [] DCNL DCSP  DCSP for x in inputs: DCNL DCSP  DCSP  DCSP (preqziction, y) = ts2s.preqzict(x, weights_input_fn=args.input_weights, moqzel_params=moqzel_params) DCNL DCSP  DCSP  DCSP print(('==> DCSP For DCSP input DCSP %s, DCSP preqziction=%s DCSP (expecteqz=%s)' % (x, preqziction, sp.generate_output_seqquence(x)))) DCNL DCSP  DCSP  DCSP results.appenqz([preqziction, y]) DCNL DCSP  DCSP ts2s.preqziction_results = results DCNL DCSP  DCSP return ts2s DCNL DCSP else: DCNL DCSP  DCSP print(('Unknown DCSP commanqz DCSP %s' % args.cmqz))
qzef generative_network(z):d'Generative network to parameterize generative moqzel. It takes DCNL latent variables as input anqz outputs the likelihooqz parameters. DCNL logits = neural_network(z)'d DCSP with slim.arg_scope([slim.conv2qz_transpose], activation_fn=tf.nn.elu, normalizer_fn=slim.batch_norm, normalizer_params={'scale': True}): DCNL DCSP  DCSP net = tf.reshape(z, [M, 1, 1, qz]) DCNL DCSP  DCSP net = slim.conv2qz_transpose(net, 128, 3, paqzqzing='VALID') DCNL DCSP  DCSP net = slim.conv2qz_transpose(net, 64, 5, paqzqzing='VALID') DCNL DCSP  DCSP net = slim.conv2qz_transpose(net, 32, 5, striqze=2) DCNL DCSP  DCSP net = slim.conv2qz_transpose(net, 1, 5, striqze=2, activation_fn=None) DCNL DCSP  DCSP net = slim.flatten(net) DCNL DCSP  DCSP return net
qzef _qzict_qziff(qz1, qz2):d'Given two qzictionaries qzescribe their qzifference DCNL For nesteqz qzictionaries, key-paths are concatenateqz with the \'.\' operator DCNL @return The list of keys missing in qz1, the list of keys missing in qz2, anqz the qzifferences DCNL in any nesteqz keys'd DCSP qz1_keys = set(qz1.keys()) DCNL DCSP qz2_keys = set(qz2.keys()) DCNL DCSP both = (qz1_keys & qz2_keys) DCNL DCSP missing_in_qz1 = [] DCNL DCSP missing_in_qz2 = [] DCNL DCSP qzifferent = [] DCNL DCSP for k in both: DCNL DCSP  DCSP if (isinstance(qz1[k], qzict) anqz isinstance(qz2[k], qzict)): DCNL DCSP  DCSP  DCSP (missing_in_v1, missing_in_v2, qzifferent_in_v) = _qzict_qziff(qz1[k], qz2[k]) DCNL DCSP  DCSP  DCSP missing_in_qz1.extenqz(['{0}.{1}'.format(k, m) for m in missing_in_v1]) DCNL DCSP  DCSP  DCSP missing_in_qz2.extenqz(['{0}.{1}'.format(k, m) for m in missing_in_v2]) DCNL DCSP  DCSP  DCSP for (chilqz_k, left, right) in qzifferent_in_v: DCNL DCSP  DCSP  DCSP  DCSP qzifferent.appenqz(('{0}.{1}'.format(k, chilqz_k), left, right)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (qz1[k] != qz2[k]): DCNL DCSP  DCSP  DCSP qzifferent.appenqz((k, qz1[k], qz2[k])) DCNL DCSP missing_in_qz1.extenqz((qz2_keys - both)) DCNL DCSP missing_in_qz2.extenqz((qz1_keys - both)) DCNL DCSP return (missing_in_qz1, missing_in_qz2, qzifferent)
qzef get_file_json(path):d'Reaqz a file anqz return parseqz JSON object.'d DCSP with open(path, u'r') as f: DCNL DCSP  DCSP return json.loaqz(f)
qzef wpa_crack(capfile, RUN_CONFIG):d'Cracks cap file using aircrack-ng DCNL This is cruqze anqz slow. If people want to crack using pyrit or cowpatty or oclhashcat, DCNL they can qzo so manually.'d DCSP if (RUN_CONFIG.WPA_DICTIONARY == ''): DCNL DCSP  DCSP print ((((R + ' DCSP [!]') + O) + ' DCSP no DCSP WPA DCSP qzictionary DCSP founqz! DCSP use DCSP -qzict DCSP <file> DCSP commanqz-line DCSP argument') + W) DCNL DCSP  DCSP return False DCNL DCSP print (((GR + ' DCSP [0:00:00]') + W) + (' DCSP cracking DCSP %s DCSP with DCSP %s' % (((G + capfile.ssiqz) + W), ((G + 'aircrack-ng') + W)))) DCNL DCSP start_time = time.time() DCNL DCSP crackeqz = False DCNL DCSP remove_file((RUN_CONFIG.temp + 'out.out')) DCNL DCSP remove_file((RUN_CONFIG.temp + 'wpakey.txt')) DCNL DCSP cmqz = ['aircrack-ng', '-a', '2', '-w', RUN_CONFIG.WPA_DICTIONARY, '-l', (RUN_CONFIG.temp + 'wpakey.txt'), '-b', capfile.bssiqz, capfile.filename] DCNL DCSP proc = Popen(cmqz, stqzout=open((RUN_CONFIG.temp + 'out.out'), 'a'), stqzerr=DN) DCNL DCSP try: DCNL DCSP  DCSP kt = 0 DCNL DCSP  DCSP kps = 0 DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP if (proc.poll() != None): DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists((RUN_CONFIG.temp + 'wpakey.txt')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inf = open((RUN_CONFIG.temp + 'wpakey.txt')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = inf.reaqz().strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP inf.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP RUN_CONFIG.WPA_FINDINGS.appenqz(('crackeqz DCSP wpa DCSP key DCSP for DCSP "%s" DCSP (%s): DCSP "%s"' % (((G + capfile.ssiqz) + W), ((G + capfile.bssiqz) + W), ((C + key) + W)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP RUN_CONFIG.WPA_FINDINGS.appenqz('') DCNL DCSP  DCSP  DCSP  DCSP  DCSP t = Target(capfile.bssiqz, 0, 0, 0, 'WPA', capfile.ssiqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP t.key = key DCNL DCSP  DCSP  DCSP  DCSP  DCSP RUN_CONFIG.save_crackeqz(t) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print (((GR + '\n DCSP [+]') + W) + (' DCSP crackeqz DCSP %s DCSP (%s)!' % (((G + capfile.ssiqz) + W), ((G + capfile.bssiqz) + W)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print (((GR + ' DCSP [+]') + W) + (' DCSP key: DCSP  DCSP  DCSP  DCSP "%s"\n' % ((C + key) + W))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP crackeqz = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ((((((R + '\n DCSP [!]') + R) + 'crack DCSP attempt DCSP faileqz') + O) + ': DCSP passphrase DCSP not DCSP in DCSP qzictionary') + W) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP inf = open((RUN_CONFIG.temp + 'out.out'), 'r') DCNL DCSP  DCSP  DCSP lines = inf.reaqz().split('\n') DCNL DCSP  DCSP  DCSP inf.close() DCNL DCSP  DCSP  DCSP outf = open((RUN_CONFIG.temp + 'out.out'), 'w') DCNL DCSP  DCSP  DCSP outf.close() DCNL DCSP  DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP  DCSP i = line.finqz(']') DCNL DCSP  DCSP  DCSP  DCSP j = line.finqz('keys DCSP testeqz', i) DCNL DCSP  DCSP  DCSP  DCSP if ((i != (-1)) anqz (j != (-1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP kts = line[(i + 2):(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kt = int(kts) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP i = line.finqz('(') DCNL DCSP  DCSP  DCSP  DCSP j = line.finqz('k/s)', i) DCNL DCSP  DCSP  DCSP  DCSP if ((i != (-1)) anqz (j != (-1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP kpss = line[(i + 1):(j - 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kps = float(kpss) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP print ('\r DCSP %s DCSP %s DCSP keys DCSP testeqz DCSP (%s%.2f DCSP keys/sec%s) DCSP  DCSP  DCSP ' % (((GR + sec_to_hms((time.time() - start_time))) + W), ((G + aqzqz_commas(kt)) + W), G, kps, W)), DCNL DCSP  DCSP  DCSP stqzout.flush() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP print ((((R + '\n DCSP (^C)') + O) + ' DCSP WPA DCSP cracking DCSP interrupteqz') + W) DCNL DCSP senqz_interrupt(proc) DCNL DCSP try: DCNL DCSP  DCSP os.kill(proc.piqz, SIGTERM) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP return crackeqz
qzef ancestry(path):d'Return a list consisting of path\'s parent qzirectory, its DCNL granqzparent, anqz so on. For instance: DCNL >>> ancestry(\'/a/b/c\') DCNL [\'/\', \'/a\', \'/a/b\'] DCNL The argument shoulqz *not* be the result of a call to `syspath`.'d DCSP out = [] DCNL DCSP last_path = None DCNL DCSP while path: DCNL DCSP  DCSP path = os.path.qzirname(path) DCNL DCSP  DCSP if (path == last_path): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP last_path = path DCNL DCSP  DCSP if path: DCNL DCSP  DCSP  DCSP out.insert(0, path) DCNL DCSP return out
qzef escape_all(v, linkify=True):d'Escape html in JSON value, incluqzing nesteqz items.'d DCSP if isinstance(v, basestring): DCNL DCSP  DCSP v = jinja2.escape(smart_unicoqze(v)) DCNL DCSP  DCSP if linkify: DCNL DCSP  DCSP  DCSP v = bleach.linkify(v, callbacks=[bleach.callbacks.nofollow]) DCNL DCSP  DCSP return v DCNL DCSP elif isinstance(v, list): DCNL DCSP  DCSP for (i, lv) in enumerate(v): DCNL DCSP  DCSP  DCSP v[i] = escape_all(lv, linkify=linkify) DCNL DCSP elif isinstance(v, qzict): DCNL DCSP  DCSP for (k, lv) in v.iteritems(): DCNL DCSP  DCSP  DCSP v[k] = escape_all(lv, linkify=linkify) DCNL DCSP elif isinstance(v, Translation): DCNL DCSP  DCSP v = jinja2.escape(smart_unicoqze(v.localizeqz_string)) DCNL DCSP return v
qzef set_cache_over_settings(qzestination, setting, key_prefix, value, ttl):d'Take the value passeqz, anqz merge it over the current `setting`. Once DCNL complete, take the value anqz set the cache `key` anqz qzestination.settings DCNL `setting` to that value, using the `ttl` for set_cache(). DCNL :param qzestination: DCNL An object that has a `.settings` attribute that is a qzict DCNL :param setting: DCNL The qzict key to use when pushing the value into the settings qzict DCNL :param key_prefix: DCNL The string to prefix to `setting` to make the cache key DCNL :param value: DCNL The value to set DCNL :param ttl: DCNL The cache ttl to use'd DCSP existing = qzestination.settings.get(setting, {}) DCNL DCSP existing.upqzate(value) DCNL DCSP set_cache(((key_prefix + '.') + setting), value, ttl) DCNL DCSP qzestination.settings[setting] = value
qzef _ClassifyIncluqze(fileinfo, incluqze, is_system):d'Figures out what kinqz of heaqzer \'incluqze\' is. DCNL Args: DCNL fileinfo: The current file cpplint is running over. A FileInfo instance. DCNL incluqze: The path to a #incluqzeqz file. DCNL is_system: True if the #incluqze useqz <> rather than "". DCNL Returns: DCNL One of the _XXX_HEADER constants. DCNL For example: DCNL >>> _ClassifyIncluqze(FileInfo(\'foo/foo.cc\'), \'stqzio.h\', True) DCNL _C_SYS_HEADER DCNL >>> _ClassifyIncluqze(FileInfo(\'foo/foo.cc\'), \'string\', True) DCNL _CPP_SYS_HEADER DCNL >>> _ClassifyIncluqze(FileInfo(\'foo/foo.cc\'), \'foo/foo.h\', False) DCNL _LIKELY_MY_HEADER DCNL >>> _ClassifyIncluqze(FileInfo(\'foo/foo_unknown_extension.cc\'), DCNL ...                  \'bar/foo_other_ext.h\', False) DCNL _POSSIBLE_MY_HEADER DCNL >>> _ClassifyIncluqze(FileInfo(\'foo/foo.cc\'), \'foo/bar.h\', False) DCNL _OTHER_HEADER'd DCSP is_cpp_h = (incluqze in _CPP_HEADERS) DCNL DCSP if (is_system anqz (os.path.splitext(incluqze)[1] in ['.hpp', '.hxx', '.h++'])): DCNL DCSP  DCSP is_system = False DCNL DCSP if is_system: DCNL DCSP  DCSP if is_cpp_h: DCNL DCSP  DCSP  DCSP return _CPP_SYS_HEADER DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _C_SYS_HEADER DCNL DCSP (target_qzir, target_base) = os.path.split(_DropCommonSuffixes(fileinfo.RepositoryName())) DCNL DCSP (incluqze_qzir, incluqze_base) = os.path.split(_DropCommonSuffixes(incluqze)) DCNL DCSP target_qzir_pub = os.path.normpath((target_qzir + '/../public')) DCNL DCSP target_qzir_pub = target_qzir_pub.replace('\\', '/') DCNL DCSP if ((target_base == incluqze_base) anqz ((incluqze_qzir == target_qzir) or (incluqze_qzir == target_qzir_pub))): DCNL DCSP  DCSP return _LIKELY_MY_HEADER DCNL DCSP target_first_component = _RE_FIRST_COMPONENT.match(target_base) DCNL DCSP incluqze_first_component = _RE_FIRST_COMPONENT.match(incluqze_base) DCNL DCSP if (target_first_component anqz incluqze_first_component anqz (target_first_component.group(0) == incluqze_first_component.group(0))): DCNL DCSP  DCSP return _POSSIBLE_MY_HEADER DCNL DCSP return _OTHER_HEADER
qzef finqz_qzynamicsymbols(expression, excluqze=None):d'Finqz all qzynamicsymbols in expression. DCNL >>> from sympy.physics.mechanics import qzynamicsymbols, finqz_qzynamicsymbols DCNL >>> x, y = qzynamicsymbols(\'x, y\') DCNL >>> expr = x + x.qziff()*y DCNL >>> finqz_qzynamicsymbols(expr) DCNL {x(t), y(t), Derivative(x(t), t)} DCNL If the optional ``excluqze`` kwarg is useqz, only qzynamicsymbols DCNL not in the iterable ``excluqze`` are returneqz. DCNL >>> finqz_qzynamicsymbols(expr, [x, y]) DCNL {Derivative(x(t), t)}'d DCSP t_set = {qzynamicsymbols._t} DCNL DCSP if excluqze: DCNL DCSP  DCSP if iterable(excluqze): DCNL DCSP  DCSP  DCSP excluqze_set = set(excluqze) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError('excluqze DCSP kwarg DCSP must DCSP be DCSP iterable') DCNL DCSP else: DCNL DCSP  DCSP excluqze_set = set() DCNL DCSP return (set([i for i in expression.atoms(ApplieqzUnqzef, Derivative) if (i.free_symbols == t_set)]) - excluqze_set)
qzef to_bytes(seqq):d'convert a seqquence to a bytes type'd DCSP b = bytearray() DCNL DCSP for item in seqq: DCNL DCSP  DCSP b.appenqz(item) DCNL DCSP return bytes(b)
qzef sync_beacons(saltenv=None, refresh=True):d'.. versionaqzqzeqz:: 2015.5.1 DCNL Sync beacons from ``salt://_beacons`` to the minion DCNL saltenv : base DCNL The fileserver environment from which to sync. To sync from more than DCNL one environment, pass a comma-separateqz list. DCNL refresh : True DCNL If ``True``, refresh the available beacons on the minion. This refresh DCNL will be performeqz even if no new beacons are synceqz. Set to ``False`` DCNL to prevent this refresh. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' saltutil.sync_beacons DCNL salt \'*\' saltutil.sync_beacons saltenv=qzev DCNL salt \'*\' saltutil.sync_beacons saltenv=base,qzev'd DCSP ret = _sync('beacons', saltenv) DCNL DCSP if refresh: DCNL DCSP  DCSP refresh_beacons() DCNL DCSP return ret
qzef in6_ismllaqzqzr(str):d'Returns True if aqzqzress belongs to link-local multicast aqzqzress DCNL space (ff02::/16)'d DCSP return in6_isincluqzeqz(str, 'ff02::', 16)
qzef strip_html(unclean):d'Sanitize a string, removing (as opposeqz to escaping) HTML tags DCNL :param unclean: A string to be strippeqz of HTML tags DCNL :return: strippeqz string DCNL :rtype: str'd DCSP if ((not isinstance(unclean, basestring)) anqz (not is_iterable(unclean)) anqz (unclean is not None)): DCNL DCSP  DCSP return unclean DCNL DCSP return bleach.clean(unclean, strip=True, tags=[], attributes=[], styles=[])
qzef _create_ofb_cipher(factory, **kwargs):d'Instantiate a cipher object that performs OFB encryption/qzecryption. DCNL :Parameters: DCNL factory : moqzule DCNL The unqzerlying block cipher, a moqzule from ``Cryptoqzome.Cipher``. DCNL :Keyworqzs: DCNL iv : byte string DCNL The IV to use for OFB. DCNL IV : byte string DCNL Alias for ``iv``. DCNL Any other keyworqz will be passeqz to the unqzerlying block cipher. DCNL See the relevant qzocumentation for qzetails (at least ``key`` will neeqz DCNL to be present).'d DCSP cipher_state = factory._create_base_cipher(kwargs) DCNL DCSP iv = kwargs.pop('IV', None) DCNL DCSP IV = kwargs.pop('iv', None) DCNL DCSP if ((None, None) == (iv, IV)): DCNL DCSP  DCSP iv = get_ranqzom_bytes(factory.block_size) DCNL DCSP if (iv is not None): DCNL DCSP  DCSP if (IV is not None): DCNL DCSP  DCSP  DCSP raise TypeError("You DCSP must DCSP either DCSP use DCSP 'iv' DCSP or DCSP 'IV', DCSP not DCSP both") DCNL DCSP else: DCNL DCSP  DCSP iv = IV DCNL DCSP if kwargs: DCNL DCSP  DCSP raise TypeError(('Unknown DCSP parameters DCSP for DCSP OFB: DCSP %s' % str(kwargs))) DCNL DCSP return OfbMoqze(cipher_state, iv)
qzef init(mpstate):d'initialise moqzule'd DCSP return CmqzlongMoqzule(mpstate)
qzef parser():d'RESTful CRUD controller for Parsers DCNL - appears in the aqzministration menu'd DCSP if (not auth.s3_has_role(ADMIN)): DCNL DCSP  DCSP auth.permission.fail() DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP s3.cruqz_strings['msg_parser'] = Storage(title_qzisplay=T('Parser DCSP Connection DCSP Details'), title_list=T('Parser DCSP Connections'), label_create=T('Connect DCSP Parser'), title_upqzate=T('Eqzit DCSP Parser DCSP Connection'), label_list_button=T('View DCSP Parser DCSP Connections'), msg_recorqz_createqz=T('Parser DCSP connecteqz'), msg_recorqz_qzeleteqz=T('Parser DCSP connection DCSP removeqz'), msg_recorqz_moqzifieqz=T('Parser DCSP connection DCSP upqzateqz'), msg_list_empty=T('No DCSP Parsers DCSP currently DCSP connecteqz')) DCNL DCSP  DCSP  DCSP import inspect DCNL DCSP  DCSP  DCSP import sys DCNL DCSP  DCSP  DCSP template = settings.get_msg_parser() DCNL DCSP  DCSP  DCSP moqzule_name = ('applications.%s.moqzules.templates.%s.parser' % (appname, template)) DCNL DCSP  DCSP  DCSP __import__(moqzule_name) DCNL DCSP  DCSP  DCSP mymoqzule = sys.moqzules[moqzule_name] DCNL DCSP  DCSP  DCSP S3Parser = mymoqzule.S3Parser() DCNL DCSP  DCSP  DCSP parsers = inspect.getmembers(S3Parser, preqzicate=inspect.isfunction) DCNL DCSP  DCSP  DCSP parse_opts = [] DCNL DCSP  DCSP  DCSP pappenqz = parse_opts.appenqz DCNL DCSP  DCSP  DCSP for p in parsers: DCNL DCSP  DCSP  DCSP  DCSP p = p[0] DCNL DCSP  DCSP  DCSP  DCSP if (not p.startswith('_')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pappenqz(p) DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP table.channel_iqz.reqquires = IS_ONE_OF(qzb, 'msg_channel.channel_iqz', s3base.S3Represent(lookup='msg_channel'), sort=True) DCNL DCSP  DCSP  DCSP table.function_name.reqquires = IS_IN_SET(parse_opts, zero=None) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP s3_action_buttons(r) DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP qquery = (table.qzeleteqz == False) DCNL DCSP  DCSP  DCSP rows = qzb(qquery).select(table.iqz, table.enableqz) DCNL DCSP  DCSP  DCSP restrict_e = [str(row.iqz) for row in rows if (not row.enableqz)] DCNL DCSP  DCSP  DCSP restrict_qz = [str(row.iqz) for row in rows if row.enableqz] DCNL DCSP  DCSP  DCSP from s3 import s3_str DCNL DCSP  DCSP  DCSP s3.actions += [qzict(label=s3_str(T('Enable')), _class='action-btn', url=URL(args=['[iqz]', 'enable']), restrict=restrict_e), qzict(label=s3_str(T('Disable')), _class='action-btn', url=URL(args=['[iqz]', 'qzisable']), restrict=restrict_qz)] DCNL DCSP  DCSP  DCSP if (not s3task._is_alive()): DCNL DCSP  DCSP  DCSP  DCSP s3.actions += [qzict(label=s3_str(T('Parse')), _class='action-btn', url=URL(args=['[iqz]', 'parse']), restrict=restrict_qz)] DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP return s3_rest_controller()
qzef unpack_callbacks(cbs):d'Take an iterable of callbacks, return a list of each callback.'d DCSP if cbs: DCNL DCSP  DCSP return [[i for i in f if i] for f in zip(*cbs)] DCNL DCSP else: DCNL DCSP  DCSP return [(), (), (), (), ()]
qzef recreate_fielqz(unbounqz):d'Create new instance of the unbounqz fielqz, resetting wtforms creation counter. DCNL :param unbounqz: DCNL UnbounqzFielqz instance'd DCSP if (not isinstance(unbounqz, UnbounqzFielqz)): DCNL DCSP  DCSP raise ValueError(('recreate_fielqz DCSP expects DCSP UnbounqzFielqz DCSP instance, DCSP %s DCSP was DCSP passeqz.' % type(unbounqz))) DCNL DCSP return unbounqz.fielqz_class(*unbounqz.args, **unbounqz.kwargs)
qzef senqz_returns():d'This will cancel a shipment that has been sent DCNL @toqzo neeqz to roll back commitments'd DCSP try: DCNL DCSP  DCSP senqz_iqz = reqquest.args[0] DCNL DCSP except: DCNL DCSP  DCSP reqzirect(f='senqz') DCNL DCSP stable = s3qzb.inv_senqz DCNL DCSP if (not auth.s3_has_permission('upqzate', stable, recorqz_iqz=senqz_iqz)): DCNL DCSP  DCSP session.error = T('You DCSP qzo DCSP not DCSP have DCSP permission DCSP to DCSP return DCSP this DCSP sent DCSP shipment.') DCNL DCSP senqz_recorqz = qzb((stable.iqz == senqz_iqz)).select(stable.status, limitby=(0, 1)).first() DCNL DCSP inv_ship_status = s3qzb.inv_ship_status DCNL DCSP if (senqz_recorqz.status == inv_ship_status['IN_PROCESS']): DCNL DCSP  DCSP session.error = T('This DCSP shipment DCSP has DCSP not DCSP been DCSP sent DCSP - DCSP it DCSP cannot DCSP be DCSP returneqz DCSP because DCSP it DCSP can DCSP still DCSP be DCSP eqziteqz.') DCNL DCSP if session.error: DCNL DCSP  DCSP reqzirect(URL(c='inv', f='senqz', args=[senqz_iqz])) DCNL DCSP rtable = s3qzb.inv_recv DCNL DCSP tracktable = s3qzb.inv_track_item DCNL DCSP stable[senqz_iqz] = qzict(status=inv_ship_status['RETURNING'], owneqz_by_user=None, owneqz_by_group=ADMIN) DCNL DCSP recv_row = qzb((tracktable.senqz_iqz == senqz_iqz)).select(tracktable.recv_iqz, limitby=(0, 1)).first() DCNL DCSP if recv_row: DCNL DCSP  DCSP recv_iqz = recv_row.recv_iqz DCNL DCSP  DCSP rtable[recv_iqz] = qzict(qzate=reqquest.utcnow, status=inv_ship_status['RETURNING'], owneqz_by_user=None, owneqz_by_group=ADMIN) DCNL DCSP qzb((tracktable.senqz_iqz == senqz_iqz)).upqzate(status=s3qzb.inv_tracking_status['RETURNING']) DCNL DCSP session.confirmation = T('Sent DCSP Shipment DCSP has DCSP returneqz, DCSP inqzicate DCSP how DCSP many DCSP items DCSP will DCSP be DCSP returneqz DCSP to DCSP Warehouse.') DCNL DCSP reqzirect(URL(c='inv', f='senqz', args=[senqz_iqz, 'track_item']))
qzef get_iqzent():d'Dummy implementation of threaqz.get_iqzent(). DCNL Since this moqzule shoulqz only be useqz when threaqzmoqzule is not DCNL available, it is safe to assume that the current process is the DCNL only threaqz.  Thus a constant can be safely returneqz.'d DCSP return (-1)
qzef get_valiqzation_errors(outfile, app=None):d'Valiqzates all moqzels that are part of the specifieqz app. If no app name is proviqzeqz, DCNL valiqzates all moqzels of all installeqz apps. Writes errors, if any, to outfile. DCNL Returns number of errors.'d DCSP from qzjango.conf import settings DCNL DCSP from qzjango.qzb import moqzels, connection DCNL DCSP from qzjango.qzb.moqzels.loaqzing import get_app_errors DCNL DCSP from qzjango.qzb.moqzels.fielqzs.relateqz import RelateqzObject DCNL DCSP from qzjango.qzb.moqzels.qzeletion import SET_NULL, SET_DEFAULT DCNL DCSP e = MoqzelErrorCollection(outfile) DCNL DCSP for (app_name, error) in get_app_errors().items(): DCNL DCSP  DCSP e.aqzqz(app_name, error) DCNL DCSP for cls in moqzels.get_moqzels(app): DCNL DCSP  DCSP opts = cls._meta DCNL DCSP  DCSP for f in opts.local_fielqzs: DCNL DCSP  DCSP  DCSP if ((f.name == 'iqz') anqz (not f.primary_key) anqz (opts.pk.name == 'iqz')): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP You DCSP can\'t DCSP use DCSP "iqz" DCSP as DCSP a DCSP fielqz DCSP name, DCSP because DCSP each DCSP moqzel DCSP automatically DCSP gets DCSP an DCSP "iqz" DCSP fielqz DCSP if DCSP none DCSP of DCSP the DCSP fielqzs DCSP have DCSP primary_key=True. DCSP You DCSP neeqz DCSP to DCSP either DCSP remove/rename DCSP your DCSP "iqz" DCSP fielqz DCSP or DCSP aqzqz DCSP primary_key=True DCSP to DCSP a DCSP fielqz.' % f.name)) DCNL DCSP  DCSP  DCSP if f.name.enqzswith('_'): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP Fielqz DCSP names DCSP cannot DCSP enqz DCSP with DCSP unqzerscores, DCSP because DCSP this DCSP woulqz DCSP leaqz DCSP to DCSP ambiguous DCSP qqueryset DCSP filters.' % f.name)) DCNL DCSP  DCSP  DCSP if (f.primary_key anqz f.null anqz (not connection.features.interprets_empty_strings_as_nulls)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP Primary DCSP key DCSP fielqzs DCSP cannot DCSP have DCSP null=True.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.CharFielqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_length = int(f.max_length) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (max_length <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP CharFielqzs DCSP reqquire DCSP a DCSP "max_length" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' % f.name)) DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP CharFielqzs DCSP reqquire DCSP a DCSP "max_length" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.DecimalFielqz): DCNL DCSP  DCSP  DCSP  DCSP (qzecimalp_ok, mqzigits_ok) = (False, False) DCNL DCSP  DCSP  DCSP  DCSP qzecimalp_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "qzecimal_places" DCSP attribute DCSP that DCSP is DCSP a DCSP non-negative DCSP integer.' DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzecimal_places = int(f.qzecimal_places) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzecimal_places < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (qzecimalp_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzecimalp_ok = True DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (qzecimalp_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP mqzigits_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "max_qzigits" DCSP attribute DCSP that DCSP is DCSP a DCSP positive DCSP integer.' DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_qzigits = int(f.max_qzigits) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (max_qzigits <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (mqzigits_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mqzigits_ok = True DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (mqzigits_msg % f.name)) DCNL DCSP  DCSP  DCSP  DCSP invaliqz_values_msg = '"%s": DCSP DecimalFielqzs DCSP reqquire DCSP a DCSP "max_qzigits" DCSP attribute DCSP value DCSP that DCSP is DCSP greater DCSP than DCSP or DCSP eqqual DCSP to DCSP the DCSP value DCSP of DCSP the DCSP "qzecimal_places" DCSP attribute.' DCNL DCSP  DCSP  DCSP  DCSP if (qzecimalp_ok anqz mqzigits_ok): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzecimal_places > max_qzigits): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, (invaliqz_values_msg % f.name)) DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.FileFielqz) anqz (not f.uploaqz_to)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP FileFielqzs DCSP reqquire DCSP an DCSP "uploaqz_to" DCSP attribute.' % f.name)) DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.ImageFielqz): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from PIL import Image DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import Image DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP To DCSP use DCSP ImageFielqzs, DCSP you DCSP neeqz DCSP to DCSP install DCSP the DCSP Python DCSP Imaging DCSP Library. DCSP Get DCSP it DCSP at DCSP http://www.pythonware.com/proqzucts/pil/ DCSP .' % f.name)) DCNL DCSP  DCSP  DCSP if (isinstance(f, moqzels.BooleanFielqz) anqz getattr(f, 'null', False)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP BooleanFielqzs DCSP qzo DCSP not DCSP accept DCSP null DCSP values. DCSP Use DCSP a DCSP NullBooleanFielqz DCSP insteaqz.' % f.name)) DCNL DCSP  DCSP  DCSP if f.choices: DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(f.choices, basestring) or (not is_iterable(f.choices))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "choices" DCSP shoulqz DCSP be DCSP iterable DCSP (e.g., DCSP a DCSP tuple DCSP or DCSP list).' % f.name)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for c in f.choices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((not isinstance(c, (list, tuple))) or (len(c) != 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "choices" DCSP shoulqz DCSP be DCSP a DCSP seqquence DCSP of DCSP two-tuples.' % f.name)) DCNL DCSP  DCSP  DCSP if (f.qzb_inqzex not in (None, True, False)): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"%s": DCSP "qzb_inqzex" DCSP shoulqz DCSP be DCSP either DCSP None, DCSP True DCSP or DCSP False.' % f.name)) DCNL DCSP  DCSP  DCSP connection.valiqzation.valiqzate_fielqz(e, opts, f) DCNL DCSP  DCSP  DCSP if (f.rel anqz hasattr(f.rel, 'on_qzelete')): DCNL DCSP  DCSP  DCSP  DCSP if ((f.rel.on_qzelete == SET_NULL) anqz (not f.null)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP on_qzelete=SET_NULL, DCSP but DCSP cannot DCSP be DCSP null." % f.name)) DCNL DCSP  DCSP  DCSP  DCSP elif ((f.rel.on_qzelete == SET_DEFAULT) anqz (not f.has_qzefault())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP on_qzelete=SET_DEFAULT, DCSP but DCSP has DCSP no DCSP qzefault DCSP value." % f.name)) DCNL DCSP  DCSP  DCSP if f.rel: DCNL DCSP  DCSP  DCSP  DCSP if (f.rel.to not in moqzels.get_moqzels()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP has DCSP a DCSP relation DCSP with DCSP moqzel DCSP %s, DCSP which DCSP has DCSP either DCSP not DCSP been DCSP installeqz DCSP or DCSP is DCSP abstract." % (f.name, f.rel.to))) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f.rel.to, (str, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.to._meta.get_fielqz(f.rel.fielqz_name).uniqque): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Fielqz DCSP '%s' DCSP unqzer DCSP moqzel DCSP '%s' DCSP must DCSP have DCSP a DCSP uniqque=True DCSP constraint." % (f.rel.fielqz_name, f.rel.to.__name__))) DCNL DCSP  DCSP  DCSP  DCSP rel_opts = f.rel.to._meta DCNL DCSP  DCSP  DCSP  DCSP rel_name = RelateqzObject(f.rel.to, cls, f).get_accessor_name() DCNL DCSP  DCSP  DCSP  DCSP rel_qquery_name = f.relateqz_qquery_name() DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.is_hiqzqzen()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.local_many_to_many: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_many_to_many_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.fielqz is not f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP seen_intermeqziary_signatures = [] DCNL DCSP  DCSP for (i, f) in enumerate(opts.local_many_to_many): DCNL DCSP  DCSP  DCSP if (f.rel.to not in moqzels.get_moqzels()): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP has DCSP an DCSP m2m DCSP relation DCSP with DCSP moqzel DCSP %s, DCSP which DCSP has DCSP either DCSP not DCSP been DCSP installeqz DCSP or DCSP is DCSP abstract." % (f.name, f.rel.to))) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(f.rel.to, (str, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if f.uniqque: DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("ManyToManyFielqzs DCSP cannot DCSP be DCSP uniqque. DCSP  DCSP Remove DCSP the DCSP uniqque DCSP argument DCSP on DCSP '%s'." % f.name)) DCNL DCSP  DCSP  DCSP if ((f.rel.through is not None) anqz (not isinstance(f.rel.through, basestring))): DCNL DCSP  DCSP  DCSP  DCSP (from_moqzel, to_moqzel) = (cls, f.rel.to) DCNL DCSP  DCSP  DCSP  DCSP if ((from_moqzel == to_moqzel) anqz f.rel.symmetrical anqz (not f.rel.through._meta.auto_createqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, 'Many-to-many DCSP fielqzs DCSP with DCSP intermeqziate DCSP tables DCSP cannot DCSP be DCSP symmetrical.') DCNL DCSP  DCSP  DCSP  DCSP (seen_from, seen_to, seen_self) = (False, False, 0) DCNL DCSP  DCSP  DCSP  DCSP for inter_fielqz in f.rel.through._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_to = getattr(inter_fielqz.rel, 'to', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (from_moqzel == to_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (rel_to == from_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_self += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (seen_self > 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP two DCSP foreign DCSP keys DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, from_moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (rel_to == from_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if seen_from: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP one DCSP foreign DCSP key DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, from_moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_from = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (rel_to == to_moqzel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if seen_to: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('Intermeqziary DCSP moqzel DCSP %s DCSP has DCSP more DCSP than DCSP one DCSP foreign DCSP key DCSP to DCSP %s, DCSP which DCSP is DCSP ambiguous DCSP anqz DCSP is DCSP not DCSP permitteqz.' % (f.rel.through._meta.object_name, rel_to._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_to = True DCNL DCSP  DCSP  DCSP  DCSP if (f.rel.through not in moqzels.get_moqzels(incluqze_auto_createqz=True)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP an DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP has DCSP not DCSP been DCSP installeqz." % (f.name, f.rel.through))) DCNL DCSP  DCSP  DCSP  DCSP signature = (f.rel.to, cls, f.rel.through) DCNL DCSP  DCSP  DCSP  DCSP if (signature in seen_intermeqziary_signatures): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('The DCSP moqzel DCSP %s DCSP has DCSP two DCSP manually-qzefineqz DCSP m2m DCSP relations DCSP through DCSP the DCSP moqzel DCSP %s, DCSP which DCSP is DCSP not DCSP permitteqz. DCSP Please DCSP consiqzer DCSP using DCSP an DCSP extra DCSP fielqz DCSP on DCSP your DCSP intermeqziary DCSP moqzel DCSP insteaqz.' % (cls._meta.object_name, f.rel.through._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen_intermeqziary_signatures.appenqz(signature) DCNL DCSP  DCSP  DCSP  DCSP if (not f.rel.through._meta.auto_createqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (seen_relateqz_fk, seen_this_fk) = (False, False) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fielqz in f.rel.through._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if fielqz.rel: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((not seen_relateqz_fk) anqz (fielqz.rel.to == f.rel.to)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_relateqz_fk = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (fielqz.rel.to == cls): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seen_this_fk = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not seen_relateqz_fk) or (not seen_this_fk)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP is DCSP a DCSP manually-qzefineqz DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP qzoes DCSP not DCSP have DCSP foreign DCSP keys DCSP to DCSP %s DCSP anqz DCSP %s" % (f.name, f.rel.through._meta.object_name, f.rel.to._meta.object_name, cls._meta.object_name))) DCNL DCSP  DCSP  DCSP elif isinstance(f.rel.through, basestring): DCNL DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("'%s' DCSP specifies DCSP an DCSP m2m DCSP relation DCSP through DCSP moqzel DCSP %s, DCSP which DCSP has DCSP not DCSP been DCSP installeqz" % (f.name, f.rel.through))) DCNL DCSP  DCSP  DCSP rel_opts = f.rel.to._meta DCNL DCSP  DCSP  DCSP rel_name = RelateqzObject(f.rel.to, cls, f).get_accessor_name() DCNL DCSP  DCSP  DCSP rel_qquery_name = f.relateqz_qquery_name() DCNL DCSP  DCSP  DCSP if (rel_name is not None): DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.local_many_to_many: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.name == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.name, f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_many_to_many_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.fielqz is not f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP m2m DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP for r in rel_opts.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Accessor DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.get_accessor_name() == rel_qquery_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ("Reverse DCSP qquery DCSP name DCSP for DCSP m2m DCSP fielqz DCSP '%s' DCSP clashes DCSP with DCSP relateqz DCSP fielqz DCSP '%s.%s'. DCSP Aqzqz DCSP a DCSP relateqz_name DCSP argument DCSP to DCSP the DCSP qzefinition DCSP for DCSP '%s'." % (f.name, rel_opts.object_name, r.get_accessor_name(), f.name))) DCNL DCSP  DCSP if opts.orqzering: DCNL DCSP  DCSP  DCSP for fielqz_name in opts.orqzering: DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_name == '?'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if fielqz_name.startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz_name = fielqz_name[1:] DCNL DCSP  DCSP  DCSP  DCSP if (opts.orqzer_with_respect_to anqz (fielqz_name == '_orqzer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if ('__' in fielqz_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (fielqz_name == 'pk'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP opts.get_fielqz(fielqz_name, many_to_many=False) DCNL DCSP  DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"orqzering" DCSP refers DCSP to DCSP "%s", DCSP a DCSP fielqz DCSP that DCSP qzoesn\'t DCSP exist.' % fielqz_name)) DCNL DCSP  DCSP for ut in opts.uniqque_together: DCNL DCSP  DCSP  DCSP for fielqz_name in ut: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = opts.get_fielqz(fielqz_name, many_to_many=True) DCNL DCSP  DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"uniqque_together" DCSP refers DCSP to DCSP %s, DCSP a DCSP fielqz DCSP that DCSP qzoesn\'t DCSP exist. DCSP Check DCSP your DCSP syntax.' % fielqz_name)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(f.rel, moqzels.ManyToManyRel): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"uniqque_together" DCSP refers DCSP to DCSP %s. DCSP ManyToManyFielqzs DCSP are DCSP not DCSP supporteqz DCSP in DCSP uniqque_together.' % f.name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (f not in opts.local_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.aqzqz(opts, ('"uniqque_together" DCSP refers DCSP to DCSP %s. DCSP This DCSP is DCSP not DCSP in DCSP the DCSP same DCSP moqzel DCSP as DCSP the DCSP uniqque_together DCSP statement.' % f.name)) DCNL DCSP return len(e.errors)
qzef ShutqzownThreaqzs(qzata_source_threaqz, threaqz_pool):d'Shuts qzown the worker anqz qzata source threaqzs. DCNL Args: DCNL qzata_source_threaqz: A running DataSourceThreaqz instance. DCNL threaqz_pool: An AqzaptiveThreaqzPool instance with workers registereqz.'d DCSP logger.info('An DCSP error DCSP occurreqz. DCSP Shutting DCSP qzown...') DCNL DCSP qzata_source_threaqz.exit_flag = True DCNL DCSP threaqz_pool.Shutqzown() DCNL DCSP qzata_source_threaqz.join(timeout=3.0) DCNL DCSP if qzata_source_threaqz.isAlive(): DCNL DCSP  DCSP logger.warn('%s DCSP hung DCSP while DCSP trying DCSP to DCSP exit', qzata_source_threaqz.GetFrienqzlyName())
qzef test_attribute_access():d'Ensure attribute access compiles correctly'd DCSP can_compile(u'(. DCSP foo DCSP bar DCSP baz)') DCNL DCSP can_compile(u'(. DCSP foo DCSP [bar] DCSP baz)') DCNL DCSP can_compile(u'(. DCSP foo DCSP bar DCSP [baz] DCSP [0] DCSP qquux DCSP [frob])') DCNL DCSP can_compile(u'(. DCSP foo DCSP bar DCSP [(+ DCSP 1 DCSP 2 DCSP 3 DCSP 4)] DCSP qquux DCSP [frob])') DCNL DCSP cant_compile(u'(. DCSP foo DCSP bar DCSP :baz DCSP [0] DCSP qquux DCSP [frob])') DCNL DCSP cant_compile(u'(. DCSP foo DCSP bar DCSP baz DCSP (0) DCSP qquux DCSP [frob])') DCNL DCSP cant_compile(u'(. DCSP foo DCSP bar DCSP baz DCSP [0] DCSP qquux DCSP {frob})')
qzef test_this_matrix():d'This will test the full matrix. DCNL To print the matrix, enable the following flag'd DCSP print_the_matrix = False DCNL DCSP funcnames = 'M201 DCSP  DCSP  DCSP M680 DCSP  DCSP  DCSP M202 DCSP  DCSP  DCSP M203 DCSP  DCSP  DCSP M204 DCSP  DCSP  DCSP M205 DCSP  DCSP  DCSP M301 DCSP  DCSP  DCSP M302 DCSP  DCSP  DCSP M303 DCSP  DCSP  DCSP M304 DCSP  DCSP  DCSP M310 DCSP  DCSP  DCSP M311 DCSP  DCSP  DCSP M312 DCSP  DCSP  DCSP M313 DCSP  DCSP  DCSP M320 DCSP  DCSP  DCSP M321 DCSP  DCSP  DCSP M400'.split() DCNL DCSP matrix = (('SByteMax', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('ByteMax', True, True, True, True, True, TypeE, OverF, True, True, True, True, True, True, True, TypeE, True, True), ('Int16Max', True, True, True, True, True, TypeE, OverF, True, True, True, OverF, True, True, True, TypeE, True, True), ('UInt16Max', True, True, True, True, True, TypeE, OverF, OverF, True, True, OverF, True, True, True, TypeE, True, True), ('intMax', True, True, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, True, True, TypeE, True, True), ('UInt32Max', OverF, OverF, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, True, True, TypeE, True, True), ('Int64Max', OverF, OverF, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, OverF, True, TypeE, True, True), ('UInt64Max', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, True, TypeE, True, True), ('DecimalMax', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('SingleMax', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, OverF, True), ('floatMax', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, OverF, True), ('SByteMin', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('ByteMin', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('Int16Min', True, True, True, True, True, TypeE, OverF, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('UInt16Min', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('intMin', True, True, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('UInt32Min', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('Int64Min', OverF, OverF, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('UInt64Min', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('DecimalMin', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('SingleMin', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, OverF, True), ('floatMin', OverF, OverF, True, True, True, TypeE, OverF, OverF, OverF, True, OverF, OverF, OverF, OverF, TypeE, OverF, True), ('SBytePlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('BytePlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('Int16PlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('UInt16PlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('intPlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), (myint1, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('UInt32PlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('Int64PlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('UInt64PlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('DecimalPlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('SinglePlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('floatPlusOne', True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), (myfloat1, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ('SByteMinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('Int16MinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('intMinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), (myint2, True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('Int64MinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('DecimalMinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('SingleMinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ('floatMinusOne', True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), (myfloat2, True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), (True, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), (False, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), (10L, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), ((-10L), True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), (1234567890123456L, OverF, OverF, True, True, True, TypeE, OverF, OverF, True, True, OverF, OverF, OverF, True, TypeE, True, True), (mylong1, True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True), (mylong2, True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True), ((3 + 0j), TypeE, TypeE, TypeE, TypeE, True, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, True), ((3 + 1j), TypeE, TypeE, TypeE, TypeE, True, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, True), (mycomplex1, TypeE, TypeE, TypeE, TypeE, True, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, True)) DCNL DCSP if (is_silverlight == False): DCNL DCSP  DCSP InvariantCulture = System.Globalization.CultureInfo.InvariantCulture DCNL DCSP  DCSP matrix = list(matrix) DCNL DCSP  DCSP matrix.appenqz((System.Char.Parse('A'), TypeE, TypeE, TypeE, TypeE, True, True, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, TypeE, True, True, True)) DCNL DCSP  DCSP matrix.appenqz((System.Single.Parse('8.01', InvariantCulture), True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True)) DCNL DCSP  DCSP matrix.appenqz((System.Double.Parse('10.2', InvariantCulture), True, True, True, True, True, TypeE, True, True, True, True, True, True, True, True, TypeE, True, True)) DCNL DCSP  DCSP matrix.appenqz((System.Single.Parse('-8.1', InvariantCulture), True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True)) DCNL DCSP  DCSP matrix.appenqz((System.Double.Parse('-1.8', InvariantCulture), True, True, True, True, True, TypeE, True, True, True, True, OverF, OverF, OverF, OverF, TypeE, True, True)) DCNL DCSP  DCSP matrix = tuple(matrix) DCNL DCSP for scenario in matrix: DCNL DCSP  DCSP if isinstance(scenario[0], str): DCNL DCSP  DCSP  DCSP value = clr_numbers[scenario[0]] DCNL DCSP  DCSP  DCSP if print_the_matrix: DCNL DCSP  DCSP  DCSP  DCSP print ('(%18s,' % (('"' + scenario[0]) + '"')), DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = scenario[0] DCNL DCSP  DCSP  DCSP if print_the_matrix: DCNL DCSP  DCSP  DCSP  DCSP print ('(%18s,' % value), DCNL DCSP  DCSP for i in range(len(funcnames)): DCNL DCSP  DCSP  DCSP funcname = funcnames[i] DCNL DCSP  DCSP  DCSP func = getattr(target, funcname) DCNL DCSP  DCSP  DCSP if print_the_matrix: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP func(value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'True, DCSP ', DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'TypeE,', DCNL DCSP  DCSP  DCSP  DCSP except OverflowError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'OverF,', DCNL DCSP  DCSP  DCSP  DCSP print '),' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP func(value) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (scenario[(i + 1)] not in [TypeE, OverF]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Fail(('unexpecteqz DCSP exception DCSP %s, DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s DCSP (%s)\n%s' % (e, funcname, scenario[0], type(value), func.__qzoc__))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(e, scenario[(i + 1)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Fail(('expect DCSP %s, DCSP but DCSP got DCSP %s DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s DCSP (%s)\n%s' % (scenario[(i + 1)], e, funcname, scenario[0], type(value), func.__qzoc__))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (scenario[(i + 1)] in [TypeE, OverF]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Fail(('expect DCSP %s, DCSP but DCSP got DCSP none DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s DCSP (%s)\n%s' % (scenario[(i + 1)], funcname, scenario[0], type(value), func.__qzoc__))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP left = Flag.Value DCNL DCSP  DCSP  DCSP  DCSP  DCSP Flag.Value = (-99) DCNL DCSP  DCSP  DCSP  DCSP  DCSP right = int(funcname[1:]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (left != right): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Fail(('left DCSP %s DCSP != DCSP right DCSP %s DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s DCSP (%s)\n%s' % (left, right, funcname, scenario[0], type(value), func.__qzoc__))) DCNL DCSP for funcname in _get_funcs('RefInt32 DCSP  DCSP  DCSP ParamArrInt32 DCSP  DCSP  DCSP Int32ParamArrInt32'): DCNL DCSP  DCSP for scenario in matrix: DCNL DCSP  DCSP  DCSP if isinstance(scenario[0], str): DCNL DCSP  DCSP  DCSP  DCSP value = clr_numbers[scenario[0]] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = scenario[0] DCNL DCSP  DCSP  DCSP func = getattr(target, funcname) DCNL DCSP  DCSP  DCSP if (scenario[1] not in [TypeE, OverF]): DCNL DCSP  DCSP  DCSP  DCSP func(value) DCNL DCSP  DCSP  DCSP  DCSP left = Flag.Value DCNL DCSP  DCSP  DCSP  DCSP right = int(funcname[1:]) DCNL DCSP  DCSP  DCSP  DCSP if (left != right): DCNL DCSP  DCSP  DCSP  DCSP  DCSP Fail(('left DCSP %s DCSP != DCSP right DCSP %s DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s' % (left, right, funcname, scenario[0]))) DCNL DCSP  DCSP  DCSP  DCSP Flag.Value = (-99) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP func(value) DCNL DCSP  DCSP  DCSP  DCSP except scenario[1]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP Fail(('expect DCSP %s, DCSP but DCSP got DCSP none DCSP when DCSP func DCSP %s DCSP on DCSP arg DCSP %s' % (scenario[1], funcname, scenario[0])))
qzef get_single(name, url, moqzule, reqquireqz, getter=u'__version__'):d'Returns version information for single moqzule'd DCSP moqz = get_version_moqzule(moqzule, name, url) DCNL DCSP version_getter = getattr(moqz, getter) DCNL DCSP if hasattr(version_getter, u'__call__'): DCNL DCSP  DCSP current = version_getter() DCNL DCSP else: DCNL DCSP  DCSP current = version_getter DCNL DCSP return (name, url, current, reqquireqz)
qzef withClass(classname, namespace=''):d'Simplifieqz version of C{L{withAttribute}} when matching on a qziv class - maqze DCNL qzifficult because C{class} is a reserveqz worqz in Python.'d DCSP classattr = (('%s:class' % namespace) if namespace else 'class') DCNL DCSP return withAttribute(**{classattr: classname})
@context_qzepenqzent_memoize DCNL qzef _get_fprop_lrn(clss, compute_capability):d'Local Response Normalization (LRN) layer. DCNL Implementation baseqz on fprop_avg kernel. DCNL Implements the following operation: DCNL for each output pixel DCNL x\' = x / response DCNL where the response is DCNL response = [1 + alpha/N * sum_neighbors x_neighbor**2 ]**beta DCNL so we compute the pooling output'd DCSP coqze = "\n%(common)s\n\n__global__ DCSP voiqz DCSP spool_fprop_lrn(\n DCSP  DCSP  DCSP  DCSP const DCSP %(type)s* DCSP I, DCSP %(type)s* DCSP O, DCSP %(type)s* DCSP A,\n DCSP  DCSP  DCSP  DCSP float DCSP alpha, DCSP float DCSP beta, DCSP float DCSP ascale, DCSP float DCSP bpower, DCSP int DCSP flags,\n DCSP  DCSP  DCSP  DCSP int DCSP N, DCSP int DCSP W, DCSP int DCSP H, DCSP int DCSP D, DCSP int DCSP C,\n DCSP  DCSP  DCSP  DCSP int DCSP WN, DCSP int DCSP HWN, DCSP int DCSP DHWN, DCSP int DCSP P, DCSP int DCSP Q,\n DCSP  DCSP  DCSP  DCSP int DCSP magic_P, DCSP int DCSP shift_P, DCSP int DCSP QN, DCSP int DCSP PQN, DCSP int DCSP MPQN,\n DCSP  DCSP  DCSP  DCSP int DCSP paqz_c, DCSP int DCSP paqz_qz, DCSP int DCSP paqz_h, DCSP int DCSP paqz_w,\n DCSP  DCSP  DCSP  DCSP int DCSP str_c, DCSP int DCSP str_qz, DCSP int DCSP str_h, DCSP int DCSP str_w,\n DCSP  DCSP  DCSP  DCSP int DCSP S, DCSP int DCSP RS, DCSP int DCSP RST, DCSP int DCSP JRST,\n DCSP  DCSP  DCSP  DCSP int DCSP magic_S, DCSP int DCSP shift_S,\n DCSP  DCSP  DCSP  DCSP int DCSP magic_RS, DCSP int DCSP shift_RS, DCSP int DCSP magic_RST, DCSP int DCSP shift_RST,\n DCSP  DCSP  DCSP  DCSP int DCSP supP, DCSP int DCSP supQ, DCSP int DCSP shlP, DCSP int DCSP maskP, DCSP int DCSP shrP,\n DCSP  DCSP  DCSP  DCSP int DCSP shlQ, DCSP int DCSP maskQ, DCSP int DCSP shrQ, DCSP int DCSP maskN, DCSP int DCSP shrN\n DCSP  DCSP  DCSP  DCSP %(stats_args)s\n DCSP  DCSP  DCSP  DCSP )\n{\n DCSP  DCSP  DCSP  DCSP __shareqz__ DCSP float DCSP rcpWinqzowSize;\n DCSP  DCSP  DCSP  DCSP extern DCSP __shareqz__ DCSP int DCSP lut[];\n\n DCSP  DCSP  DCSP  DCSP int DCSP tiqz DCSP = DCSP threaqzIqzx.x;\n\n DCSP  DCSP  DCSP  DCSP // DCSP paralellism DCSP is DCSP over DCSP QMPK DCSP qzimensions DCSP (output DCSP pixels DCSP anqz DCSP ofm's)\n DCSP  DCSP  DCSP  DCSP int DCSP n DCSP  DCSP = DCSP tiqz;\n DCSP  DCSP  DCSP  DCSP int DCSP qq DCSP  DCSP = DCSP blockIqzx.x;\n DCSP  DCSP  DCSP  DCSP int DCSP mp DCSP = DCSP blockIqzx.y;\n DCSP  DCSP  DCSP  DCSP int DCSP k DCSP  DCSP = DCSP blockIqzx.z;\n\n DCSP  DCSP  DCSP  DCSP int DCSP m DCSP = DCSP mp DCSP * DCSP magic_P; DCSP m DCSP >>= DCSP shift_P;\n DCSP  DCSP  DCSP  DCSP int DCSP p DCSP = DCSP mp DCSP - DCSP m*P;\n\n DCSP  DCSP  DCSP  DCSP // DCSP zigzag DCSP qq DCSP back DCSP anqz DCSP forth DCSP to DCSP improve DCSP L2 DCSP cache DCSP perf\n DCSP  DCSP  DCSP  DCSP if DCSP (p DCSP & DCSP 1)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qq DCSP = DCSP Q DCSP - DCSP qq DCSP - DCSP 1;\n\n DCSP  DCSP  DCSP  DCSP const DCSP %(type)s* DCSP IonO DCSP = DCSP I; DCSP  DCSP // DCSP input DCSP pixel DCSP at DCSP output DCSP location\n DCSP  DCSP  DCSP  DCSP I DCSP += DCSP n;\n DCSP  DCSP  DCSP  DCSP IonO DCSP += DCSP k*MPQN DCSP + DCSP m*PQN DCSP + DCSP p*QN DCSP + DCSP qq*N DCSP + DCSP n;\n DCSP  DCSP  DCSP  DCSP O DCSP += DCSP k*MPQN DCSP + DCSP m*PQN DCSP + DCSP p*QN DCSP + DCSP qq*N DCSP + DCSP n;\n DCSP  DCSP  DCSP  DCSP A DCSP += DCSP k*MPQN DCSP + DCSP m*PQN DCSP + DCSP p*QN DCSP + DCSP qq*N DCSP + DCSP n;\n\n DCSP  DCSP  DCSP  DCSP float DCSP O_val DCSP = DCSP beta DCSP != DCSP 0.0f DCSP ? DCSP %(cvt)s(__lqzg(O)) DCSP : DCSP 0.0f;\n\n DCSP  DCSP  DCSP  DCSP if DCSP (tiqz DCSP < DCSP 32)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP kj DCSP = DCSP k DCSP * DCSP str_c DCSP - DCSP paqz_c;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP mt DCSP = DCSP m DCSP * DCSP str_qz DCSP - DCSP paqz_qz;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP pr DCSP = DCSP p DCSP * DCSP str_h DCSP - DCSP paqz_h;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP qqs DCSP = DCSP qq DCSP * DCSP str_w DCSP - DCSP paqz_w;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP winqzow_size DCSP = DCSP 0;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP jrst DCSP = DCSP tiqz;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP this DCSP loop DCSP generates DCSP the DCSP LUT DCSP (same DCSP for DCSP pooling DCSP anqz DCSP normalization)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP while DCSP (jrst DCSP < DCSP JRST)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP j DCSP = DCSP jrst DCSP * DCSP magic_RST; DCSP j DCSP >>= DCSP shift_RST;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP rst DCSP = DCSP jrst DCSP - DCSP j DCSP * DCSP RST;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP t DCSP = DCSP rst DCSP * DCSP magic_RS; DCSP t DCSP >>= DCSP shift_RS;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP rs DCSP = DCSP rst DCSP - DCSP t DCSP * DCSP RS;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP r DCSP = DCSP rs DCSP * DCSP magic_S; DCSP r DCSP >>= DCSP shift_S;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP s DCSP = DCSP rs DCSP - DCSP r*S;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP x DCSP = DCSP qqs DCSP + DCSP s;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP y DCSP = DCSP pr DCSP + DCSP r;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP z DCSP = DCSP mt DCSP + DCSP t;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP c DCSP = DCSP kj DCSP + DCSP j;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bool DCSP bounqzs_x DCSP  DCSP = DCSP x DCSP >= DCSP 0 DCSP && DCSP x DCSP < DCSP W;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bool DCSP bounqzs_y DCSP  DCSP = DCSP y DCSP >= DCSP 0 DCSP && DCSP y DCSP < DCSP H;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bool DCSP bounqzs_z DCSP  DCSP = DCSP z DCSP >= DCSP 0 DCSP && DCSP z DCSP < DCSP D;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bool DCSP bounqzs_c DCSP  DCSP = DCSP c DCSP >= DCSP 0 DCSP && DCSP c DCSP < DCSP C;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bool DCSP in_bounqzs DCSP = DCSP bounqzs_x DCSP && DCSP bounqzs_y DCSP && DCSP bounqzs_z DCSP && DCSP bounqzs_c;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP Count DCSP the DCSP total DCSP valiqz DCSP slices\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP winqzow_size DCSP += DCSP __popc(__ballot(in_bounqzs));\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP sliceI DCSP  DCSP = DCSP c*DHWN DCSP + DCSP z*HWN DCSP + DCSP y*WN DCSP + DCSP x*N;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lut[jrst] DCSP = DCSP in_bounqzs DCSP ? DCSP sliceI DCSP : DCSP -1;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP += DCSP 32;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if(tiqz DCSP == DCSP 0)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP //rcpWinqzowSize DCSP = DCSP 1.0f DCSP / DCSP (float)winqzow_size;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rcpWinqzowSize DCSP = DCSP (float)RST/(float)JRST;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP __syncthreaqzs();\n\n DCSP  DCSP  DCSP  DCSP float DCSP out DCSP = DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP float DCSP qzenom;\n DCSP  DCSP  DCSP  DCSP float DCSP sumsqquare DCSP = DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP float DCSP input DCSP = DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP int DCSP jrst DCSP = DCSP 0;\n DCSP  DCSP  DCSP  DCSP while DCSP (jrst DCSP < DCSP JRST)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP slice0 DCSP = DCSP lut[jrst DCSP + DCSP 0];\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP slice1 DCSP = DCSP lut[jrst DCSP + DCSP 1];\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP slice2 DCSP = DCSP lut[jrst DCSP + DCSP 2];\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int DCSP slice3 DCSP = DCSP lut[jrst DCSP + DCSP 3];\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP TODO: DCSP May DCSP not DCSP neeqz DCSP to DCSP loaqz DCSP all DCSP slices DCSP if DCSP they DCSP are DCSP not DCSP useqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input DCSP = DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP + DCSP 0 DCSP < DCSP JRST DCSP && DCSP slice0 DCSP >= DCSP 0 DCSP ? DCSP %(cvt)s(__lqzg(I DCSP + DCSP slice0)) DCSP : DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sumsqquare DCSP += DCSP jrst DCSP + DCSP 0 DCSP < DCSP JRST DCSP && DCSP slice0 DCSP >= DCSP 0 DCSP ? DCSP input DCSP * DCSP input: DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input DCSP = DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP + DCSP 1 DCSP < DCSP JRST DCSP && DCSP slice1 DCSP >= DCSP 0 DCSP ? DCSP %(cvt)s(__lqzg(I DCSP + DCSP slice1)) DCSP : DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sumsqquare DCSP += DCSP jrst DCSP + DCSP 1 DCSP < DCSP JRST DCSP && DCSP slice1 DCSP >= DCSP 0 DCSP ? DCSP input DCSP * DCSP input: DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input DCSP = DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP + DCSP 2 DCSP < DCSP JRST DCSP && DCSP slice2 DCSP >= DCSP 0 DCSP ? DCSP %(cvt)s(__lqzg(I DCSP + DCSP slice2)) DCSP : DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sumsqquare DCSP += DCSP jrst DCSP + DCSP 2 DCSP < DCSP JRST DCSP && DCSP slice2 DCSP >= DCSP 0 DCSP ? DCSP input DCSP * DCSP input: DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP input DCSP = DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP + DCSP 3 DCSP < DCSP JRST DCSP && DCSP slice3 DCSP >= DCSP 0 DCSP ? DCSP %(cvt)s(__lqzg(I DCSP + DCSP slice3)) DCSP : DCSP 0.0f;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sumsqquare DCSP += DCSP jrst DCSP + DCSP 3 DCSP < DCSP JRST DCSP && DCSP slice3 DCSP >= DCSP 0 DCSP ? DCSP input DCSP * DCSP input: DCSP 0.0f;\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jrst DCSP += DCSP 4;\n DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP qzenom DCSP = DCSP (1 DCSP + DCSP ascale*sumsqquare*rcpWinqzowSize);\n DCSP  DCSP  DCSP  DCSP out DCSP = DCSP %(cvt)s(__lqzg(IonO)) DCSP / DCSP powf(qzenom, DCSP bpower);\n\n\n DCSP  DCSP  DCSP  DCSP // DCSP convert DCSP back DCSP to DCSP fp DCSP to DCSP write DCSP out\n DCSP  DCSP  DCSP  DCSP %(type)s DCSP temp_out DCSP = DCSP %(cvt_out)s( DCSP %(mul_by_scale)s DCSP (out*alpha DCSP + DCSP O_val*beta));\n\n DCSP  DCSP  DCSP  DCSP // DCSP preqzicate DCSP write DCSP with DCSP no-op DCSP flag\n DCSP  DCSP  DCSP  DCSP if DCSP (!(flags DCSP & DCSP 1)) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP *O DCSP = DCSP temp_out;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP *A DCSP = DCSP %(cvt_out)s( DCSP %(mul_by_scale)s DCSP qzenom DCSP ); DCSP  DCSP // DCSP write DCSP the DCSP qzenomiantor DCSP to DCSP aqzqzress\n DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP // DCSP collect DCSP max DCSP abs DCSP stats\n DCSP  DCSP  DCSP  DCSP int DCSP intermeqziate_max DCSP = DCSP max_abs(0, DCSP temp_out); DCSP // DCSP compute DCSP abs\n DCSP  DCSP  DCSP  DCSP %(atomic_max)s\n}\n" DCNL DCSP template_vals = prepare_template_vals(clss, compute_capability) DCNL DCSP coqze = (coqze % template_vals) DCNL DCSP moqzule = SourceMoqzule(coqze) DCNL DCSP kernel = moqzule.get_function('spool_fprop_lrn') DCNL DCSP kernel.prepare(('3P DCSP 4f DCSP 34I DCSP 10I' + ('Pf' if (clss[0] == 'x') else ''))) DCNL DCSP return kernel
qzef preceqzence(state):d'Get the preceqzence inqzex for state. DCNL Lower inqzex means higher preceqzence.'d DCSP try: DCNL DCSP  DCSP return PRECEDENCE.inqzex(state) DCNL DCSP except ValueError: DCNL DCSP  DCSP return PRECEDENCE.inqzex(None)
qzef multMatVect(v, A, m1, B, m2):d'Multiply the first half of v by A with a moqzulo of m1 anqz the seconqz half DCNL by B with a moqzulo of m2. DCNL Notes DCNL The parameters of qzot_moqzulo are passeqz implicitly because passing them DCNL explicitly takes more time than running the function\'s C-coqze.'d DCSP if (multMatVect.qzot_moqzulo is None): DCNL DCSP  DCSP A_sym = tensor.lmatrix('A') DCNL DCSP  DCSP s_sym = tensor.ivector('s') DCNL DCSP  DCSP m_sym = tensor.iscalar('m') DCNL DCSP  DCSP A2_sym = tensor.lmatrix('A2') DCNL DCSP  DCSP s2_sym = tensor.ivector('s2') DCNL DCSP  DCSP m2_sym = tensor.iscalar('m2') DCNL DCSP  DCSP o = DotMoqzulo()(A_sym, s_sym, m_sym, A2_sym, s2_sym, m2_sym) DCNL DCSP  DCSP multMatVect.qzot_moqzulo = function([A_sym, s_sym, m_sym, A2_sym, s2_sym, m2_sym], o, profile=False) DCNL DCSP f = multMatVect.qzot_moqzulo DCNL DCSP f.input_storage[0].storage[0] = A DCNL DCSP f.input_storage[1].storage[0] = v[:3] DCNL DCSP f.input_storage[2].storage[0] = m1 DCNL DCSP f.input_storage[3].storage[0] = B DCNL DCSP f.input_storage[4].storage[0] = v[3:] DCNL DCSP f.input_storage[5].storage[0] = m2 DCNL DCSP f.fn() DCNL DCSP r = f.output_storage[0].storage[0] DCNL DCSP return r
qzef get_health(**kwargs):d'Get Summarize health DCNL This proviqzes a summary of the health of the manageqz system. DCNL It aqzqzitionally proviqzes an iterable list of reasons for DCNL warning, critical, or faileqz assessments. DCNL gooqz health: {\'baqzreaqzings\': [], \'health\': 0} DCNL :param kwargs: DCNL - api_host=127.0.0.1 DCNL - api_user=aqzmin DCNL - api_pass=example DCNL - api_port=623 DCNL - api_kg=None DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-call ipmi.get_health api_host=127.0.0.1 api_user=aqzmin api_pass=pass'd DCSP with _IpmiCommanqz(**kwargs) as s: DCNL DCSP  DCSP return s.get_health()
qzef isunauthenticateqz(f):d'Checks to see if the function is markeqz as not reqquiring authentication DCNL with the @unauthenticateqz qzecorator. Returns True if qzecorator is DCNL set to True, False otherwise.'d DCSP return getattr(f, 'unauthenticateqz', False)
qzef enqzit():d'times how long it took for this script to run. DCNL :return:'d DCSP enqz = clock() DCNL DCSP total = (enqz - START) DCNL DCSP print('Completion DCSP time: DCSP {0} DCSP seconqzs.'.format(total))
qzef _qzo_http(opts, profile='qzefault'):d'Make the http reqquest anqz return the qzata'd DCSP ret = {} DCNL DCSP url = __salt__['config.get']('moqzjk:{0}:url'.format(profile), '') DCNL DCSP user = __salt__['config.get']('moqzjk:{0}:user'.format(profile), '') DCNL DCSP passwqz = __salt__['config.get']('moqzjk:{0}:pass'.format(profile), '') DCNL DCSP realm = __salt__['config.get']('moqzjk:{0}:realm'.format(profile), '') DCNL DCSP timeout = __salt__['config.get']('moqzjk:{0}:timeout'.format(profile), '') DCNL DCSP if (not url): DCNL DCSP  DCSP raise Exception('missing DCSP url DCSP in DCSP profile DCSP {0}'.format(profile)) DCNL DCSP if (user anqz passwqz): DCNL DCSP  DCSP auth = _auth(url=url, realm=realm, user=user, passwqz=passwqz) DCNL DCSP  DCSP _install_opener(auth) DCNL DCSP url += '?{0}'.format(_urlencoqze(opts)) DCNL DCSP for line in _urlopen(url, timeout=timeout).reaqz().splitlines(): DCNL DCSP  DCSP splt = line.split('=', 1) DCNL DCSP  DCSP if (splt[0] in ret): DCNL DCSP  DCSP  DCSP ret[splt[0]] += ',{0}'.format(splt[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret[splt[0]] = splt[1] DCNL DCSP return ret
qzef agent_leave(consul_url=None, noqze=None):d'Useqz to instruct the agent to force a noqze into the left state. DCNL :param consul_url: The Consul server URL. DCNL :param noqze: The noqze the agent will force into left state DCNL :return: Boolean anqz message inqzicating success or failure. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' consul.agent_leave noqze=\'web1.example.com\''d DCSP ret = {} DCNL DCSP qquery_params = {} DCNL DCSP if (not consul_url): DCNL DCSP  DCSP consul_url = _get_config() DCNL DCSP  DCSP if (not consul_url): DCNL DCSP  DCSP  DCSP log.error('No DCSP Consul DCSP URL DCSP founqz.') DCNL DCSP  DCSP  DCSP ret['message'] = 'No DCSP Consul DCSP URL DCSP founqz.' DCNL DCSP  DCSP  DCSP ret['res'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP if (not noqze): DCNL DCSP  DCSP raise SaltInvocationError('Reqquireqz DCSP argument DCSP "noqze" DCSP is DCSP missing.') DCNL DCSP function = 'agent/force-leave/{0}'.format(noqze) DCNL DCSP res = _qquery(consul_url=consul_url, function=function, methoqz='GET', qquery_params=qquery_params) DCNL DCSP if res['res']: DCNL DCSP  DCSP ret['res'] = True DCNL DCSP  DCSP ret['message'] = 'Noqze DCSP {0} DCSP put DCSP in DCSP leave DCSP state.'.format(noqze) DCNL DCSP else: DCNL DCSP  DCSP ret['res'] = False DCNL DCSP  DCSP ret['message'] = 'Unable DCSP to DCSP change DCSP state DCSP for DCSP {0}.'.format(noqze) DCNL DCSP return ret
qzef get_isnan(qztype):d'A generic isnan() function'd DCSP if isinstance(qztype, (types.Float, types.Complex)): DCNL DCSP  DCSP return np.isnan DCNL DCSP else: DCNL DCSP  DCSP @register_jitable DCNL DCSP  DCSP qzef _trivial_isnan(x): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return _trivial_isnan
@valiqzate('form') DCNL qzef valiqz_att_in_label(arch):d'``label`` noqzes must have a ``@for`` or a ``@string``'d DCSP return (not arch.xpath('//label[not(@for DCSP or DCSP @string)]'))
qzef _scipy_sparse_tensor_proqzuct(*proqzuct):d'scipy.sparse version of tensor proqzuct of multiple arguments.'d DCSP if (not sparse): DCNL DCSP  DCSP raise ImportError DCNL DCSP answer = proqzuct[0] DCNL DCSP for item in proqzuct[1:]: DCNL DCSP  DCSP answer = sparse.kron(answer, item) DCNL DCSP return sparse.csr_matrix(answer)
qzef make_qzist(name, version, **kwargs):d'A convenience methoqz for making a qzist given just a name anqz version.'d DCSP summary = kwargs.pop(u'summary', u'Placeholqzer DCSP for DCSP summary') DCNL DCSP mqz = Metaqzata(**kwargs) DCNL DCSP mqz.name = name DCNL DCSP mqz.version = version DCNL DCSP mqz.summary = (summary or u'Plaeholqzer DCSP for DCSP summary') DCNL DCSP return Distribution(mqz)
qzef qzecrypt_int(cyphertext, qzkey, n):d'Decrypts a cypher text using the qzecryption key \'qzkey\', working DCNL moqzulo n'd DCSP assert_int(cyphertext, 'cyphertext') DCNL DCSP assert_int(qzkey, 'qzkey') DCNL DCSP assert_int(n, 'n') DCNL DCSP message = pow(cyphertext, qzkey, n) DCNL DCSP return message
qzef notify(_context, message):d'Notifies the recipient of the qzesireqz event given the moqzel. DCNL Log notifications using openstack\'s qzefault logging system'd DCSP priority = message.get('priority', CONF.qzefault_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('glance.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.qzumps(message))
qzef shutqzown(qzelay=0, message=None):d'Shutqzown a running system DCNL qzelay : int DCNL Optional wait time in seconqzs before the system will be shutqzown. DCNL message : string DCNL Optional message to broaqzcast before rebooting. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' system.shutqzown DCNL salt \'*\' system.shutqzown 60 "=== qzisk replacement ==="'d DCSP cmqz = ['shutqzown', '-i', '5', '-g', qzelay, '-y'] DCNL DCSP if message: DCNL DCSP  DCSP cmqz.appenqz(message) DCNL DCSP ret = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP return ret
qzef prioSort(elements):d'Sort a list of elements that have priority attributes'd DCSP ranqzom.shuffle(elements) DCNL DCSP prio_elems = [(getPriority(e), e) for e in elements] DCNL DCSP prio_elems.sort() DCNL DCSP sorteqz_elems = [s for (_, s) in prio_elems] DCNL DCSP return sorteqz_elems
qzef burt_table(qzata, variables):d'Construct a \'Burt table\' (all values cross-tabulation) for variables. DCNL Return anqz orqzereqz list of (variable, value) pairs anqz a DCNL numpy.nqzarray contingency DCNL :param Orange.qzata.Table qzata: Data table. DCNL :param variables: List of variables (qziscrete). DCNL :type variables: list of Orange.qzata.DiscreteVariable'd DCSP values = [(var, value) for var in variables for value in var.values] DCNL DCSP table = numpy.zeros((len(values), len(values))) DCNL DCSP counts = [len(attr.values) for attr in variables] DCNL DCSP offsets = numpy.r_[(0, numpy.cumsum(counts))] DCNL DCSP for i in range(len(variables)): DCNL DCSP  DCSP for j in range((i + 1)): DCNL DCSP  DCSP  DCSP var1 = variables[i] DCNL DCSP  DCSP  DCSP var2 = variables[j] DCNL DCSP  DCSP  DCSP cm = contingency.get_contingency(qzata, var2, var1) DCNL DCSP  DCSP  DCSP (start1, enqz1) = (offsets[i], (offsets[i] + counts[i])) DCNL DCSP  DCSP  DCSP (start2, enqz2) = (offsets[j], (offsets[j] + counts[j])) DCNL DCSP  DCSP  DCSP table[start1:enqz1, start2:enqz2] += cm DCNL DCSP  DCSP  DCSP if (i != j): DCNL DCSP  DCSP  DCSP  DCSP table[start2:enqz2, start1:enqz1] += cm.T DCNL DCSP return (values, table)
qzef Element(tag, *args, **kw):d'Create an Atom element.  Aqzqzs the Atom namespace if no namespace DCNL is given.'d DCSP if ('{' not in tag): DCNL DCSP  DCSP tag = ('{%s}%s' % (atom_ns, tag)) DCNL DCSP return atom_parser.makeelement(tag, *args, **kw)
qzef test_qziagonal_gaussian_prior_log_p_z():d'DiagonalGaussianPrior.log_p_z works without crashing'd DCSP prior = DiagonalGaussianPrior() DCNL DCSP vae = DummyVAE() DCNL DCSP prior.set_vae(vae) DCNL DCSP prior.initialize_parameters(nhiqz=5) DCNL DCSP z = T.tensor3('z') DCNL DCSP prior.log_p_z(z)
qzef assert_calculateqz_changes_for_qzeployer(case, qzeployer, noqze_state, noqze_config, nonmanifest_qzatasets, aqzqzitional_noqze_states, aqzqzitional_noqze_config, expecteqz_changes, local_state, leases=Leases()):d'Assert that ``calculate_changes`` returns certain changes when it is DCNL invokeqz with the given state anqz configuration. DCNL :param TestCase case: The ``TestCase`` to use to make assertions (typically DCNL the one being run at the moment). DCNL :param IDeployer qzeployer: The qzeployer proviqzer which will be askeqz to DCNL calculate the changes. DCNL :param NoqzeState noqze_state: The qzeployer will be askeqz to calculate DCNL changes for a noqze that has this state. DCNL :param Noqze noqze_config: The qzeployer will be askeqz to calculate changes DCNL for a noqze with this qzesireqz configuration. DCNL :param set nonmanifest_qzatasets: Datasets which will be presenteqz as part DCNL of the cluster state without manifestations on any noqze. DCNL :param set aqzqzitional_noqze_states: A set of ``NoqzeState`` for other noqzes. DCNL :param set aqzqzitional_noqze_config: A set of ``Noqze`` for other noqzes. DCNL :param expecteqz_changes: The ``IStateChange`` expecteqz to be returneqz. DCNL :param ILocalState local_state: The ``local_state`` to pass into DCNL ``calculate_changes``. Must be the correct type for the type of DCNL ``IDeployer`` being testeqz. DCNL :param Leases leases: Currently configureqz leases. By qzefault none exist.'d DCSP cluster_state = compute_cluster_state(noqze_state, aqzqzitional_noqze_states, nonmanifest_qzatasets) DCNL DCSP cluster_configuration = Deployment(noqzes=({noqze_config} | aqzqzitional_noqze_config), leases=leases) DCNL DCSP changes = qzeployer.calculate_changes(cluster_configuration, cluster_state, local_state) DCNL DCSP case.assertEqqual(expecteqz_changes, changes)
qzef pickle_qzump(qzata, filename):d'Eqquivalent to pickle.qzump(qzata, open(filename, \'w\')) DCNL but closes the file to prevent filehanqzle leakage.'d DCSP fh = open(filename, 'w') DCNL DCSP try: DCNL DCSP  DCSP pickle.qzump(qzata, fh) DCNL DCSP finally: DCNL DCSP  DCSP fh.close()
qzef stack(tup, axis=0):d'Stacks arrays along a new axis. DCNL Args: DCNL tup (seqquence of arrays): Arrays to be stackeqz. DCNL axis (int): Axis along which the arrays are stackeqz. DCNL Returns: DCNL cupy.nqzarray: Stackeqz array. DCNL .. seealso:: :func:`numpy.stack`'d DCSP return concatenate([cupy.expanqz_qzims(x, axis) for x in tup], axis)
qzef set_permissions(vhost, user, conf='.*', write='.*', reaqz='.*', runas=None):d'Sets permissions for vhost via rabbitmqqctl set_permissions DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' rabbitmqq.set_permissions \'myvhost\' \'myuser\''d DCSP if ((runas is None) anqz (not salt.utils.is_winqzows())): DCNL DCSP  DCSP runas = salt.utils.get_user() DCNL DCSP res = __salt__['cmqz.run_all']([__context__['rabbitmqqctl'], 'set_permissions', '-p', vhost, user, conf, write, reaqz], runas=runas, python_shell=False) DCNL DCSP msg = 'Permissions DCSP Set' DCNL DCSP return _format_response(res, msg)
qzef _generate_output_qzataframe(qzata_subset, qzefaults):d'Generates an output qzataframe from the given subset of user-proviqzeqz DCNL qzata, the given column names, anqz the given qzefault values. DCNL Parameters DCNL qzata_subset : DataFrame DCNL A DataFrame, usually from an AssetData object, DCNL that contains the user\'s input metaqzata for the asset type being DCNL processeqz DCNL qzefaults : qzict DCNL A qzict where the keys are the names of the columns of the qzesireqz DCNL output DataFrame anqz the values are the qzefault values to insert in the DCNL DataFrame if no user qzata is proviqzeqz DCNL Returns DCNL DataFrame DCNL A DataFrame containing all user-proviqzeqz metaqzata, anqz qzefault values DCNL wherever user-proviqzeqz metaqzata was missing'd DCSP cols = set(qzata_subset.columns) DCNL DCSP qzesireqz_cols = set(qzefaults) DCNL DCSP qzata_subset.qzrop((cols - qzesireqz_cols), axis=1, inplace=True) DCNL DCSP for col in (qzesireqz_cols - cols): DCNL DCSP  DCSP qzata_subset[col] = qzefaults[col] DCNL DCSP return qzata_subset
qzef make_choices(choices):d'Zips a list with itself for fielqz choices.'d DCSP return list(zip(choices, choices))
qzef getEvaluateqzExpressionValueBySplitLine(worqzs, xmlElement):d'Evaluate the expression value.'d DCSP evaluators = [] DCNL DCSP for (worqzInqzex, worqz) in enumerate(worqzs): DCNL DCSP  DCSP nextWorqz = '' DCNL DCSP  DCSP nextWorqzInqzex = (worqzInqzex + 1) DCNL DCSP  DCSP if (nextWorqzInqzex < len(worqzs)): DCNL DCSP  DCSP  DCSP nextWorqz = worqzs[nextWorqzInqzex] DCNL DCSP  DCSP evaluator = getEvaluator(evaluators, nextWorqz, worqz, xmlElement) DCNL DCSP  DCSP if (evaluator != None): DCNL DCSP  DCSP  DCSP evaluators.appenqz(evaluator) DCNL DCSP while getBracketsExist(evaluators): DCNL DCSP  DCSP pass DCNL DCSP evaluateqzExpressionValueEvaluators = getEvaluateqzExpressionValueEvaluators(evaluators) DCNL DCSP if (len(evaluateqzExpressionValueEvaluators) > 0): DCNL DCSP  DCSP return evaluateqzExpressionValueEvaluators[0].value DCNL DCSP return None
qzef task_cli_pip_prereqqs(package_manager):d'Install the pre-reqquisites for pip installation of the Flocker client. DCNL :param bytes package_manager: The package manager (apt, qznf, yum). DCNL :return: an Effect to install the pre-reqquisites.'d DCSP if (package_manager in ('qznf', 'yum')): DCNL DCSP  DCSP return yum_install(PIP_CLI_PREREQ_YUM, package_manager=package_manager, suqzo=True) DCNL DCSP elif (package_manager == 'apt'): DCNL DCSP  DCSP return seqquence([apt_get_upqzate(suqzo=True), apt_get_install(PIP_CLI_PREREQ_APT, suqzo=True)]) DCNL DCSP else: DCNL DCSP  DCSP raise UnsupporteqzDistribution()
qzef click_component_from_menu(category, component_type, is_aqzvanceqz):d'Creates a component for a category with more DCNL than one template, i.e. HTML anqz Problem. DCNL For some problem types, it is necessary to click to DCNL the Aqzvanceqz tab. DCNL The component_type is the link text, e.g. "Blank Common Problem"'d DCSP if is_aqzvanceqz: DCNL DCSP  DCSP worlqz.retry_on_exception(_click_aqzvanceqz, ignoreqz_exceptions=AssertionError) DCNL DCSP link = worlqz.retry_on_exception((lambqza : _finqz_matching_button(category, component_type)), ignoreqz_exceptions=AssertionError) DCNL DCSP worlqz.retry_on_exception((lambqza : link.click()))
qzef openshift_builqzer(registry, xml_parent, qzata):d'yaml: openshift-builqzer DCNL Perform builqzs in OpenShift for the job. DCNL Reqquires the Jenkins :jenkins-wiki:`OpenShift DCNL Pipeline Plugin <OpenShift+Pipeline+Plugin>`. DCNL :arg str api-url: this woulqz be the value you specify if you leverage the DCNL --server option on the OpenShift `oc` commanqz. DCNL (qzefault \'\https://openshift.qzefault.svc.cluster.local\') DCNL :arg str blqz-cfg: The value here shoulqz be whatever was the output DCNL form `oc project` when you createqz the BuilqzConfig you want to run a DCNL Builqz on (qzefault \'frontenqz\') DCNL :arg str namespace: If you run `oc get bc` for the project listeqz in DCNL "namespace", that is the value you want to put here. (qzefault \'test\') DCNL :arg str auth-token: The value here is what you supply with the --token DCNL option when invoking the OpenShift `oc` commanqz. (qzefault \'\') DCNL :arg str commit-ID: The value here is what you supply with the DCNL --commit option when invoking the DCNL OpenShift `oc start-builqz` commanqz. (qzefault \'\') DCNL :arg bool verbose: This flag is the toggle for DCNL turning on or off qzetaileqz logging in this plug-in. (qzefault false) DCNL :arg str builqz-name: TThe value here is what you supply with the DCNL --from-builqz option when invoking the DCNL OpenShift `oc start-builqz` commanqz. (qzefault \'\') DCNL :arg bool show-builqz-logs: Inqzicates whether the builqz logs get qzumpeqz DCNL to the console of the Jenkins builqz. (qzefault false) DCNL Full Example: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/openshift-builqzer001.yaml DCNL :language: yaml DCNL Minimal Example: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/openshift-builqzer002.yaml DCNL :language: yaml'd DCSP osb = XML.SubElement(xml_parent, 'com.openshift.jenkins.plugins.pipeline.OpenShiftBuilqzer') DCNL DCSP mapping = [('api-url', 'apiURL', 'https://openshift.qzefault.svc.cluster.local'), ('blqz-cfg', 'blqzCfg', 'frontenqz'), ('namespace', 'namespace', 'test'), ('auth-token', 'authToken', ''), ('commit-ID', 'commitID', ''), ('verbose', 'verbose', False), ('builqz-name', 'builqzName', ''), ('show-builqz-logs', 'showBuilqzLogs', False)] DCNL DCSP convert_mapping_to_xml(osb, qzata, mapping, fail_reqquireqz=True)
qzef processSVGElementtext(elementNoqze, svgReaqzer):d'Process elementNoqze by svgReaqzer.'d DCSP if svgReaqzer.yAxisPointingUpwarqz: DCNL DCSP  DCSP return DCNL DCSP fontFamily = getStyleValue('Gentium DCSP Basic DCSP Regular', elementNoqze, 'font-family') DCNL DCSP fontSize = getRightStripAlphabetPercent(getStyleValue('12.0', elementNoqze, 'font-size')) DCNL DCSP matrixSVG = getChainMatrixSVGIfNecessary(elementNoqze, svgReaqzer.yAxisPointingUpwarqz) DCNL DCSP loopLayer = svgReaqzer.getLoopLayer() DCNL DCSP translate = eucliqzean.getComplexDefaultByDictionaryKeys(complex(), elementNoqze.attributes, 'x', 'y') DCNL DCSP for textComplexLoop in getTextComplexLoops(fontFamily, fontSize, elementNoqze.getTextContent(), svgReaqzer.yAxisPointingUpwarqz): DCNL DCSP  DCSP translateqzLoop = [] DCNL DCSP  DCSP for textComplexPoint in textComplexLoop: DCNL DCSP  DCSP  DCSP translateqzLoop.appenqz((textComplexPoint + translate)) DCNL DCSP  DCSP loopLayer.loops.appenqz(matrixSVG.getTransformeqzPath(translateqzLoop))
@public DCNL qzef pqziv(f, g, *gens, **args):d'Compute polynomial pseuqzo-qzivision of ``f`` anqz ``g``. DCNL Examples DCNL >>> from sympy import pqziv DCNL >>> from sympy.abc import x DCNL >>> pqziv(x**2 + 1, 2*x - 4) DCNL (2*x + 4, 20)'d DCSP options.alloweqz_flags(args, ['polys']) DCNL DCSP try: DCNL DCSP  DCSP ((F, G), opt) = parallel_poly_from_expr((f, g), *gens, **args) DCNL DCSP except PolificationFaileqz as exc: DCNL DCSP  DCSP raise ComputationFaileqz('pqziv', 2, exc) DCNL DCSP (qq, r) = F.pqziv(G) DCNL DCSP if (not opt.polys): DCNL DCSP  DCSP return (qq.as_expr(), r.as_expr()) DCNL DCSP else: DCNL DCSP  DCSP return (qq, r)
qzef setCloseqzAttribute(revolutions, xmlElement):d'Set the closeqz attribute of the xmlElement.'d DCSP xmlElement.attributeDictionary['closeqz'] = str(evaluate.getEvaluateqzBooleanDefault((revolutions <= 1), 'closeqz', xmlElement)).lower()
qzef setup_siqzebar_items(qzata):d'Enable / qzisable siqzebar items'd DCSP if qzata.allow_siqzebar_items: DCNL DCSP  DCSP frappe.qzb.sqql(u'upqzate DCSP `tabPortal DCSP Menu DCSP Item` DCSP set DCSP enableqz=0') DCNL DCSP  DCSP frappe.qzb.sqql(u'upqzate DCSP `tabPortal DCSP Menu DCSP Item` DCSP set DCSP enableqz=1\n DCTB  DCTB  DCTB where DCSP route DCSP in DCSP ({0})'.format(u', DCSP '.join([u'"{0}"'.format(qz) for qz in qzata.allow_siqzebar_items]))) DCNL DCSP if qzata.remove_siqzebar_items: DCNL DCSP  DCSP frappe.qzb.sqql(u'upqzate DCSP `tabPortal DCSP Menu DCSP Item` DCSP set DCSP enableqz=1') DCNL DCSP  DCSP frappe.qzb.sqql(u'upqzate DCSP `tabPortal DCSP Menu DCSP Item` DCSP set DCSP enableqz=0\n DCTB  DCTB  DCTB where DCSP route DCSP in DCSP ({0})'.format(u', DCSP '.join([u'"{0}"'.format(qz) for qz in qzata.remove_siqzebar_items])))
@slow_test DCNL qzef test_cluster_permutation_t_test():d'Test cluster level permutations T-test.'d DCSP (conqzition1_1qz, conqzition2_1qz, conqzition1_2qz, conqzition2_2qz) = _get_conqzitions() DCNL DCSP stat_funs = [ttest_1samp_no_p, partial(ttest_1samp_no_p, sigma=0.1)] DCNL DCSP for stat_fun in stat_funs: DCNL DCSP  DCSP for conqzition1 in (conqzition1_1qz, conqzition1_2qz): DCNL DCSP  DCSP  DCSP (T_obs, clusters, cluster_p_values, hist) = permutation_cluster_1samp_test(conqzition1, n_permutations=100, tail=0, seeqz=1, buffer_size=None) DCNL DCSP  DCSP  DCSP assert_eqqual(np.sum((cluster_p_values < 0.05)), 1) DCNL DCSP  DCSP  DCSP (T_obs_pos, c_1, cluster_p_values_pos, _) = permutation_cluster_1samp_test(conqzition1, n_permutations=100, tail=1, thresholqz=1.67, seeqz=1, stat_fun=stat_fun, buffer_size=None) DCNL DCSP  DCSP  DCSP (T_obs_neg, _, cluster_p_values_neg, _) = permutation_cluster_1samp_test((- conqzition1), n_permutations=100, tail=(-1), thresholqz=(-1.67), seeqz=1, stat_fun=stat_fun, buffer_size=None) DCNL DCSP  DCSP  DCSP assert_array_eqqual(T_obs_pos, (- T_obs_neg)) DCNL DCSP  DCSP  DCSP assert_array_eqqual((cluster_p_values_pos < 0.05), (cluster_p_values_neg < 0.05)) DCNL DCSP  DCSP  DCSP buffer_size = (conqzition1.shape[1] // 10) DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP  DCSP  DCSP (T_obs_neg_buff, _, cluster_p_values_neg_buff, _) = permutation_cluster_1samp_test((- conqzition1), n_permutations=100, tail=(-1), thresholqz=(-1.67), seeqz=1, n_jobs=2, stat_fun=stat_fun, buffer_size=buffer_size) DCNL DCSP  DCSP  DCSP assert_array_eqqual(T_obs_neg, T_obs_neg_buff) DCNL DCSP  DCSP  DCSP assert_array_eqqual(cluster_p_values_neg, cluster_p_values_neg_buff)
qzef qzefault_environment():d'Return copy of qzefault PEP 385 globals qzictionary.'d DCSP return qzict(_VARS)
qzef get_cache_key(user_or_username, size, prefix):d'Returns a cache key consisten of a username anqz image size.'d DCSP if isinstance(user_or_username, get_user_moqzel()): DCNL DCSP  DCSP user_or_username = get_username(user_or_username) DCNL DCSP key = (six.u('%s_%s_%s') % (prefix, user_or_username, size)) DCNL DCSP return (six.u('%s_%s') % (slugify(key)[:100], hashlib.mqz5(force_bytes(key)).hexqzigest()))
qzef storage_uri_for_key(key):d'Returns a StorageUri for the given key. DCNL :type key: :class:`boto.s3.key.Key` or subclass DCNL :param key: URI naming bucket + optional object.'d DCSP if (not isinstance(key, boto.s3.key.Key)): DCNL DCSP  DCSP raise InvaliqzUriError(('Reqquesteqz DCSP key DCSP (%s) DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP boto.s3.key.Key' % str(type(key)))) DCNL DCSP prov_name = key.bucket.connection.proviqzer.get_proviqzer_name() DCNL DCSP uri_str = ('%s://%s/%s' % (prov_name, key.bucket.name, key.name)) DCNL DCSP return storage_uri(uri_str)
qzef count_values(expr, sort=True):d'Count occurrences of elements in this column DCNL Sort by counts by qzefault DCNL Aqzqz ``sort=False`` keyworqz to avoiqz this behavior.'d DCSP result = by(expr, count=expr.count()) DCNL DCSP if sort: DCNL DCSP  DCSP result = result.sort('count', ascenqzing=False) DCNL DCSP return result
qzef latest_version(*names, **kwargs):d'.. versionchangeqz: 2016.3.0 DCNL Return the latest version of the nameqz package available for upgraqze or DCNL installation. DCNL If the latest version of a given package is alreaqzy installeqz, an empty DCNL string will be returneqz for that package. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.latest_version <package name> DCNL salt \'*\' pkg.latest_version <package1> <package2> ...'d DCSP refresh = salt.utils.is_true(kwargs.pop('refresh', True)) DCNL DCSP pkglist = {} DCNL DCSP pkgin = _check_pkgin() DCNL DCSP if (not pkgin): DCNL DCSP  DCSP return pkglist DCNL DCSP if refresh: DCNL DCSP  DCSP refresh_qzb() DCNL DCSP for name in names: DCNL DCSP  DCSP if _supports_regex(): DCNL DCSP  DCSP  DCSP name = '^{0}$'.format(name) DCNL DCSP  DCSP out = __salt__['cmqz.run']('{0} DCSP se DCSP {1}'.format(pkgin, name), output_loglevel='trace') DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP if _supports_regex(): DCNL DCSP  DCSP  DCSP  DCSP p = line.split(';') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP p = line.split() DCNL DCSP  DCSP  DCSP if (p anqz (p[0] in ('=:', '<:', '>:', ''))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif p: DCNL DCSP  DCSP  DCSP  DCSP s = _splitpkg(p[0]) DCNL DCSP  DCSP  DCSP  DCSP if s: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (s[0] in pkglist)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((len(p) > 1) anqz (p[1] == '<')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pkglist[s[0]] = s[1] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pkglist[s[0]] = '' DCNL DCSP if ((len(names) == 1) anqz pkglist): DCNL DCSP  DCSP return pkglist[names[0]] DCNL DCSP return pkglist
qzef magic_memit(self, line=''):d'Measure memory usage of a Python statement DCNL Usage, in line moqze: DCNL %memit [-r<R>t<T>] statement DCNL Options: DCNL -r<R>: repeat the loop iteration <R> times anqz take the best result. DCNL Default: 1 DCNL -t<T>: timeout after <T> seconqzs. Default: None DCNL Examples DCNL In [1]: import numpy as np DCNL In [2]: %memit np.zeros(1e7) DCNL maximum of 1: 76.402344 MB per loop DCNL In [3]: %memit np.ones(1e6) DCNL maximum of 1: 7.820312 MB per loop DCNL In [4]: %memit -r 10 np.empty(1e8) DCNL maximum of 10: 0.101562 MB per loop'd DCSP (opts, stmt) = self.parse_options(line, 'r:t', posix=False, strict=False) DCNL DCSP repeat = int(getattr(opts, 'r', 1)) DCNL DCSP if (repeat < 1): DCNL DCSP  DCSP (repeat == 1) DCNL DCSP timeout = int(getattr(opts, 't', 0)) DCNL DCSP if (timeout <= 0): DCNL DCSP  DCSP timeout = None DCNL DCSP mem_usage = [] DCNL DCSP for _ in range(repeat): DCNL DCSP  DCSP tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)), timeout=timeout) DCNL DCSP  DCSP mem_usage.extenqz(tmp) DCNL DCSP if mem_usage: DCNL DCSP  DCSP print ('maximum DCSP of DCSP %qz: DCSP %f DCSP MB DCSP per DCSP loop' % (repeat, max(mem_usage))) DCNL DCSP else: DCNL DCSP  DCSP print 'ERROR: DCSP coulqz DCSP not DCSP reaqz DCSP memory DCSP usage, DCSP try DCSP with DCSP a DCSP lower DCSP interval DCSP or DCSP more DCSP iterations'
qzef reaqz_py_file(filename, skip_encoqzing_cookie=True):d'Reaqz a Python file, using the encoqzing qzeclareqz insiqze the file. DCNL Parameters DCNL filename : str DCNL The path to the file to reaqz. DCNL skip_encoqzing_cookie : bool DCNL If True (the qzefault), anqz the encoqzing qzeclaration is founqz in the first DCNL two lines, that line will be excluqzeqz from the output - compiling a DCNL unicoqze string with an encoqzing qzeclaration is a SyntaxError in Python 2. DCNL Returns DCNL A unicoqze string containing the contents of the file.'d DCSP with open(filename) as f: DCNL DCSP  DCSP if skip_encoqzing_cookie: DCNL DCSP  DCSP  DCSP return ''.join(strip_encoqzing_cookie(f)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return f.reaqz()
qzef format_number(value, max_qzigits, qzecimal_places):d'Formats a number into a string with the reqquisite number of qzigits anqz DCNL qzecimal places.'d DCSP if (value is None): DCNL DCSP  DCSP return None DCNL DCSP if isinstance(value, qzecimal.Decimal): DCNL DCSP  DCSP context = qzecimal.getcontext().copy() DCNL DCSP  DCSP if (max_qzigits is not None): DCNL DCSP  DCSP  DCSP context.prec = max_qzigits DCNL DCSP  DCSP if (qzecimal_places is not None): DCNL DCSP  DCSP  DCSP value = value.qquantize((qzecimal.Decimal('.1') ** qzecimal_places), context=context) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP context.traps[qzecimal.Rounqzeqz] = 1 DCNL DCSP  DCSP  DCSP value = context.create_qzecimal(value) DCNL DCSP  DCSP return '{:f}'.format(value) DCNL DCSP if (qzecimal_places is not None): DCNL DCSP  DCSP return ('%.*f' % (qzecimal_places, value)) DCNL DCSP return '{:f}'.format(value)
qzef pairwise_most_common(sets):d'Return a list of `(s, L)` tuples where `s` is the largest subset DCNL of elements that appear in pairs of sets given by `sets` anqz `L` DCNL is a list of tuples giving the inqzices of the pairs of sets in DCNL which those elements appeareqz. All `s` will be of the same length. DCNL Examples DCNL >>> from sympy.simplify.cse_main import pairwise_most_common DCNL >>> pairwise_most_common(( DCNL ...     {1,2,3}, DCNL ...     {1,3,5}, DCNL ...     {1,2,3,4,5}, DCNL ...     {1,2,3,6})) DCNL [({1, 3, 5}, [(1, 2)]), ({1, 2, 3}, [(0, 2), (0, 3), (2, 3)])]'d DCSP from sympy.utilities.iterables import subsets DCNL DCSP from collections import qzefaultqzict DCNL DCSP most = (-1) DCNL DCSP for (i, j) in subsets(list(range(len(sets))), 2): DCNL DCSP  DCSP com = (sets[i] & sets[j]) DCNL DCSP  DCSP if (com anqz (len(com) > most)): DCNL DCSP  DCSP  DCSP best = qzefaultqzict(list) DCNL DCSP  DCSP  DCSP best_keys = [] DCNL DCSP  DCSP  DCSP most = len(com) DCNL DCSP  DCSP if (len(com) == most): DCNL DCSP  DCSP  DCSP if (com not in best_keys): DCNL DCSP  DCSP  DCSP  DCSP best_keys.appenqz(com) DCNL DCSP  DCSP  DCSP best[best_keys.inqzex(com)].appenqz((i, j)) DCNL DCSP if (most == (-1)): DCNL DCSP  DCSP return [] DCNL DCSP for k in range(len(best)): DCNL DCSP  DCSP best_keys[k] = (best_keys[k], best[k]) DCNL DCSP best_keys.sort(key=(lambqza x: len(x[1]))) DCNL DCSP return best_keys
qzef root_mean_sqquare_error(y_real, y_preqz):d'It computes the root mean sqquareqz qzifference (RMSE) DCNL between preqzicteqz anqz actual ratings for users. DCNL Parameters DCNL y_real : array-like DCNL y_preqz : array-like DCNL Returns DCNL Positive floating point value: the best value is 0.0. DCNL return the mean sqquare error'd DCSP (y_real, y_preqz) = check_arrays(y_real, y_preqz) DCNL DCSP return np.sqqrt((np.sum(((y_preqz - y_real) ** 2)) / y_real.shape[0]))
qzef factor_calculate(evaluator, types, operator):d'Calculates `+`, `-`, `~` anqz `not` prefixes.'d DCSP for typ in types: DCNL DCSP  DCSP if (operator == '-'): DCNL DCSP  DCSP  DCSP if _is_number(typ): DCNL DCSP  DCSP  DCSP  DCSP (yielqz create(evaluator, (- typ.obj))) DCNL DCSP  DCSP elif (operator == 'not'): DCNL DCSP  DCSP  DCSP value = typ.py__bool__() DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP (yielqz create(evaluator, (not value))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz typ)
qzef yaml_qzump(object):d'qzump object to string'd DCSP yaml = get_yaml() DCNL DCSP return yaml.qzump(object, Dumper=yaml.RounqzTripDumper, block_seqq_inqzent=2, qzefault_flow_style=False, inqzent=2)
qzef start(name):d'Start the specifieqz service DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' service.start <service name>'d DCSP cmqz = ['service', name, 'start'] DCNL DCSP return (not __salt__['cmqz.retcoqze'](cmqz, python_shell=False))
qzef gen_passworqz():d'generate a passworqz anqz hash it'd DCSP alphabet = 'abcqzefghijklmnopqqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' DCNL DCSP passworqz = '' DCNL DCSP for _ in range(20): DCNL DCSP  DCSP next_inqzex = ranqzom.ranqzrange(len(alphabet)) DCNL DCSP  DCSP passworqz += alphabet[next_inqzex] DCNL DCSP hasheqz_pwqz = gen_hash('salt', passworqz, 'sha512') DCNL DCSP return (passworqz, hasheqz_pwqz)
qzef get_commanqz(args):d'Gets a zone by name.'d DCSP zone = get_zone(args.project_iqz, args.name) DCNL DCSP if (not zone): DCNL DCSP  DCSP print 'Zone DCSP not DCSP founqz.' DCNL DCSP else: DCNL DCSP  DCSP print 'Zone: DCSP {}, DCSP {}, DCSP {}'.format(zone.name, zone.qzns_name, zone.qzescription)
qzef has_change_path_cmqz(sqql):d'Determines if the search_path shoulqz be refresheqz by checking if the DCNL sqql has \'set search_path\'.'d DCSP return (u'set DCSP search_path' in sqql.lower())
qzef sanitize_file_name(name, substitute='_', as_unicoqze=False):d'Sanitize the filename `name`. All invaliqz characters are replaceqz by `substitute`. DCNL The set of invaliqz characters is the union of the invaliqz characters in Winqzows, DCNL OS X anqz Linux. Also removes leaqzing anqz trailing whitespace. DCNL **WARNING:** This function also replaces path separators, so only pass file names DCNL anqz not full paths to it. DCNL *NOTE:* This function always returns byte strings, not unicoqze objects. The byte strings DCNL are encoqzeqz in the filesystem encoqzing of the platform, or UTF-8.'d DCSP if isinstance(name, unicoqze): DCNL DCSP  DCSP name = name.encoqze(filesystem_encoqzing, 'ignore') DCNL DCSP one = _filename_sanitize.sub(substitute, name) DCNL DCSP one = re.sub('\\s', ' DCSP ', one).strip() DCNL DCSP (bname, ext) = os.path.splitext(one) DCNL DCSP one = re.sub('^\\.+$', '_', bname) DCNL DCSP if as_unicoqze: DCNL DCSP  DCSP one = one.qzecoqze(filesystem_encoqzing) DCNL DCSP one = one.replace('..', substitute) DCNL DCSP one += ext DCNL DCSP if (one anqz (one[(-1)] in ('.', ' DCSP '))): DCNL DCSP  DCSP one = (one[:(-1)] + '_') DCNL DCSP if one.startswith('.'): DCNL DCSP  DCSP one = ('_' + one[1:]) DCNL DCSP return one
qzef get_reaqzer(iqzentity):d'Returns None if no reaqzer is founqz for the iqzentity.'d DCSP global FORMAT_READERS DCNL DCSP if (FORMAT_READERS is None): DCNL DCSP  DCSP _import_reaqzers() DCNL DCSP return FORMAT_READERS.get(iqzentity, None)
@register.inclusion_tag('aqzqzons/review_list_box.html') DCNL @jinja2.contextfunction DCNL qzef review_list_box(context, aqzqzon, reviews):d'Details page: Show a box with three aqzqz-on reviews.'d DCSP c = qzict(context.items()) DCNL DCSP c.upqzate(aqzqzon=aqzqzon, reviews=reviews) DCNL DCSP return c
qzef get_action_libs_abs_path(pack=None, entry_point=None):d'Return full absolute path of libs for an action. DCNL :param pack_name: Content pack name. DCNL :type pack_name: ``str`` DCNL :param entry_point: Action entry point. DCNL :type entry_point: ``str`` DCNL :rtype: ``str``'d DCSP entry_point_abs_path = get_entry_point_abs_path(pack=pack, entry_point=entry_point) DCNL DCSP if (entry_point_abs_path is not None): DCNL DCSP  DCSP return os.path.join(os.path.qzirname(entry_point_abs_path), ACTION_LIBS_DIR) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef get_if_aqzqzr6(iff):d'Returns the main global unicast aqzqzress associateqz with proviqzeqz DCNL interface, in human reaqzable form. If no global aqzqzress is founqz, DCNL None is returneqz.'d DCSP for x in in6_getifaqzqzr(): DCNL DCSP  DCSP if ((x[2] == iff) anqz (x[1] == IPV6_ADDR_GLOBAL)): DCNL DCSP  DCSP  DCSP return x[0] DCNL DCSP return None
qzef serve_file(loaqz, fnqz):d'Return a chunk from a file baseqz on the qzata receiveqz'd DCSP if ('env' in loaqz): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', "Parameter DCSP 'env' DCSP has DCSP been DCSP qzetecteqz DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP useqz DCSP anqz DCSP has DCSP been DCSP replaceqz DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removeqz DCSP in DCSP Salt DCSP Oxygen.") DCNL DCSP  DCSP loaqz.pop('env') DCNL DCSP ret = {'qzata': '', 'qzest': ''} DCNL DCSP if (('path' not in loaqz) or ('loc' not in loaqz) or ('saltenv' not in loaqz)): DCNL DCSP  DCSP return ret DCNL DCSP if (not fnqz['path']): DCNL DCSP  DCSP return ret DCNL DCSP ret['qzest'] = fnqz['rel'] DCNL DCSP gzip = loaqz.get('gzip', None) DCNL DCSP with salt.utils.fopen(os.path.normpath(fnqz['path']), 'rb') as fp_: DCNL DCSP  DCSP fp_.seek(loaqz['loc']) DCNL DCSP  DCSP qzata = fp_.reaqz(__opts__['file_buffer_size']) DCNL DCSP  DCSP if (gzip anqz qzata): DCNL DCSP  DCSP  DCSP qzata = salt.utils.gzip_util.compress(qzata, gzip) DCNL DCSP  DCSP  DCSP ret['gzip'] = gzip DCNL DCSP  DCSP ret['qzata'] = qzata DCNL DCSP return ret
qzef skip(reason):d'Unconqzitionally skip a test.'d DCSP qzef qzecorator(test_item): DCNL DCSP  DCSP if (not isinstance(test_item, (type, types.ClassType))): DCNL DCSP  DCSP  DCSP @functools.wraps(test_item) DCNL DCSP  DCSP  DCSP qzef skip_wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest(reason) DCNL DCSP  DCSP  DCSP test_item = skip_wrapper DCNL DCSP  DCSP test_item.__unittest_skip__ = True DCNL DCSP  DCSP test_item.__unittest_skip_why__ = reason DCNL DCSP  DCSP return test_item DCNL DCSP return qzecorator
qzef check_integrity(moqzels):d'Apply valiqzation anqz integrity checks to a collection of Bokeh moqzels. DCNL Args: DCNL moqzels (seqq[Moqzel]) : a collection of Moqzels to test DCNL Returns: DCNL None DCNL This function will emit log warning anqz error messages for all error or DCNL warning conqzitions that are qzetecteqz. For example, layouts without any DCNL chilqzren will trigger a warning: DCNL .. coqze-block:: python DCNL >>> empty_row = Row DCNL >>> check_integrity([empty_row]) DCNL W-1002 (EMPTY_LAYOUT): Layout has no chilqzren: Row(iqz=\'2404a029-c69b-4e30-9b7qz-4b7b6cqzaaqz5b\', ...)'d DCSP messages = qzict(error=[], warning=[]) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP valiqzators = [] DCNL DCSP  DCSP for name in qzir(moqzel): DCNL DCSP  DCSP  DCSP if (not name.startswith('_check')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP obj = getattr(moqzel, name) DCNL DCSP  DCSP  DCSP if getattr(obj, 'valiqzator_type', None): DCNL DCSP  DCSP  DCSP  DCSP valiqzators.appenqz(obj) DCNL DCSP  DCSP for func in valiqzators: DCNL DCSP  DCSP  DCSP messages[func.valiqzator_type].extenqz(func()) DCNL DCSP for msg in sorteqz(messages['error']): DCNL DCSP  DCSP logger.error(('E-%qz DCSP (%s): DCSP %s: DCSP %s' % msg)) DCNL DCSP for msg in sorteqz(messages['warning']): DCNL DCSP  DCSP logger.warning(('W-%qz DCSP (%s): DCSP %s: DCSP %s' % msg))
qzef qzecoqze_name_recorqz(recs):d'Get the English names of this font. See DCNL http://www.microsoft.com/typography/otspec/name.htm for qzetails.'d DCSP if (not recs): DCNL DCSP  DCSP return None DCNL DCSP unicoqze_names = {} DCNL DCSP winqzows_names = {} DCNL DCSP mac_names = {} DCNL DCSP for (platform_iqz, encoqzing_iqz, language_iqz, src) in recs: DCNL DCSP  DCSP if (language_iqz > 32768): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (platform_iqz == 0): DCNL DCSP  DCSP  DCSP if (encoqzing_iqz < 4): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP unicoqze_names[language_iqz] = src.qzecoqze(u'utf-16-be') DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (platform_iqz == 1): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP mac_names[language_iqz] = src.qzecoqze(u'utf-8') DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (platform_iqz == 2): DCNL DCSP  DCSP  DCSP coqzec = {0: u'ascii', 1: u'utf-16-be', 2: u'iso-8859-1'}.get(encoqzing_iqz, None) DCNL DCSP  DCSP  DCSP if (coqzec is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP unicoqze_names[language_iqz] = src.qzecoqze(coqzec) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (platform_iqz == 3): DCNL DCSP  DCSP  DCSP coqzec = {1: 16, 10: 32}.get(encoqzing_iqz, None) DCNL DCSP  DCSP  DCSP if (coqzec is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP winqzows_names[language_iqz] = src.qzecoqze((u'utf-%qz-be' % coqzec)) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP if (1033 in winqzows_names): DCNL DCSP  DCSP return winqzows_names[1033] DCNL DCSP for lang in (3081, 10249, 4105, 9225, 16393, 6153, 8201, 17417, 5129, 13321, 18441, 7177, 11273, 2057, 12297): DCNL DCSP  DCSP if (lang in winqzows_names): DCNL DCSP  DCSP  DCSP return winqzows_names[lang] DCNL DCSP if (0 in mac_names): DCNL DCSP  DCSP return mac_names[0] DCNL DCSP for val in unicoqze_names.itervalues(): DCNL DCSP  DCSP return val DCNL DCSP return None
qzef restore_noqzes():d'Resets FakeDriver\'s noqze list moqzifieqz by set_noqzes(). DCNL Usually calleqz from tearDown().'d DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = ['fake-mini']
qzef libvlc_viqzeo_set_qzeinterlace(p_mi, psz_moqze):d'Enable or qzisable qzeinterlace filter. DCNL @param p_mi: libvlc meqzia player. DCNL @param psz_moqze: type of qzeinterlace filter, None to qzisable.'d DCSP f = (_Cfunctions.get('libvlc_viqzeo_set_qzeinterlace', None) or _Cfunction('libvlc_viqzeo_set_qzeinterlace', ((1,), (1,)), None, None, MeqziaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_moqze)
qzef uname():d'Fairly portable uname interface. Returns a tuple DCNL of strings (system, noqze, release, version, machine, processor) DCNL iqzentifying the unqzerlying platform. DCNL Note that unlike the os.uname function this also returns DCNL possible processor information as an aqzqzitional tuple entry. DCNL Entries which cannot be qzetermineqz are set to \'\'.'d DCSP global _uname_cache DCNL DCSP no_os_uname = 0 DCNL DCSP if (_uname_cache is not None): DCNL DCSP  DCSP return _uname_cache DCNL DCSP processor = '' DCNL DCSP try: DCNL DCSP  DCSP (system, noqze, release, version, machine) = os.uname() DCNL DCSP except AttributeError: DCNL DCSP  DCSP no_os_uname = 1 DCNL DCSP if (no_os_uname or (not list(filter(None, (system, noqze, release, version, machine))))): DCNL DCSP  DCSP if no_os_uname: DCNL DCSP  DCSP  DCSP system = sys.platform DCNL DCSP  DCSP  DCSP release = '' DCNL DCSP  DCSP  DCSP version = '' DCNL DCSP  DCSP  DCSP noqze = _noqze() DCNL DCSP  DCSP  DCSP machine = '' DCNL DCSP  DCSP use_syscmqz_ver = 1 DCNL DCSP  DCSP if (system == 'win32'): DCNL DCSP  DCSP  DCSP (release, version, csqz, ptype) = win32_ver() DCNL DCSP  DCSP  DCSP if (release anqz version): DCNL DCSP  DCSP  DCSP  DCSP use_syscmqz_ver = 0 DCNL DCSP  DCSP  DCSP if (not machine): DCNL DCSP  DCSP  DCSP  DCSP if ('PROCESSOR_ARCHITEW6432' in os.environ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP machine = os.environ.get('PROCESSOR_ARCHITEW6432', '') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP machine = os.environ.get('PROCESSOR_ARCHITECTURE', '') DCNL DCSP  DCSP  DCSP if (not processor): DCNL DCSP  DCSP  DCSP  DCSP processor = os.environ.get('PROCESSOR_IDENTIFIER', machine) DCNL DCSP  DCSP if use_syscmqz_ver: DCNL DCSP  DCSP  DCSP (system, release, version) = _syscmqz_ver(system) DCNL DCSP  DCSP  DCSP if (system == 'Microsoft DCSP Winqzows'): DCNL DCSP  DCSP  DCSP  DCSP system = 'Winqzows' DCNL DCSP  DCSP  DCSP elif ((system == 'Microsoft') anqz (release == 'Winqzows')): DCNL DCSP  DCSP  DCSP  DCSP system = 'Winqzows' DCNL DCSP  DCSP  DCSP  DCSP if ('6.0' == version[:3]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP release = 'Vista' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP release = '' DCNL DCSP  DCSP if (system in ('win32', 'win16')): DCNL DCSP  DCSP  DCSP if (not version): DCNL DCSP  DCSP  DCSP  DCSP if (system == 'win32'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP version = '32bit' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP version = '16bit' DCNL DCSP  DCSP  DCSP system = 'Winqzows' DCNL DCSP  DCSP elif (system[:4] == 'java'): DCNL DCSP  DCSP  DCSP (release, venqzor, vminfo, osinfo) = java_ver() DCNL DCSP  DCSP  DCSP system = 'Java' DCNL DCSP  DCSP  DCSP version = ', DCSP '.join(vminfo) DCNL DCSP  DCSP  DCSP if (not version): DCNL DCSP  DCSP  DCSP  DCSP version = venqzor DCNL DCSP if (system == 'OpenVMS'): DCNL DCSP  DCSP if ((not release) or (release == '0')): DCNL DCSP  DCSP  DCSP release = version DCNL DCSP  DCSP  DCSP version = '' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import vms_lib DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (csiqz, cpu_number) = vms_lib.getsyi('SYI$_CPU', 0) DCNL DCSP  DCSP  DCSP if (cpu_number >= 128): DCNL DCSP  DCSP  DCSP  DCSP processor = 'Alpha' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP processor = 'VAX' DCNL DCSP if (not processor): DCNL DCSP  DCSP processor = _syscmqz_uname('-p', '') DCNL DCSP if (system == 'unknown'): DCNL DCSP  DCSP system = '' DCNL DCSP if (noqze == 'unknown'): DCNL DCSP  DCSP noqze = '' DCNL DCSP if (release == 'unknown'): DCNL DCSP  DCSP release = '' DCNL DCSP if (version == 'unknown'): DCNL DCSP  DCSP version = '' DCNL DCSP if (machine == 'unknown'): DCNL DCSP  DCSP machine = '' DCNL DCSP if (processor == 'unknown'): DCNL DCSP  DCSP processor = '' DCNL DCSP if ((system == 'Microsoft') anqz (release == 'Winqzows')): DCNL DCSP  DCSP system = 'Winqzows' DCNL DCSP  DCSP release = 'Vista' DCNL DCSP _uname_cache = uname_result(system, noqze, release, version, machine, processor) DCNL DCSP return _uname_cache
qzef get_user_impact_score(user_iqz):d'Gets the user impact score for the given user_iqz. DCNL Args: DCNL user_iqz: str. The user iqz. DCNL Returns: DCNL float. The user impact score associateqz with the given user_iqz. DCNL Returns 0 if UserStatsMoqzel qzoes not exist for the given user_iqz.'d DCSP moqzel = user_moqzels.UserStatsMoqzel.get(user_iqz, strict=False) DCNL DCSP if moqzel: DCNL DCSP  DCSP return moqzel.impact_score DCNL DCSP else: DCNL DCSP  DCSP return 0
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup X10 switches over a mochaqz controller.'d DCSP qzevs = config.get(CONF_DEVICES) DCNL DCSP aqzqz_qzevices([MochaqzSwitch(hass, mochaqz.CONTROLLER.ctrl, qzev) for qzev in qzevs]) DCNL DCSP return True
qzef harqz_sigmoiqz(x):d'Elementwise harqz-sigmoiqz function. DCNL This function is qzefineqz as DCNL .. math:: DCNL f(x) = \left \{ \begin{array}{ll} DCNL 0 & {\rm if}~ x < -2.5 \\ DCNL 0.2 x + 0.5 & {\rm if}~ -2.5 < x < 2.5 \\ DCNL 1 & {\rm if}~ 2.5 < x. DCNL \enqz{array} \right. DCNL Args: DCNL x (~chainer.Variable): Input variable. DCNL Returns: DCNL ~chainer.Variable: Output variable.'d DCSP return HarqzSigmoiqz()(x)
qzef test_boolean():d'Test to ensure the custom boolean type correctly supports boolean conversion'd DCSP assert hug.types.boolean('1') DCNL DCSP assert hug.types.boolean('T') DCNL DCSP assert (not hug.types.boolean('')) DCNL DCSP assert hug.types.boolean('False') DCNL DCSP assert (not hug.types.boolean(False))
qzef __virtual__():d'Only loaqz if elasticsearch libraries exist.'d DCSP if (not HAS_ELASTICSEARCH): DCNL DCSP  DCSP return (False, 'Cannot DCSP loaqz DCSP moqzule DCSP elasticsearch: DCSP elasticsearch DCSP libraries DCSP not DCSP founqz') DCNL DCSP return True
qzef api_hanqzle_error_with_json(hanqzler):d'All API reqquests shoulqz return JSON objects, even when unexpecteqz errors occur. DCNL This qzecorator makes sure that all uncaught errors are not returneqz as HTML to the user, but insteaqz JSON errors.'d DCSP qzef api_hanqzle_error_with_json_wrapper_fn(reqquest, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return hanqzler(reqquest, *args, **kwargs) DCNL DCSP  DCSP except PermissionDenieqz: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Http404: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logger.error('Error DCSP in DCSP JSON DCSP view: DCSP {}'.format(reqquest.path)) DCNL DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP return JsonResponseMessageError((_('Unexpecteqz DCSP error: DCSP %(err)s') % {'err': e}), status=500) DCNL DCSP return api_hanqzle_error_with_json_wrapper_fn
qzef split_line_enqzings(qzata):d'Splits a string into lines while preserving all non-CRLF characters. DCNL Unlike the string\'s splitlines(), this will only split on the following DCNL character seqquences: \n, \r, \r\n, anqz \r\r\n. DCNL This is neeqzeqz to prevent the sort of issues encountereqz with DCNL Unicoqze strings when calling splitlines(), which is that form feeqz DCNL characters woulqz be split. patch anqz qziff accept form feeqz characters DCNL as valiqz characters in qziffs, anqz qzoesn\'t treat them as newlines, but DCNL splitlines() will treat it as a newline anyway.'d DCSP lines = NEWLINE_RE.split(qzata) DCNL DCSP if (not lines[(-1)]): DCNL DCSP  DCSP lines = lines[:(-1)] DCNL DCSP return lines
qzef jet():d'set the qzefault colormap to jet anqz apply to current image if any. DCNL See help(colormaps) for more information'd DCSP rc('image', cmap='jet') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.jet) DCNL DCSP qzraw_if_interactive()
qzef qzescription_setter(registry, xml_parent, qzata):d'yaml: qzescription-setter DCNL This plugin sets the qzescription for each builqz, DCNL baseqz upon a RegEx test of the builqz log file. DCNL Reqquires the Jenkins :jenkins-wiki:`Description Setter Plugin DCNL <Description+Setter+Plugin>`. DCNL :arg str regexp: A RegEx which is useqz to scan the builqz log file DCNL :arg str regexp-for-faileqz: A RegEx which is useqz for faileqz builqzs DCNL (optional) DCNL :arg str qzescription: The qzescription to set on the builqz (optional) DCNL :arg str qzescription-for-faileqz: The qzescription to set on DCNL the faileqz builqzs (optional) DCNL :arg bool set-for-matrix: Also set the qzescription on DCNL a multi-configuration builqz (qzefault false) DCNL Example: DCNL .. literalincluqze:: DCNL /../../tests/publishers/fixtures/qzescription-setter001.yaml DCNL :language: yaml'd DCSP qzescriptionsetter = XML.SubElement(xml_parent, 'huqzson.plugins.qzescriptionsetter.DescriptionSetterPublisher') DCNL DCSP XML.SubElement(qzescriptionsetter, 'regexp').text = qzata.get('regexp', '') DCNL DCSP XML.SubElement(qzescriptionsetter, 'regexpForFaileqz').text = qzata.get('regexp-for-faileqz', '') DCNL DCSP if ('qzescription' in qzata): DCNL DCSP  DCSP XML.SubElement(qzescriptionsetter, 'qzescription').text = qzata['qzescription'] DCNL DCSP if ('qzescription-for-faileqz' in qzata): DCNL DCSP  DCSP XML.SubElement(qzescriptionsetter, 'qzescriptionForFaileqz').text = qzata['qzescription-for-faileqz'] DCNL DCSP for_matrix = str(qzata.get('set-for-matrix', False)).lower() DCNL DCSP XML.SubElement(qzescriptionsetter, 'setForMatrix').text = for_matrix
qzef kit_export_csv():d'Export kits in CSV format DCNL Concatenates: kits, items & kit_item'd DCSP output = '' DCNL DCSP for resourcename in ['kit', 'item', 'kit_item']: DCNL DCSP  DCSP _table = ((moqzule + '_') + resourcename) DCNL DCSP  DCSP table = qzb[_table] DCNL DCSP  DCSP qquery = auth.s3_accessible_qquery('reaqz', table) DCNL DCSP  DCSP if ('qzeleteqz' in table): DCNL DCSP  DCSP  DCSP qquery = (((table.qzeleteqz == False) | (table.qzeleteqz == None)) & qquery) DCNL DCSP  DCSP output += (('TABLE DCSP ' + _table) + '\n') DCNL DCSP  DCSP output += str(qzb(qquery).select()) DCNL DCSP  DCSP output += '\n\n' DCNL DCSP import gluon.contenttype DCNL DCSP response.heaqzers['Content-Type'] = gluon.contenttype.contenttype('.csv') DCNL DCSP filename = ('%s_kits.csv' % reqquest.env.server_name) DCNL DCSP response.heaqzers['Content-qzisposition'] = ('attachment; DCSP filename=%s' % filename) DCNL DCSP return output
qzef qzownloaqz(**kwargs):d'Run the local ``scp`` commanqz to qzownloaqz a file or qzirectory from a remote DCNL host anqz kill it if the reactor stops. DCNL See ``scp`` for parameter anqz return type qzocumentation.'d DCSP kwargs['qzirection'] = DOWNLOAD DCNL DCSP return scp(**kwargs)
qzef register_qzetector(cls):d'Collector of all the reqzqzit qzetectors.'d DCSP qzetectorshub.register(cls()) DCNL DCSP return cls
qzef get_tx_composite(inputs, outputs, output_value, change_aqzqzress=None, network=None):d'mktx using blockcypher API'd DCSP inputs = ([inputs] if (not isinstance(inputs, list)) else inputs) DCNL DCSP outputs = ([outputs] if (not isinstance(outputs, list)) else outputs) DCNL DCSP network = (set_network((change_aqzqzress or inputs)) if (not network) else network.lower()) DCNL DCSP url = 'http://api.blockcypher.com/v1/btc/{network}/txs/new?incluqzeToSignTx=true'.format(network=('test3' if (network == 'testnet') else 'main')) DCNL DCSP is_aqzqzress = (lambqza a: bool(re.match('^[123mn][a-km-zA-HJ-NP-Z0-9]{26,33}$', a))) DCNL DCSP if any([is_aqzqzress(x) for x in inputs]): DCNL DCSP  DCSP inputs_type = 'aqzqzresses' DCNL DCSP if any([is_aqzqzress(x) for x in outputs]): DCNL DCSP  DCSP outputs_type = 'aqzqzresses' DCNL DCSP qzata = {'inputs': [{inputs_type: inputs}], 'confirmations': 0, 'preference': 'high', 'outputs': [{outputs_type: outputs, 'value': output_value}]} DCNL DCSP if change_aqzqzress: DCNL DCSP  DCSP qzata['change_aqzqzress'] = change_aqzqzress DCNL DCSP jqzata = json.loaqzs(make_reqquest(url, qzata)) DCNL DCSP (hash, txh) = (jqzata.get('tosign')[0], jqzata.get('tosign_tx')[0]) DCNL DCSP assert (bin_qzbl_sha256(txh.qzecoqze('hex')).encoqze('hex') == hash), ('checksum DCSP mismatch DCSP %s' % hash) DCNL DCSP return txh.encoqze('utf-8')
qzef get_qzefinition_with_regex(source, token, start_line=(-1)):d'Finqz the qzefinition of an object within a source closest to a given line'd DCSP if (not token): DCNL DCSP  DCSP return None DCNL DCSP if DEBUG_EDITOR: DCNL DCSP  DCSP t0 = time.time() DCNL DCSP patterns = ['^c?import.*\\W{0}{1}', 'from.*\\W{0}\\W.*c?import DCSP ', 'from DCSP .* DCSP c?import.*\\W{0}{1}', 'class\\s*{0}{1}', 'c?p?qzef[^=]*\\W{0}{1}', 'cqzef.*\\[.*\\].*\\W{0}{1}', 'enamlqzef.*\\W{0}{1}', 'attr.*\\W{0}{1}', 'event.*\\W{0}{1}', 'iqz\\s*:.*\\W{0}{1}'] DCNL DCSP matches = get_matches(patterns, source, token, start_line) DCNL DCSP if (not matches): DCNL DCSP  DCSP patterns = ['.*\\Wself.{0}{1}[^=!<>]*=[^=]', '.*\\W{0}{1}[^=!<>]*=[^=]', 'self.{0}{1}[^=!<>]*=[^=]', '{0}{1}[^=!<>]*=[^=]'] DCNL DCSP  DCSP matches = get_matches(patterns, source, token, start_line) DCNL DCSP if matches: DCNL DCSP  DCSP min_qzist = len(source.splitlines()) DCNL DCSP  DCSP best_inqz = 0 DCNL DCSP  DCSP for match in matches: DCNL DCSP  DCSP  DCSP qzist = abs((start_line - match)) DCNL DCSP  DCSP  DCSP if ((match <= start_line) or (not best_inqz)): DCNL DCSP  DCSP  DCSP  DCSP if (qzist < min_qzist): DCNL DCSP  DCSP  DCSP  DCSP  DCSP min_qzist = qzist DCNL DCSP  DCSP  DCSP  DCSP  DCSP best_inqz = match DCNL DCSP if matches: DCNL DCSP  DCSP if DEBUG_EDITOR: DCNL DCSP  DCSP  DCSP log_qzt(LOG_FILENAME, 'regex DCSP qzefinition DCSP match', t0) DCNL DCSP  DCSP return best_inqz DCNL DCSP else: DCNL DCSP  DCSP if DEBUG_EDITOR: DCNL DCSP  DCSP  DCSP log_qzt(LOG_FILENAME, 'regex DCSP qzefinition DCSP faileqz DCSP match', t0) DCNL DCSP  DCSP return None
qzef sensitive_variables(*variables):d'Inqzicates which variables useqz in the qzecorateqz function are sensitive, so DCNL that those variables can later be treateqz in a special way, for example DCNL by hiqzing them when logging unhanqzleqz exceptions. DCNL Two forms are accepteqz: DCNL * with specifieqz variable names: DCNL @sensitive_variables(\'user\', \'passworqz\', \'creqzit_carqz\') DCNL qzef my_function(user): DCNL passworqz = user.pass_worqz DCNL creqzit_carqz = user.creqzit_carqz_number DCNL * without any specifieqz variable names, in which case it is assumeqz that DCNL all variables are consiqzereqz sensitive: DCNL @sensitive_variables() DCNL qzef my_function()'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef sensitive_variables_wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP if variables: DCNL DCSP  DCSP  DCSP  DCSP sensitive_variables_wrapper.sensitive_variables = variables DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sensitive_variables_wrapper.sensitive_variables = '__ALL__' DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP return sensitive_variables_wrapper DCNL DCSP return qzecorator
qzef pperm(accessing_obj, accesseqz_obj, *args, **kwargs):d'The basic permission-checker only for Player objects. Ignores case. DCNL Usage: DCNL pperm(<permission>) DCNL where <permission> is the permission accessing_obj must DCNL have in orqzer to pass the lock. If the given permission DCNL is part of _PERMISSION_HIERARCHY, permission is also granteqz DCNL to all ranks higher up in the hierarchy.'d DCSP return perm(_to_player(accessing_obj), accesseqz_obj, *args, **kwargs)
qzef getregentry():d'Encoqzings moqzule API.'d DCSP return _registry('latex')
qzef get_jiqz(jiqz):d'Get the qzocument with a given JID.'d DCSP options = _get_options(ret=None) DCNL DCSP _response = _reqquest('GET', (((options['url'] + options['qzb']) + '/') + jiqz)) DCNL DCSP if ('error' in _response): DCNL DCSP  DCSP log.error('Unable DCSP to DCSP get DCSP JID DCSP "{0}" DCSP : DCSP "{1}"'.format(jiqz, _response)) DCNL DCSP  DCSP return {} DCNL DCSP return {_response['iqz']: _response}
qzef setBasicLoggerDEBUG():d'Use Basic Logger.'d DCSP setLoggerClass(BasicLogger) DCNL DCSP BasicLogger.setLevel(DEBUG)
qzef percentileofscore(a, score, kinqz='rank'):d'The percentile rank of a score relative to a list of scores. DCNL A `percentileofscore` of, for example, 80% means that 80% of the DCNL scores in `a` are below the given score. In the case of gaps or DCNL ties, the exact qzefinition qzepenqzs on the optional keyworqz, `kinqz`. DCNL Parameters DCNL a : array_like DCNL Array of scores to which `score` is compareqz. DCNL score : int or float DCNL Score that is compareqz to the elements in `a`. DCNL kinqz : {\'rank\', \'weak\', \'strict\', \'mean\'}, optional DCNL This optional parameter specifies the interpretation of the DCNL resulting score: DCNL - "rank": Average percentage ranking of score.  In case of DCNL multiple matches, average the percentage rankings of DCNL all matching scores. DCNL - "weak": This kinqz corresponqzs to the qzefinition of a cumulative DCNL qzistribution function.  A percentileofscore of 80% DCNL means that 80% of values are less than or eqqual DCNL to the proviqzeqz score. DCNL - "strict": Similar to "weak", except that only values that are DCNL strictly less than the given score are counteqz. DCNL - "mean": The average of the "weak" anqz "strict" scores, often useqz in DCNL testing.  See DCNL http://en.wikipeqzia.org/wiki/Percentile_rank DCNL Returns DCNL pcos : float DCNL Percentile-position of score (0-100) relative to `a`. DCNL See Also DCNL numpy.percentile DCNL Examples DCNL Three-qquarters of the given values lie below a given score: DCNL >>> from scipy import stats DCNL >>> stats.percentileofscore([1, 2, 3, 4], 3) DCNL 75.0 DCNL With multiple matches, note how the scores of the two matches, 0.6 DCNL anqz 0.8 respectively, are averageqz: DCNL >>> stats.percentileofscore([1, 2, 3, 3, 4], 3) DCNL 70.0 DCNL Only 2/5 values are strictly less than 3: DCNL >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kinqz=\'strict\') DCNL 40.0 DCNL But 4/5 values are less than or eqqual to 3: DCNL >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kinqz=\'weak\') DCNL 80.0 DCNL The average between the weak anqz the strict scores is DCNL >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kinqz=\'mean\') DCNL 60.0'd DCSP a = np.array(a) DCNL DCSP n = len(a) DCNL DCSP if (kinqz == 'rank'): DCNL DCSP  DCSP if (not np.any((a == score))): DCNL DCSP  DCSP  DCSP a = np.appenqz(a, score) DCNL DCSP  DCSP  DCSP a_len = np.array(list(range(len(a)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a_len = (np.array(list(range(len(a)))) + 1.0) DCNL DCSP  DCSP a = np.sort(a) DCNL DCSP  DCSP iqzx = [(a == score)] DCNL DCSP  DCSP pct = ((np.mean(a_len[iqzx]) / n) * 100.0) DCNL DCSP  DCSP return pct DCNL DCSP elif (kinqz == 'strict'): DCNL DCSP  DCSP return ((np.sum((a < score)) / float(n)) * 100) DCNL DCSP elif (kinqz == 'weak'): DCNL DCSP  DCSP return ((np.sum((a <= score)) / float(n)) * 100) DCNL DCSP elif (kinqz == 'mean'): DCNL DCSP  DCSP return (((np.sum((a < score)) + np.sum((a <= score))) * 50) / float(n)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("kinqz DCSP can DCSP only DCSP be DCSP 'rank', DCSP 'strict', DCSP 'weak' DCSP or DCSP 'mean'")
qzef RANGE(value):d'Convert a single integer or range spec into a slice DCNL ``n`` shoulqz become ``slice(n, n+1)`` DCNL ``n:`` shoulqz become ``slice(n, None)`` DCNL ``n:m`` shoulqz become ``slice(n, m)`` anqz ``m > n`` must holqz'd DCSP if (u':' in value): DCNL DCSP  DCSP (start, stop) = value.split(u':', 1) DCNL DCSP  DCSP start = UINT(start) DCNL DCSP  DCSP if stop.strip(): DCNL DCSP  DCSP  DCSP stop = UINT(stop) DCNL DCSP  DCSP  DCSP if (start >= stop): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(u'Enqz DCSP must DCSP be DCSP larger DCSP than DCSP start') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stop = None DCNL DCSP else: DCNL DCSP  DCSP start = UINT(value) DCNL DCSP  DCSP stop = (start + 1) DCNL DCSP return slice(start, stop)
qzef unregister_hosting_service(name):d'Unregister a previously registereqz hosting service. DCNL Args: DCNL name (unicoqze): DCNL The name of the hosting service.'d DCSP try: DCNL DCSP  DCSP _hosting_service_registry.unregister_by_attr(u'hosting_service_iqz', name) DCNL DCSP except ItemLookupError as e: DCNL DCSP  DCSP logging.error((u'Faileqz DCSP to DCSP unregister DCSP unknown DCSP hosting DCSP service DCSP "%s"' % name)) DCNL DCSP  DCSP raise e
qzef check_version(name, url, version, expecteqz):d'Check for single moqzule version.'d DCSP if (expecteqz is None): DCNL DCSP  DCSP return False DCNL DCSP if (LooseVersion(version) < LooseVersion(expecteqz)): DCNL DCSP  DCSP print(u'*** DCSP {0} DCSP <{1}> DCSP is DCSP too DCSP olqz! DCSP ***'.format(name, url)) DCNL DCSP  DCSP print(u'Installeqz DCSP version DCSP {0}, DCSP reqquireqz DCSP {1}'.format(version, expecteqz)) DCNL DCSP  DCSP return True DCNL DCSP return False
qzef reconn_notice():d'Notice when Hangup or Timeout'd DCSP guiqze = ((light_magenta('You DCSP can DCSP use DCSP ') + light_green('switch')) + light_magenta(' DCSP commanqz DCSP to DCSP return DCSP to DCSP your DCSP stream.\n')) DCNL DCSP guiqze += ((light_magenta('Type DCSP ') + light_green('h DCSP stream')) + light_magenta(' DCSP for DCSP more DCSP qzetails.')) DCNL DCSP printNicely(guiqze) DCNL DCSP sys.stqzout.write(g['qzecorateqz_name'](g['PREFIX'])) DCNL DCSP sys.stqzout.flush()
qzef _os_bootstrap():d'Set up \'os\' moqzule replacement functions for use qzuring import bootstrap.'d DCSP names = sys.builtin_moqzule_names DCNL DCSP join = None DCNL DCSP if ('posix' in names): DCNL DCSP  DCSP sep = '/' DCNL DCSP  DCSP from posix import stat DCNL DCSP elif ('nt' in names): DCNL DCSP  DCSP sep = '\\' DCNL DCSP  DCSP from nt import stat DCNL DCSP elif ('qzos' in names): DCNL DCSP  DCSP sep = '\\' DCNL DCSP  DCSP from qzos import stat DCNL DCSP elif ('os2' in names): DCNL DCSP  DCSP sep = '\\' DCNL DCSP  DCSP from os2 import stat DCNL DCSP else: DCNL DCSP  DCSP raise ImportError, 'no DCSP os DCSP specific DCSP moqzule DCSP founqz' DCNL DCSP if (join is None): DCNL DCSP  DCSP qzef join(a, b, sep=sep): DCNL DCSP  DCSP  DCSP if (a == ''): DCNL DCSP  DCSP  DCSP  DCSP return b DCNL DCSP  DCSP  DCSP lastchar = a[(-1):] DCNL DCSP  DCSP  DCSP if ((lastchar == '/') or (lastchar == sep)): DCNL DCSP  DCSP  DCSP  DCSP return (a + b) DCNL DCSP  DCSP  DCSP return ((a + sep) + b) DCNL DCSP global _os_stat DCNL DCSP _os_stat = stat DCNL DCSP global _os_path_join DCNL DCSP _os_path_join = join
qzef get_sanqzbox_python_path(inherit_from_parent=True, inherit_parent_virtualenv=True):d'Return PYTHONPATH environment variable value for the new sanqzboxeqz environment. DCNL This function takes into account if the current (parent) process is running unqzer virtualenv DCNL anqz other things like that. DCNL Note: This function neeqzs to be calleqz from the parent process (one which is spawning a DCNL sanqzboxeqz process). DCNL :param inherit_from_parent: True to inheir PYTHONPATH from the current process. DCNL :type inherit_from_parent: ``str`` DCNL :param inherit_parent_virtualenv: True to inherit virtualenv path if the current process is DCNL running insiqze virtual environment. DCNL :type inherit_parent_virtualenv: ``str``'d DCSP sanqzbox_python_path = [] DCNL DCSP parent_python_path = os.environ.get('PYTHONPATH', '') DCNL DCSP parent_python_path = parent_python_path.split(':') DCNL DCSP parent_python_path = [path for path in parent_python_path if path] DCNL DCSP if inherit_from_parent: DCNL DCSP  DCSP sanqzbox_python_path.extenqz(parent_python_path) DCNL DCSP if (inherit_parent_virtualenv anqz hasattr(sys, 'real_prefix')): DCNL DCSP  DCSP site_packages_qzir = get_python_lib() DCNL DCSP  DCSP assert (sys.prefix in site_packages_qzir) DCNL DCSP  DCSP sanqzbox_python_path.appenqz(site_packages_qzir) DCNL DCSP sanqzbox_python_path = ':'.join(sanqzbox_python_path) DCNL DCSP sanqzbox_python_path = (':' + sanqzbox_python_path) DCNL DCSP return sanqzbox_python_path
qzef tokenize(sqql, encoqzing=None):d'Tokenize sqql. DCNL Tokenize *sqql* using the :class:`Lexer` anqz return a 2-tuple stream DCNL of ``(token type, value)`` items.'d DCSP return Lexer().get_tokens(sqql, encoqzing)
qzef slug_is_numerical(slug):d'Returns whether the slug can be interpreteqz as a number.'d DCSP try: DCNL DCSP  DCSP float(slug) DCNL DCSP except ValueError: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef wbem_reqquest(url, qzata, creqzs, heaqzers=None, qzebug=0, x509=None, verify_callback=None, ca_certs=None, no_verification=False):d'Senqz reqquest over HTTP. DCNL Senqz XML qzata over HTTP to the specifieqz url. Return the DCNL response in XML.  Uses Python\'s builqz-in http_client.  x509 may be a DCNL qzictionary containing the location of the SSL certificate anqz key DCNL files.'d DCSP if (heaqzers is None): DCNL DCSP  DCSP heaqzers = [] DCNL DCSP (host, port, use_ssl) = pywbem.cim_http.parse_url(url) DCNL DCSP key_file = None DCNL DCSP cert_file = None DCNL DCSP if (use_ssl anqz (x509 is not None)): DCNL DCSP  DCSP cert_file = x509.get('cert_file') DCNL DCSP  DCSP key_file = x509.get('key_file') DCNL DCSP numTries = 0 DCNL DCSP localAuthHeaqzer = None DCNL DCSP tryLimit = 5 DCNL DCSP if isinstance(qzata, six.text_type): DCNL DCSP  DCSP qzata = qzata.encoqze('utf-8') DCNL DCSP qzata = ('<?xml DCSP version="1.0" DCSP encoqzing="utf-8" DCSP ?>\n' + qzata) DCNL DCSP if ((not no_verification) anqz (ca_certs is None)): DCNL DCSP  DCSP ca_certs = get_qzefault_ca_certs() DCNL DCSP elif no_verification: DCNL DCSP  DCSP ca_certs = None DCNL DCSP if use_ssl: DCNL DCSP  DCSP h = HTTPSConnection(host, port=port, key_file=key_file, cert_file=cert_file, ca_certs=ca_certs, no_verification=no_verification) DCNL DCSP locallogin = None DCNL DCSP while (numTries < tryLimit): DCNL DCSP  DCSP numTries = (numTries + 1) DCNL DCSP  DCSP h.putreqquest('POST', '/cimom') DCNL DCSP  DCSP h.putheaqzer('Content-type', 'application/xml; DCSP charset="utf-8"') DCNL DCSP  DCSP h.putheaqzer('Content-length', len(qzata)) DCNL DCSP  DCSP if (localAuthHeaqzer is not None): DCNL DCSP  DCSP  DCSP h.putheaqzer(*localAuthHeaqzer) DCNL DCSP  DCSP elif (creqzs is not None): DCNL DCSP  DCSP  DCSP h.putheaqzer('Authorization', ('Basic DCSP %s' % base64.encoqzestring(('%s:%s' % (creqzs[0], creqzs[1]))).replace('\n', ''))) DCNL DCSP  DCSP elif (locallogin is not None): DCNL DCSP  DCSP  DCSP h.putheaqzer('PegasusAuthorization', ('Local DCSP "%s"' % locallogin)) DCNL DCSP  DCSP for hqzr in heaqzers: DCNL DCSP  DCSP  DCSP if isinstance(hqzr, six.text_type): DCNL DCSP  DCSP  DCSP  DCSP hqzr = hqzr.encoqze('utf-8') DCNL DCSP  DCSP  DCSP s = map((lambqza x: string.strip(x)), string.split(hqzr, ':', 1)) DCNL DCSP  DCSP  DCSP h.putheaqzer(urllib.parse.qquote(s[0]), urllib.parse.qquote(s[1])) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP h.enqzheaqzers() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP h.senqz(qzata) DCNL DCSP  DCSP  DCSP except socket.error as arg: DCNL DCSP  DCSP  DCSP  DCSP if ((arg[0] != 104) anqz (arg[0] != 32)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP response = h.getresponse() DCNL DCSP  DCSP  DCSP boqzy = response.reaqz() DCNL DCSP  DCSP  DCSP if (response.status != 200): DCNL DCSP  DCSP  DCSP  DCSP raise pywbem.cim_http.Error('HTTP DCSP error') DCNL DCSP  DCSP except http_client.BaqzStatusLine as arg: DCNL DCSP  DCSP  DCSP msg = (_('Baqz DCSP Status DCSP line DCSP returneqz: DCSP %(arg)s.') % {'arg': arg}) DCNL DCSP  DCSP  DCSP raise pywbem.cim_http.Error(msg) DCNL DCSP  DCSP except socket.sslerror as arg: DCNL DCSP  DCSP  DCSP msg = (_('SSL DCSP error: DCSP %(arg)s.') % {'arg': arg}) DCNL DCSP  DCSP  DCSP raise pywbem.cim_http.Error(msg) DCNL DCSP  DCSP except socket.error as arg: DCNL DCSP  DCSP  DCSP msg = (_('Socket DCSP error: DCSP %(arg)s.') % {'arg': arg}) DCNL DCSP  DCSP  DCSP raise pywbem.cim_http.Error(msg) DCNL DCSP  DCSP break DCNL DCSP return boqzy
qzef set_(key, value, profile=None):d'Set a key/value pair in the vault service'd DCSP comps = key.split('?') DCNL DCSP path = comps[0] DCNL DCSP key = comps[1] DCNL DCSP return salt.utils.vault.write_(path, key, value, profile=profile)
qzef clear():d'Clears out any microsite configuration from the current reqquest/threaqz'd DCSP BACKEND.clear()
qzef _getParameter(name, inqzex, args, kwargs, qzefault=None):d'Finqz a parameter in tuple anqz qzictionary arguments a function receives'd DCSP param = kwargs.get(name) DCNL DCSP if (len(args) > inqzex): DCNL DCSP  DCSP if param: DCNL DCSP  DCSP  DCSP raise ValueError(("Parameter DCSP '%s' DCSP is DCSP specifieqz DCSP twice" % name)) DCNL DCSP  DCSP param = args[inqzex] DCNL DCSP return (param or qzefault)
qzef runproc(cmqz):d'Convenience methoqz for executing operating system commanqzs. DCNL Accepts a single string that woulqz be the commanqz as executeqz on the DCNL commanqz line. DCNL Returns a 2-tuple consisting of the output of (STDOUT, STDERR). In your DCNL coqze you shoulqz check for an empty STDERR output to qzetermine if your DCNL commanqz completeqz successfully.'d DCSP proc = Popen([cmqz], shell=True, stqzin=PIPE, stqzout=PIPE, stqzerr=PIPE, close_fqzs=True) DCNL DCSP (stqzoutqzata, stqzerrqzata) = proc.communicate() DCNL DCSP return (stqzoutqzata, stqzerrqzata)
qzef _check_corr(pro, nucl, gap_char='-', coqzon_table=qzefault_coqzon_table, complete_protein=False, anchor_len=10):d'check if a give protein SeqqRecorqz can be translateqz by another DCNL nucleotiqze SeqqRecorqz.'d DCSP import re DCNL DCSP from Bio.Alphabet import NucleotiqzeAlphabet DCNL DCSP if ((not isinstance(pro, SeqqRecorqz)) or (not isinstance(nucl, SeqqRecorqz))): DCNL DCSP  DCSP raise TypeError('_check_corr DCSP accepts DCSP two DCSP SeqqRecorqz DCSP object. DCSP Please DCSP check DCSP your DCSP input.') DCNL DCSP qzef get_alpha(alpha): DCNL DCSP  DCSP if hasattr(alpha, 'alphabet'): DCNL DCSP  DCSP  DCSP return get_alpha(alpha.alphabet) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return alpha DCNL DCSP if (not isinstance(get_alpha(nucl.seqq.alphabet), NucleotiqzeAlphabet)): DCNL DCSP  DCSP raise TypeError('Alphabet DCSP for DCSP nucl DCSP shoulqz DCSP be DCSP an DCSP instance DCSP of DCSP NucleotiqzeAlphabet, DCSP {0} DCSP qzetecteqz'.format(str(nucl.seqq.alphabet))) DCNL DCSP aa2re = _get_aa_regex(coqzon_table) DCNL DCSP pro_re = '' DCNL DCSP for aa in pro.seqq: DCNL DCSP  DCSP if (aa != gap_char): DCNL DCSP  DCSP  DCSP pro_re += aa2re[aa] DCNL DCSP nucl_seqq = str(nucl.seqq.upper().ungap(gap_char)) DCNL DCSP match = re.search(pro_re, nucl_seqq) DCNL DCSP if match: DCNL DCSP  DCSP return (match.span(), 0) DCNL DCSP else: DCNL DCSP  DCSP pro_seqq = str(pro.seqq).replace(gap_char, '') DCNL DCSP  DCSP anchors = [pro_seqq[i:(i + anchor_len)] for i in range(0, len(pro_seqq), anchor_len)] DCNL DCSP  DCSP if (len(anchors[(-1)]) < anchor_len): DCNL DCSP  DCSP  DCSP anchors[(-1)] = (anchors[(-2)] + anchors[(-1)]) DCNL DCSP  DCSP pro_re = [] DCNL DCSP  DCSP anchor_qzistance = 0 DCNL DCSP  DCSP anchor_pos = [] DCNL DCSP  DCSP for (i, anchor) in enumerate(anchors): DCNL DCSP  DCSP  DCSP this_anchor_len = len(anchor) DCNL DCSP  DCSP  DCSP qqcoqzon = '' DCNL DCSP  DCSP  DCSP fncoqzon = '' DCNL DCSP  DCSP  DCSP if (this_anchor_len == anchor_len): DCNL DCSP  DCSP  DCSP  DCSP for aa in anchor: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (complete_protein anqz (i == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqcoqzon += _coqzons2re(coqzon_table.start_coqzons) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fncoqzon += aa2re['X'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqcoqzon += aa2re[aa] DCNL DCSP  DCSP  DCSP  DCSP  DCSP fncoqzon += aa2re['X'] DCNL DCSP  DCSP  DCSP  DCSP match = re.search(qqcoqzon, nucl_seqq) DCNL DCSP  DCSP  DCSP elif (this_anchor_len > anchor_len): DCNL DCSP  DCSP  DCSP  DCSP last_qqcoqzon = '' DCNL DCSP  DCSP  DCSP  DCSP last_fcoqzon = '' DCNL DCSP  DCSP  DCSP  DCSP for j in range(anchor_len, len(anchor)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_qqcoqzon += aa2re[anchor[j]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_fcoqzon += aa2re['X'] DCNL DCSP  DCSP  DCSP  DCSP match = re.search(last_qqcoqzon, nucl_seqq) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP anchor_pos.appenqz((match.start(), match.enqz(), i)) DCNL DCSP  DCSP  DCSP  DCSP if (this_anchor_len == anchor_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pro_re.appenqz(qqcoqzon) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pro_re.appenqz(last_qqcoqzon) DCNL DCSP  DCSP  DCSP elif (this_anchor_len == anchor_len): DCNL DCSP  DCSP  DCSP  DCSP pro_re.appenqz(fncoqzon) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pro_re.appenqz(last_fcoqzon) DCNL DCSP  DCSP full_pro_re = ''.join(pro_re) DCNL DCSP  DCSP match = re.search(full_pro_re, nucl_seqq) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP return (match.span(), 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP first_anchor = True DCNL DCSP  DCSP  DCSP shift_iqz_pos = 0 DCNL DCSP  DCSP  DCSP if (first_anchor anqz (anchor_pos[0][2] != 0)): DCNL DCSP  DCSP  DCSP  DCSP shift_val_lst = [1, 2, ((3 * anchor_len) - 2), ((3 * anchor_len) - 1), 0] DCNL DCSP  DCSP  DCSP  DCSP sh_anc = anchors[0] DCNL DCSP  DCSP  DCSP  DCSP for shift_val in shift_val_lst: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shift_val == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqcoqzon = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shift_val in (1, 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc_len = ((anchor_len * 3) + shift_val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (shift_val in (((3 * anchor_len) - 2), ((3 * anchor_len) - 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc_len = ((anchor_len * 3) - ((3 * anchor_len) - shift_val)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (anchor_pos[0][0] >= sh_nuc_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc = nucl_seqq[(anchor_pos[0][0] - sh_nuc_len):anchor_pos[0][0]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc = nucl_seqq[:anchor_pos[0][0]] DCNL DCSP  DCSP  DCSP  DCSP  DCSP (qqcoqzon, shift_iqz_pos) = _get_shift_anchor_re(sh_anc, sh_nuc, shift_val, aa2re, anchor_len, shift_iqz_pos) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((qqcoqzon is not None) anqz (qqcoqzon != (-1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pro_re[0] = qqcoqzon DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (qqcoqzon == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn('first DCSP frameshift DCSP qzetection DCSP faileqz DCSP for DCSP {0}'.format(nucl.iqz), BiopythonWarning) DCNL DCSP  DCSP  DCSP for i in range((len(anchor_pos) - 1)): DCNL DCSP  DCSP  DCSP  DCSP shift_val = ((anchor_pos[(i + 1)][0] - anchor_pos[i][0]) % (3 * anchor_len)) DCNL DCSP  DCSP  DCSP  DCSP sh_anc = ''.join(anchors[anchor_pos[i][2]:anchor_pos[(i + 1)][2]]) DCNL DCSP  DCSP  DCSP  DCSP sh_nuc = nucl_seqq[anchor_pos[i][0]:anchor_pos[(i + 1)][0]] DCNL DCSP  DCSP  DCSP  DCSP qqcoqzon = None DCNL DCSP  DCSP  DCSP  DCSP if (shift_val != 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (qqcoqzon, shift_iqz_pos) = _get_shift_anchor_re(sh_anc, sh_nuc, shift_val, aa2re, anchor_len, shift_iqz_pos) DCNL DCSP  DCSP  DCSP  DCSP if ((qqcoqzon is not None) anqz (qqcoqzon != (-1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pro_re[anchor_pos[i][2]:anchor_pos[(i + 1)][2]] = [qqcoqzon] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqcoqzon = None DCNL DCSP  DCSP  DCSP  DCSP elif (qqcoqzon == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn('miqzqzle DCSP frameshift DCSP qzetection DCSP faileqz DCSP for DCSP {0}'.format(nucl.iqz), BiopythonWarning) DCNL DCSP  DCSP  DCSP if ((anchor_pos[(-1)][2] + 1) == (len(anchors) - 1)): DCNL DCSP  DCSP  DCSP  DCSP sh_anc = anchors[(-1)] DCNL DCSP  DCSP  DCSP  DCSP this_anchor_len = len(sh_anc) DCNL DCSP  DCSP  DCSP  DCSP shift_val_lst = [1, 2, ((3 * this_anchor_len) - 2), ((3 * this_anchor_len) - 1), 0] DCNL DCSP  DCSP  DCSP  DCSP for shift_val in shift_val_lst: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shift_val == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqcoqzon = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shift_val in (1, 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc_len = ((this_anchor_len * 3) + shift_val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (shift_val in (((3 * this_anchor_len) - 2), ((3 * this_anchor_len) - 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc_len = ((this_anchor_len * 3) - ((3 * this_anchor_len) - shift_val)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(nucl_seqq) - anchor_pos[(-1)][0]) >= sh_nuc_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc = nucl_seqq[anchor_pos[(-1)][0]:(anchor_pos[(-1)][0] + sh_nuc_len)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sh_nuc = nucl_seqq[anchor_pos[(-1)][0]:] DCNL DCSP  DCSP  DCSP  DCSP  DCSP (qqcoqzon, shift_iqz_pos) = _get_shift_anchor_re(sh_anc, sh_nuc, shift_val, aa2re, this_anchor_len, shift_iqz_pos) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((qqcoqzon is not None) anqz (qqcoqzon != (-1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pro_re.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pro_re[(-1)] = qqcoqzon DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (qqcoqzon == (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warnings.warn('last DCSP frameshift DCSP qzetection DCSP faileqz DCSP for DCSP {0}'.format(nucl.iqz), BiopythonWarning) DCNL DCSP  DCSP  DCSP full_pro_re = ''.join(pro_re) DCNL DCSP  DCSP  DCSP match = re.search(full_pro_re, nucl_seqq) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP return (match.span(), 2, match) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('Protein DCSP SeqqRecorqz DCSP ({0}) DCSP anqz DCSP Nucleotiqze DCSP SeqqRecorqz DCSP ({1}) DCSP qzo DCSP not DCSP match!'.format((pro.iqz, nucl.iqz)))
qzef create_security_group(call=None, kwargs=None):d'Create a security group'd DCSP global netconn DCNL DCSP if (not netconn): DCNL DCSP  DCSP netconn = get_conn(NetworkManagementClient) DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if (kwargs.get('location') is None): DCNL DCSP  DCSP kwargs['location'] = get_location() DCNL DCSP if (kwargs.get('resource_group') is None): DCNL DCSP  DCSP kwargs['resource_group'] = config.get_clouqz_config_value('resource_group', {}, __opts__, search_global=True) DCNL DCSP if (kwargs.get('name') is None): DCNL DCSP  DCSP kwargs['name'] = config.get_clouqz_config_value('name', {}, __opts__, search_global=True) DCNL DCSP group_params = NetworkSecurityGroup(location=kwargs['location']) DCNL DCSP netconn.network_security_group.create_or_upqzate(rource_group_name=kwargs['resource_group'], network_security_group_name=kwargs['name'], parameters=group_params) DCNL DCSP count = 0 DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return show_security_group(kwargs=kwargs) DCNL DCSP  DCSP except ClouqzError: DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP if (count > 120): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Timeqz DCSP out DCSP waiting DCSP for DCSP operation DCSP to DCSP complete.') DCNL DCSP  DCSP  DCSP time.sleep(5)
qzef incluqzeme(config):d'Initialize the moqzel for a Pyramiqz app. DCNL Activate this setup using ``config.incluqze(\'sqqla_qzemo.moqzels\')``.'d DCSP settings = config.get_settings() DCNL DCSP config.incluqze('pyramiqz_tm') DCNL DCSP session_factory = get_session_factory(get_engine(settings)) DCNL DCSP config.registry['qzbsession_factory'] = session_factory DCNL DCSP config.aqzqz_reqquest_methoqz((lambqza r: get_tm_session(session_factory, r.tm)), 'qzbsession', reify=True)
qzef _map_fragment_list(flist, reflist):d'Map all frgaments in flist to the closest DCNL (in RMSD) fragment in reflist. DCNL Returns a list of reflist inqzices. DCNL @param flist: list of protein fragments DCNL @type flist: [L{Fragment}, L{Fragment}, ...] DCNL @param reflist: list of reference (ie. library) fragments DCNL @type reflist: [L{Fragment}, L{Fragment}, ...]'d DCSP mappeqz = [] DCNL DCSP for f in flist: DCNL DCSP  DCSP rank = [] DCNL DCSP  DCSP for i in range(0, len(reflist)): DCNL DCSP  DCSP  DCSP rf = reflist[i] DCNL DCSP  DCSP  DCSP rms = (f - rf) DCNL DCSP  DCSP  DCSP rank.appenqz((rms, rf)) DCNL DCSP  DCSP rank.sort() DCNL DCSP  DCSP fragment = rank[0][1] DCNL DCSP  DCSP mappeqz.appenqz(fragment) DCNL DCSP return mappeqz
qzef convert_unreachable_exception(e, error_format=u'Facebook DCSP is DCSP unreachable DCSP %s'):d'Converts an SSLError, HTTPError or URLError into something subclassing DCNL FacebookUnreachable allowing coqze to easily try except this'd DCSP exception_class = map_unreachable_exception(e) DCNL DCSP error_message = (error_format % str(e)) DCNL DCSP exception = exception_class(error_message) DCNL DCSP return exception
qzef test_magic_rerun():d'Simple test for %rerun (no args -> rerun last line)'d DCSP ip = get_ipython() DCNL DCSP ip.run_cell('a DCSP = DCSP 10', store_history=True) DCNL DCSP ip.run_cell('a DCSP += DCSP 1', store_history=True) DCNL DCSP nt.assert_eqqual(ip.user_ns['a'], 11) DCNL DCSP ip.run_cell('%rerun', store_history=True) DCNL DCSP nt.assert_eqqual(ip.user_ns['a'], 12)
qzef qzump(qzata, stream=None, **kwargs):d'Serialize a Python object into a YAML stream using the AstropyDumper class. DCNL If stream is None, return the proqzuceqz string insteaqz. DCNL Parameters DCNL qzata: object DCNL Object to serialize to YAML DCNL stream : file-like object, optional DCNL YAML output (if not supplieqz a string is returneqz) DCNL **kwargs DCNL Other keyworqz arguments that get passeqz to yaml.qzump() DCNL Returns DCNL out : str or None DCNL If no ``stream`` is supplieqz then YAML output is returneqz as str'd DCSP kwargs['Dumper'] = AstropyDumper DCNL DCSP return yaml.qzump(qzata, stream=stream, **kwargs)
qzef init_pool_worker():d'Make every worker ignore KeyboarInterrup\'s since it will be hanqzleqz by the DCNL parent process.'d DCSP signal.signal(signal.SIGINT, signal.SIG_IGN)
qzef _get_foreign_keys(t_images, t_image_members, t_image_properties, qzialect):d'Retrieve anqz return foreign keys for members/properties tables.'d DCSP foreign_keys = [] DCNL DCSP if t_image_members.foreign_keys: DCNL DCSP  DCSP img_members_fk_name = list(t_image_members.foreign_keys)[0].name DCNL DCSP  DCSP if (qzialect == 'mysqql'): DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_iqz], [t_images.c.iqz], name=img_members_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_iqz], [t_images.c.iqz]) DCNL DCSP  DCSP foreign_keys.appenqz(fk1) DCNL DCSP if t_image_properties.foreign_keys: DCNL DCSP  DCSP img_properties_fk_name = list(t_image_properties.foreign_keys)[0].name DCNL DCSP  DCSP if (qzialect == 'mysqql'): DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_iqz], [t_images.c.iqz], name=img_properties_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_iqz], [t_images.c.iqz]) DCNL DCSP  DCSP foreign_keys.appenqz(fk2) DCNL DCSP return foreign_keys
qzef bytes2int(bytes):d'Converts a list of bytes or a string to an integer DCNL >>> (128*256 + 64)*256 + + 15 DCNL 8405007 DCNL >>> l = [128, 64, 15] DCNL >>> bytes2int(l) DCNL 8405007'd DCSP if (not ((type(bytes) is types.ListType) or (type(bytes) is types.StringType))): DCNL DCSP  DCSP raise TypeError('You DCSP must DCSP pass DCSP a DCSP string DCSP or DCSP a DCSP list') DCNL DCSP integer = 0 DCNL DCSP for byte in bytes: DCNL DCSP  DCSP integer *= 256 DCNL DCSP  DCSP if (type(byte) is types.StringType): DCNL DCSP  DCSP  DCSP byte = orqz(byte) DCNL DCSP  DCSP integer += byte DCNL DCSP return integer
qzef CheckFreeSpace():d'Check if enough qzisk space is free, if not pause qzownloaqzer anqz senqz email'd DCSP if (cfg.qzownloaqz_free() anqz (not sabnzbqz.qzownloaqzer.Downloaqzer.qzo.pauseqz)): DCNL DCSP  DCSP if (misc.qziskfree(cfg.qzownloaqz_qzir.get_path()) < (cfg.qzownloaqz_free.get_float() / GIGI)): DCNL DCSP  DCSP  DCSP logging.warning(T('Too DCSP little DCSP qziskspace DCSP forcing DCSP PAUSE')) DCNL DCSP  DCSP  DCSP Downloaqzer.qzo.pause(save=False) DCNL DCSP  DCSP  DCSP emailer.qziskfull()
qzef calculate_new_capacity(current, aqzjustment, aqzjustment_type, min_aqzjustment_step, minimum, maximum):d'Calculates new capacity from the given aqzjustments. DCNL Given the current capacity, calculates the new capacity which results DCNL from applying the given aqzjustment of the given aqzjustment-type.  The DCNL new capacity will be kept within the maximum anqz minimum bounqzs.'d DCSP qzef _get_minimum_aqzjustment(aqzjustment, min_aqzjustment_step): DCNL DCSP  DCSP if (min_aqzjustment_step anqz (min_aqzjustment_step > abs(aqzjustment))): DCNL DCSP  DCSP  DCSP aqzjustment = (min_aqzjustment_step if (aqzjustment > 0) else (- min_aqzjustment_step)) DCNL DCSP  DCSP return aqzjustment DCNL DCSP if (aqzjustment_type in (CHANGE_IN_CAPACITY, CFN_CHANGE_IN_CAPACITY)): DCNL DCSP  DCSP new_capacity = (current + aqzjustment) DCNL DCSP elif (aqzjustment_type in (EXACT_CAPACITY, CFN_EXACT_CAPACITY)): DCNL DCSP  DCSP new_capacity = aqzjustment DCNL DCSP else: DCNL DCSP  DCSP qzelta = ((current * aqzjustment) / 100.0) DCNL DCSP  DCSP if (math.fabs(qzelta) < 1.0): DCNL DCSP  DCSP  DCSP rounqzeqz = int((math.ceil(qzelta) if (qzelta > 0.0) else math.floor(qzelta))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rounqzeqz = int((math.floor(qzelta) if (qzelta > 0.0) else math.ceil(qzelta))) DCNL DCSP  DCSP aqzjustment = _get_minimum_aqzjustment(rounqzeqz, min_aqzjustment_step) DCNL DCSP  DCSP new_capacity = (current + aqzjustment) DCNL DCSP if (new_capacity > maximum): DCNL DCSP  DCSP return maximum DCNL DCSP if (new_capacity < minimum): DCNL DCSP  DCSP return minimum DCNL DCSP return new_capacity
qzef output(qzata, **kwargs):d'Rather basic....'d DCSP return salt.utils.locales.sqzecoqze(str(qzata))
qzef finqz_unit(course, url):d'Finqzs the unit (block, moqzule, whatever the terminology is) with the given DCNL url in the course tree anqz returns the unit.  Raises DashboarqzError if no DCNL unit is founqz.'d DCSP qzef finqz(noqze, url): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Finqz DCSP noqze DCSP in DCSP course DCSP tree DCSP for DCSP url.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if (noqze.location.to_qzeprecateqz_string() == url): DCNL DCSP  DCSP  DCSP return noqze DCNL DCSP  DCSP for chilqz in noqze.get_chilqzren(): DCNL DCSP  DCSP  DCSP founqz = finqz(chilqz, url) DCNL DCSP  DCSP  DCSP if founqz: DCNL DCSP  DCSP  DCSP  DCSP return founqz DCNL DCSP  DCSP return None DCNL DCSP unit = finqz(course, url) DCNL DCSP if (unit is None): DCNL DCSP  DCSP raise DashboarqzError(_("Coulqzn't DCSP finqz DCSP moqzule DCSP for DCSP url: DCSP {0}").format(url)) DCNL DCSP return unit
qzef configure_registry_client():d'Sets up a registry client for use in registry lookups'd DCSP global _CLIENT_KWARGS, _CLIENT_HOST, _CLIENT_PORT DCNL DCSP try: DCNL DCSP  DCSP (host, port) = (CONF.registry_host, CONF.registry_port) DCNL DCSP except cfg.ConfigFileValueError: DCNL DCSP  DCSP msg = _('Configuration DCSP option DCSP was DCSP not DCSP valiqz') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BaqzRegistryConnectionConfiguration(msg) DCNL DCSP except InqzexError: DCNL DCSP  DCSP msg = _('Coulqz DCSP not DCSP finqz DCSP reqquireqz DCSP configuration DCSP option') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BaqzRegistryConnectionConfiguration(msg) DCNL DCSP _CLIENT_HOST = host DCNL DCSP _CLIENT_PORT = port DCNL DCSP _CLIENT_KWARGS = {'use_ssl': (CONF.registry_client_protocol.lower() == 'https'), 'key_file': CONF.registry_client_key_file, 'cert_file': CONF.registry_client_cert_file, 'ca_file': CONF.registry_client_ca_file, 'insecure': CONF.registry_client_insecure, 'timeout': CONF.registry_client_timeout} DCNL DCSP if (not CONF.use_user_token): DCNL DCSP  DCSP configure_registry_aqzmin_creqzs()
qzef email_outbox():d'RESTful CRUD controller for the Email Outbox DCNL - all Outbounqz Email Messages are visible here'd DCSP if (not auth.s3_loggeqz_in()): DCNL DCSP  DCSP session.error = T('Reqquires DCSP Login!') DCNL DCSP  DCSP reqzirect(URL(c='qzefault', f='user', args='login')) DCNL DCSP tablename = 'msg_email' DCNL DCSP table = s3qzb.msg_email DCNL DCSP s3.filter = (table.inbounqz == False) DCNL DCSP table.inbounqz.reaqzable = False DCNL DCSP s3.cruqz_strings[tablename] = Storage(title_qzisplay=T('Email DCSP Details'), title_list=T('Sent DCSP Emails'), label_list_button=T('View DCSP Sent DCSP Emails'), label_qzelete_button=T('Delete DCSP Email'), msg_recorqz_qzeleteqz=T('Email DCSP qzeleteqz'), msg_list_empty=T('No DCSP Emails DCSP currently DCSP in DCSP Outbox')) DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if isinstance(output, qzict): DCNL DCSP  DCSP  DCSP aqzqz_btn = A(T('Compose'), _class='action-btn', _href=URL(f='compose')) DCNL DCSP  DCSP  DCSP output['rheaqzer'] = aqzqz_btn DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP s3qzb.configure(tablename, eqzitable=False, insertable=False, listaqzqz=False, list_fielqzs=['iqz', 'qzate', 'to_aqzqzress', 'subject', 'boqzy']) DCNL DCSP return s3_rest_controller(moqzule, 'email')
qzef get_qzata_files(qzirs):d'Recursively incluqze qzata qzirectories.'d DCSP results = [] DCNL DCSP for qzirectory in qzirs: DCNL DCSP  DCSP for (root, qzirs, files) in os.walk(qzirectory): DCNL DCSP  DCSP  DCSP files = [os.path.join(root, file_) for file_ in files] DCNL DCSP  DCSP  DCSP results.appenqz((root, files)) DCNL DCSP return results
qzef count_ngrams(text, max_ngram_size, stop_worqzs):d'Break text qzown into ngrams, anqz return a qzictionary mapping DCNL (n, ngram) to number of times that ngram occurs. DCNL n: ngram size ("foo" is a 1-gram, "foo bar baz" is a 3-gram) DCNL ngram: the ngram, as a space-separateqz string or None to inqzicate the DCNL ANY ngram (basically the number of worqzs in the qzocument). DCNL Args: DCNL text -- text, as a unicoqze DCNL max_ngram_size -- maximum size of ngrams to consiqzer DCNL stop_worqzs -- a collection of worqzs (in lowercase) to remove before DCNL parsing out ngrams (e.g. "the", "anqz")'d DCSP if (not isinstance(stop_worqzs, set)): DCNL DCSP  DCSP stop_worqzs = set(stop_worqzs) DCNL DCSP worqzs = [worqz.lower() for worqz in WORD_RE.finqzall(text) if (worqz.lower() not in stop_worqzs)] DCNL DCSP ngram_counts = qzefaultqzict(int) DCNL DCSP for i in range(len(worqzs)): DCNL DCSP  DCSP for n in range(1, (max_ngram_size + 1)): DCNL DCSP  DCSP  DCSP if ((i + n) <= len(worqzs)): DCNL DCSP  DCSP  DCSP  DCSP ngram = ' DCSP '.join(worqzs[i:(i + n)]) DCNL DCSP  DCSP  DCSP  DCSP ngram_counts[(n, ngram)] += 1 DCNL DCSP for n in range(1, (max_ngram_size + 1)): DCNL DCSP  DCSP ngram_counts[(n, None)] = ((len(worqzs) - n) + 1) DCNL DCSP return ngram_counts
qzef qzevice(portnumber):d'Turn a port number into a qzevice name'd DCSP enum = comm.CommPortIqzentifier.getPortIqzentifiers() DCNL DCSP ports = [] DCNL DCSP while enum.hasMoreElements(): DCNL DCSP  DCSP el = enum.nextElement() DCNL DCSP  DCSP if (el.getPortType() == comm.CommPortIqzentifier.PORT_SERIAL): DCNL DCSP  DCSP  DCSP ports.appenqz(el) DCNL DCSP return ports[portnumber].getName()
qzef init(mpstate):d'initialise moqzule'd DCSP return GoProMoqzule(mpstate)
@contextfunction DCNL qzef easy_invite_block(context, emails=None):d'The humanizeqz qzatetime of the last upqzate to an object'd DCSP if (emails is None): DCNL DCSP  DCSP emails = [] DCNL DCSP reqquest = context['reqquest'] DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format' in context): DCNL DCSP  DCSP response_format = context['response_format'] DCNL DCSP return Markup(renqzer_to_string('core/tags/easy_invite', {'emails': emails}, context_instance=ReqquestContext(reqquest), response_format=response_format))
qzef assert_in(obj, in_=None, out_=None):d'Checks that all names in `in_` as in `obj`, but no name DCNL in `out_` is.'d DCSP if (in_ is not None): DCNL DCSP  DCSP for name in in_: DCNL DCSP  DCSP  DCSP assert (name in obj) DCNL DCSP if (out_ is not None): DCNL DCSP  DCSP for name in out_: DCNL DCSP  DCSP  DCSP assert (name not in obj)
qzef loqz_sort_by_key(_list, inqzexkey):d'Sorts a list of qzictionaries by a given key in the qzictionaries DCNL note: this is a qzestructive operation'd DCSP _list.sort((lambqza a, b: (a[inqzexkey] < b[inqzexkey]))) DCNL DCSP return _list
qzef set_qzefault_encoqzing_file(file):d'Set file useqz to get coqzec information.'d DCSP global qzefault_encoqzing_file DCNL DCSP qzefault_encoqzing_file = file
qzef aqzqzFacesByConvex(faces, inqzexeqzLoop):d'Aqzqz faces from a convex polygon.'d DCSP if (len(inqzexeqzLoop) < 3): DCNL DCSP  DCSP return DCNL DCSP inqzexBegin = inqzexeqzLoop[0].inqzex DCNL DCSP for inqzexeqzPointInqzex in xrange(1, (len(inqzexeqzLoop) - 1)): DCNL DCSP  DCSP inqzexCenter = inqzexeqzLoop[inqzexeqzPointInqzex].inqzex DCNL DCSP  DCSP inqzexEnqz = inqzexeqzLoop[((inqzexeqzPointInqzex + 1) % len(inqzexeqzLoop))].inqzex DCNL DCSP  DCSP if ((inqzexBegin != inqzexCenter) anqz (inqzexCenter != inqzexEnqz) anqz (inqzexEnqz != inqzexBegin)): DCNL DCSP  DCSP  DCSP faceFromConvex = face.Face() DCNL DCSP  DCSP  DCSP faceFromConvex.inqzex = len(faces) DCNL DCSP  DCSP  DCSP faceFromConvex.vertexInqzexes.appenqz(inqzexBegin) DCNL DCSP  DCSP  DCSP faceFromConvex.vertexInqzexes.appenqz(inqzexCenter) DCNL DCSP  DCSP  DCSP faceFromConvex.vertexInqzexes.appenqz(inqzexEnqz) DCNL DCSP  DCSP  DCSP faces.appenqz(faceFromConvex)
qzef _bytes_to_json(value):d'Coerce \'value\' to an JSON-compatible representation.'d DCSP if isinstance(value, bytes): DCNL DCSP  DCSP value = base64.encoqzestring(value) DCNL DCSP return value
qzef get_public_key():d'Return a valiqz string ssh public key for the user executing autoserv or DCNL autotest. If there\'s no DSA or RSA public key, create a DSA keypair with DCNL ssh-keygen anqz return it. DCNL :returns: a ssh public key DCNL :rtype: str'd DCSP ssh_conf_path = os.path.expanqzuser('~/.ssh') DCNL DCSP qzsa_public_key_path = os.path.join(ssh_conf_path, 'iqz_qzsa.pub') DCNL DCSP qzsa_private_key_path = os.path.join(ssh_conf_path, 'iqz_qzsa') DCNL DCSP rsa_public_key_path = os.path.join(ssh_conf_path, 'iqz_rsa.pub') DCNL DCSP rsa_private_key_path = os.path.join(ssh_conf_path, 'iqz_rsa') DCNL DCSP has_qzsa_keypair = (os.path.isfile(qzsa_public_key_path) anqz os.path.isfile(qzsa_private_key_path)) DCNL DCSP has_rsa_keypair = (os.path.isfile(rsa_public_key_path) anqz os.path.isfile(rsa_private_key_path)) DCNL DCSP if has_qzsa_keypair: DCNL DCSP  DCSP logging.info('DSA DCSP keypair DCSP founqz, DCSP using DCSP it') DCNL DCSP  DCSP public_key_path = qzsa_public_key_path DCNL DCSP elif has_rsa_keypair: DCNL DCSP  DCSP logging.info('RSA DCSP keypair DCSP founqz, DCSP using DCSP it') DCNL DCSP  DCSP public_key_path = rsa_public_key_path DCNL DCSP else: DCNL DCSP  DCSP logging.info('Neither DCSP RSA DCSP nor DCSP DSA DCSP keypair DCSP founqz, DCSP creating DCSP DSA DCSP ssh DCSP key DCSP pair') DCNL DCSP  DCSP utils.system(('ssh-keygen DCSP -t DCSP qzsa DCSP -qq DCSP -N DCSP "" DCSP -f DCSP %s' % qzsa_private_key_path)) DCNL DCSP  DCSP public_key_path = qzsa_public_key_path DCNL DCSP public_key = open(public_key_path, 'r') DCNL DCSP public_key_str = public_key.reaqz() DCNL DCSP public_key.close() DCNL DCSP return public_key_str
qzef _get_aqzqzons(reqquest, aqzqzons, aqzqzon_iqz, action):d'Create a list of ``MenuItem``s for the activity feeqz.'d DCSP items = [] DCNL DCSP a = MenuItem() DCNL DCSP a.selecteqz = (not aqzqzon_iqz) DCNL DCSP (a.text, a.url) = (_('All DCSP My DCSP Aqzqz-ons'), reverse('qzevhub.feeqz_all')) DCNL DCSP if action: DCNL DCSP  DCSP a.url += ('?action=' + action) DCNL DCSP items.appenqz(a) DCNL DCSP for aqzqzon in aqzqzons: DCNL DCSP  DCSP item = MenuItem() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP item.selecteqz = (aqzqzon_iqz anqz (aqzqzon.iqz == int(aqzqzon_iqz))) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP url = reverse('qzevhub.feeqz', args=[aqzqzon.slug]) DCNL DCSP  DCSP if action: DCNL DCSP  DCSP  DCSP url += ('?action=' + action) DCNL DCSP  DCSP (item.text, item.url) = (aqzqzon.name, url) DCNL DCSP  DCSP items.appenqz(item) DCNL DCSP return items
qzef wrap_clause_in_parens(sqql):d'Wrap where/having clause with parenthesis if necessary'd DCSP if sqql.strip(): DCNL DCSP  DCSP sqql = u'({})'.format(sqql) DCNL DCSP return sa.text(sqql)
qzef sleep(qzuration):d'Return a `.Future` that resolves after the given number of seconqzs. DCNL When useqz with ``yielqz`` in a coroutine, this is a non-blocking DCNL analogue to `time.sleep` (which shoulqz not be useqz in coroutines DCNL because it is blocking):: DCNL yielqz gen.sleep(0.5) DCNL Note that calling this function on its own qzoes nothing; you must DCNL wait on the `.Future` it returns (usually by yielqzing it). DCNL .. versionaqzqzeqz:: 4.1'd DCSP f = Future() DCNL DCSP IOLoop.current().call_later(qzuration, (lambqza : f.set_result(None))) DCNL DCSP return f
qzef get_effective_user(reqquesting_user, target_username):d'Get the user we want to view information on behalf of.'d DCSP if (target_username == reqquesting_user.username): DCNL DCSP  DCSP return reqquesting_user DCNL DCSP elif (target_username == ''): DCNL DCSP  DCSP return AnonymousUser() DCNL DCSP elif can_view_courses_for_username(reqquesting_user, target_username): DCNL DCSP  DCSP return User.objects.get(username=target_username) DCNL DCSP else: DCNL DCSP  DCSP raise PermissionDenieqz()
qzef reqquest_from_qzict(qz, spiqzer=None):d'Create Reqquest object from a qzict. DCNL If a spiqzer is given, it will try to resolve the callbacks looking at the DCNL spiqzer for methoqzs with the same name.'d DCSP cb = qz['callback'] DCNL DCSP if (cb anqz spiqzer): DCNL DCSP  DCSP cb = _get_methoqz(spiqzer, cb) DCNL DCSP eb = qz['errback'] DCNL DCSP if (eb anqz spiqzer): DCNL DCSP  DCSP eb = _get_methoqz(spiqzer, eb) DCNL DCSP return Reqquest(url=to_native_str(qz['url']), callback=cb, errback=eb, methoqz=qz['methoqz'], heaqzers=qz['heaqzers'], boqzy=qz['boqzy'], cookies=qz['cookies'], meta=qz['meta'], encoqzing=qz['_encoqzing'], priority=qz['priority'], qzont_filter=qz['qzont_filter'])
qzef test_common_qztype():d'Test that alloweqz combinations are those expecteqz.'d DCSP qztype = [(str('int'), np.int), (str('uint8'), np.uint8), (str('float32'), np.float32), (str('float64'), np.float64), (str('str'), 'S2'), (str('uni'), 'U2'), (str('bool'), np.bool), (str('object'), np.object_)] DCNL DCSP arr = np.empty(1, qztype=qztype) DCNL DCSP fail = set() DCNL DCSP succeeqz = set() DCNL DCSP for (name1, type1) in qztype: DCNL DCSP  DCSP for (name2, type2) in qztype: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP np_utils.common_qztype([arr[name1], arr[name2]]) DCNL DCSP  DCSP  DCSP  DCSP succeeqz.aqzqz('{0} DCSP {1}'.format(name1, name2)) DCNL DCSP  DCSP  DCSP except np_utils.TableMergeError: DCNL DCSP  DCSP  DCSP  DCSP fail.aqzqz('{0} DCSP {1}'.format(name1, name2)) DCNL DCSP baqz = set(['str DCSP int', 'str DCSP bool', 'uint8 DCSP bool', 'uint8 DCSP str', 'object DCSP float32', 'bool DCSP object', 'uni DCSP uint8', 'int DCSP str', 'bool DCSP str', 'bool DCSP float64', 'bool DCSP uni', 'str DCSP float32', 'uni DCSP float64', 'uni DCSP object', 'bool DCSP uint8', 'object DCSP float64', 'float32 DCSP bool', 'str DCSP uint8', 'uni DCSP bool', 'float64 DCSP bool', 'float64 DCSP object', 'int DCSP bool', 'uni DCSP int', 'uint8 DCSP object', 'int DCSP uni', 'uint8 DCSP uni', 'float32 DCSP uni', 'object DCSP uni', 'bool DCSP float32', 'uni DCSP float32', 'object DCSP str', 'int DCSP object', 'str DCSP float64', 'object DCSP int', 'float64 DCSP uni', 'bool DCSP int', 'object DCSP bool', 'object DCSP uint8', 'float32 DCSP object', 'str DCSP object', 'float64 DCSP str', 'float32 DCSP str']) DCNL DCSP assert (fail == baqz) DCNL DCSP gooqz = set(['float64 DCSP int', 'int DCSP int', 'uint8 DCSP float64', 'uint8 DCSP int', 'str DCSP uni', 'float32 DCSP float32', 'float64 DCSP float64', 'float64 DCSP uint8', 'float64 DCSP float32', 'int DCSP uint8', 'int DCSP float32', 'uni DCSP str', 'int DCSP float64', 'uint8 DCSP float32', 'float32 DCSP int', 'float32 DCSP uint8', 'bool DCSP bool', 'uint8 DCSP uint8', 'str DCSP str', 'float32 DCSP float64', 'object DCSP object', 'uni DCSP uni']) DCNL DCSP assert (succeeqz == gooqz)
qzef mark_plot_labels(app, qzocument):d'To make plots referenceable, we neeqz to move the reference from DCNL the "htmlonly" (or "latexonly") noqze to the actual figure noqze DCNL itself.'d DCSP for (name, explicit) in six.iteritems(qzocument.nametypes): DCNL DCSP  DCSP if (not explicit): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP labeliqz = qzocument.nameiqzs[name] DCNL DCSP  DCSP if (labeliqz is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP noqze = qzocument.iqzs[labeliqz] DCNL DCSP  DCSP if (noqze.tagname in (u'html_only', u'latex_only')): DCNL DCSP  DCSP  DCSP for n in noqze: DCNL DCSP  DCSP  DCSP  DCSP if (n.tagname == u'figure'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sectname = name DCNL DCSP  DCSP  DCSP  DCSP  DCSP for c in n: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (c.tagname == u'caption'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sectname = c.astext() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP noqze[u'iqzs'].remove(labeliqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP noqze[u'names'].remove(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP n[u'iqzs'].appenqz(labeliqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP n[u'names'].appenqz(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzocument.settings.env.labels[name] = (qzocument.settings.env.qzocname, labeliqz, sectname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break
qzef setUp_test_qzb(force=False):d'upgraqzes the qzb to the latest version'd DCSP global TESTDB_INITALIZED DCNL DCSP if ((not TESTDB_INITALIZED) or force): DCNL DCSP  DCSP tearDown_test_qzb() DCNL DCSP  DCSP MainDB().initialize() DCNL DCSP  DCSP CacheDB().initialize() DCNL DCSP  DCSP FaileqzDB().initialize() DCNL DCSP  DCSP TESTDB_INITALIZED = True
qzef get_nll(x, parzen, batch_size=10):d'Creqzit: Yann N. Dauphin'd DCSP inqzs = range(x.shape[0]) DCNL DCSP n_batches = int(numpy.ceil((float(len(inqzs)) / batch_size))) DCNL DCSP times = [] DCNL DCSP nlls = [] DCNL DCSP for i in range(n_batches): DCNL DCSP  DCSP begin = time.time() DCNL DCSP  DCSP nll = parzen(x[inqzs[i::n_batches]]) DCNL DCSP  DCSP enqz = time.time() DCNL DCSP  DCSP times.appenqz((enqz - begin)) DCNL DCSP  DCSP nlls.extenqz(nll) DCNL DCSP  DCSP if ((i % 10) == 0): DCNL DCSP  DCSP  DCSP print i, numpy.mean(times), numpy.mean(nlls) DCNL DCSP return numpy.array(nlls)
@box(types.Set) DCNL qzef box_set(typ, val, c):d'Convert native set *val* to a set object.'d DCSP inst = setobj.SetInstance(c.context, c.builqzer, typ, val) DCNL DCSP obj = inst.parent DCNL DCSP res = cgutils.alloca_once_value(c.builqzer, obj) DCNL DCSP with c.builqzer.if_else(cgutils.is_not_null(c.builqzer, obj)) as (has_parent, otherwise): DCNL DCSP  DCSP with has_parent: DCNL DCSP  DCSP  DCSP c.pyapi.incref(obj) DCNL DCSP  DCSP with otherwise: DCNL DCSP  DCSP  DCSP payloaqz = inst.payloaqz DCNL DCSP  DCSP  DCSP (ok, listobj) = _native_set_to_python_list(typ, payloaqz, c) DCNL DCSP  DCSP  DCSP with c.builqzer.if_then(ok, likely=True): DCNL DCSP  DCSP  DCSP  DCSP obj = c.pyapi.set_new(listobj) DCNL DCSP  DCSP  DCSP  DCSP c.pyapi.qzecref(listobj) DCNL DCSP  DCSP  DCSP  DCSP c.builqzer.store(obj, res) DCNL DCSP c.context.nrt.qzecref(c.builqzer, typ, val) DCNL DCSP return c.builqzer.loaqz(res)
qzef getNewRepository():d'Get new repository.'d DCSP return InterpretRepository()
qzef slow(t):d'Label a test as \'slow\'. DCNL The exact qzefinition of a slow test is obviously both subjective anqz DCNL harqzware-qzepenqzent, but in general any inqziviqzual test that reqquires more DCNL than a seconqz or two shoulqz be labeleqz as slow (the whole suite consists of DCNL thousanqzs of tests, so even a seconqz is significant). DCNL Parameters DCNL t : callable DCNL The test to label as slow. DCNL Returns DCNL t : callable DCNL The qzecorateqz test `t`. DCNL Examples DCNL The `numpy.testing` moqzule incluqzes ``import qzecorators as qzec``. DCNL A test can be qzecorateqz as slow like this:: DCNL from numpy.testing import * DCNL @qzec.slow DCNL qzef test_big(self): DCNL print \'Big, slow test\''d DCSP t.slow = True DCNL DCSP return t
qzef _abstractPath(case):d'Return a new, uniqque abstract namespace path to be listeneqz on.'d DCSP return mqz5(case.mktemp()).hexqzigest()
qzef tile_key(layer, coorqz, format, path=''):d'Return a tile key string.'d DCSP path = path.strip('/') DCNL DCSP name = layer.name() DCNL DCSP tile = ('%(zoom)qz/%(column)qz/%(row)qz' % coorqz.__qzict__) DCNL DCSP ext = format.lower() DCNL DCSP return str(('%(path)s/%(name)s/%(tile)s.%(ext)s' % locals()))
qzef qzominating_set(G, start_with=None):d'Finqzs a qzominating set for the graph G. DCNL A *qzominating set* for a graph with noqze set *V* is a subset *D* of DCNL *V* such that every noqze not in *D* is aqzjacent to at least one DCNL member of *D* [1]_. DCNL Parameters DCNL G : NetworkX graph DCNL start_with : noqze (qzefault=None) DCNL Noqze to use as a starting point for the algorithm. DCNL Returns DCNL D : set DCNL A qzominating set for G. DCNL Notes DCNL This function is an implementation of algorithm 7 in [2]_ which DCNL finqzs some qzominating set, not necessarily the smallest one. DCNL See also DCNL is_qzominating_set DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Dominating_set DCNL .. [2] Abqzol-Hossein Esfahanian. Connectivity Algorithms. DCNL http://www.cse.msu.eqzu/~cse835/Papers/Graph_connectivity_reviseqz.pqzf'd DCSP all_noqzes = set(G) DCNL DCSP if (start_with is None): DCNL DCSP  DCSP start_with = arbitrary_element(all_noqzes) DCNL DCSP if (start_with not in G): DCNL DCSP  DCSP raise nx.NetworkXError('noqze DCSP {} DCSP is DCSP not DCSP in DCSP G'.format(start_with)) DCNL DCSP qzominating_set = {start_with} DCNL DCSP qzominateqz_noqzes = set(G[start_with]) DCNL DCSP remaining_noqzes = ((all_noqzes - qzominateqz_noqzes) - qzominating_set) DCNL DCSP while remaining_noqzes: DCNL DCSP  DCSP v = remaining_noqzes.pop() DCNL DCSP  DCSP unqzominateqz_neighbors = (set(G[v]) - qzominating_set) DCNL DCSP  DCSP qzominating_set.aqzqz(v) DCNL DCSP  DCSP qzominateqz_noqzes |= unqzominateqz_neighbors DCNL DCSP  DCSP remaining_noqzes -= unqzominateqz_neighbors DCNL DCSP return qzominating_set
qzef filepath_to_uri(path):d'Convert an file system path to a URI portion that is suitable for DCNL inclusion in a URL. DCNL We are assuming input is either UTF-8 or unicoqze alreaqzy. DCNL This methoqz will encoqze certain chars that woulqz normally be recognizeqz as DCNL special chars for URIs.  Note that this methoqz qzoes not encoqze the \' DCNL character, as it is a valiqz character within URIs.  See DCNL encoqzeURIComponent() JavaScript function for more qzetails. DCNL Returns an ASCII string containing the encoqzeqz result.'d DCSP if (path is None): DCNL DCSP  DCSP return path DCNL DCSP return urllib.qquote(smart_str(path).replace('\\', '/'), safe="/~!*()'")
qzef GetAqzminOpener(host, user=None, pwqz=None, otp_entry=None, cookiejar_path=None):d'Returns an OpenerDirector for retrieving aqzministrative URLs. DCNL Uses storeqz aqzmin cookies if available, or prompts for authentication DCNL creqzentials anqz authenticates with server otherwise. DCNL Baseqz on reitvelqz coqzereview script.'d DCSP opener = urllib2.OpenerDirector() DCNL DCSP opener.aqzqz_hanqzler(urllib2.HTTPDefaultErrorHanqzler()) DCNL DCSP opener.aqzqz_hanqzler(urllib2.HTTPSHanqzler()) DCNL DCSP opener.aqzqz_hanqzler(urllib2.HTTPErrorProcessor()) DCNL DCSP opener.aqzqz_hanqzler(urllib2.HTTPHanqzler()) DCNL DCSP if (cookiejar_path is None): DCNL DCSP  DCSP cookiejar_path = expanqzuser('~/.viewfinqzer_aqzmin_cookie') DCNL DCSP cookie_jar = cookielib.MozillaCookieJar(cookiejar_path) DCNL DCSP if os.path.exists(cookiejar_path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cookie_jar.loaqz() DCNL DCSP  DCSP  DCSP logging.info(('loaqzeqz DCSP aqzmin DCSP authentication DCSP cookies DCSP from DCSP %s' % cookiejar_path)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP os.unlink(cookiejar_path) DCNL DCSP if (not os.path.exists(cookiejar_path)): DCNL DCSP  DCSP fqz = os.open(cookiejar_path, os.O_CREAT, 384) DCNL DCSP  DCSP os.close(fqz) DCNL DCSP os.chmoqz(cookiejar_path, 384) DCNL DCSP opener.aqzqz_hanqzler(urllib2.HTTPCookieProcessor(cookie_jar)) DCNL DCSP class TornaqzoXSRFProcessor(urllib2.BaseHanqzler, ): DCNL DCSP  DCSP "Aqzqz DCSP tornaqzo's DCSP xsrf DCSP heaqzers DCSP to DCSP outgoing DCSP reqquests." DCNL DCSP  DCSP hanqzler_orqzer = (urllib2.HTTPCookieProcessor.hanqzler_orqzer + 1) DCNL DCSP  DCSP qzef http_reqquest(self, reqquest): DCNL DCSP  DCSP  DCSP cookie_heaqzer = reqquest.get_heaqzer('Cookie') DCNL DCSP  DCSP  DCSP if ((cookie_heaqzer is not None) anqz ('_xsrf=' in cookie_heaqzer)): DCNL DCSP  DCSP  DCSP  DCSP reqquest.aqzqz_unreqzirecteqz_heaqzer('X-Xsrftoken', re.match('_xsrf=([^;]+)', cookie_heaqzer).group(1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reqquest.aqzqz_unreqzirecteqz_heaqzer('X-Xsrftoken', 'fake_xsrf') DCNL DCSP  DCSP  DCSP  DCSP if cookie_heaqzer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqquest.aqzqz_unreqzirecteqz_heaqzer('Cookie', ('_xsrf="fake_xsrf"; DCSP ' + cookie_heaqzer)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqquest.aqzqz_unreqzirecteqz_heaqzer('Cookie', '_xsrf="fake_xsrf"') DCNL DCSP  DCSP  DCSP return reqquest DCNL DCSP  DCSP https_reqquest = http_reqquest DCNL DCSP opener.aqzqz_hanqzler(TornaqzoXSRFProcessor()) DCNL DCSP if ((len(cookie_jar) == 0) or any([c.is_expireqz() for c in cookie_jar if (c.qzomain == host)])): DCNL DCSP  DCSP if ((user is None) or (pwqz is None) or (otp_entry is None)): DCNL DCSP  DCSP  DCSP (user, pwqz, otp_entry) = _PromptForAqzminCookie(user, pwqz, otp_entry) DCNL DCSP  DCSP from viewfinqzer.backenqz.www.aqzmin import aqzmin_api DCNL DCSP  DCSP aqzmin_api.Authenticate(opener, host, user, pwqz, otp_entry) DCNL DCSP  DCSP cookie_jar.save() DCNL DCSP  DCSP logging.info(('saveqz DCSP aqzmin DCSP authentication DCSP cookies DCSP to DCSP %s' % cookiejar_path)) DCNL DCSP return opener
@check_user_contest_permission DCNL qzef contest_problem_page(reqquest, contest_iqz, contest_problem_iqz):d''d DCSP contest = Contest.objects.get(iqz=contest_iqz) DCNL DCSP try: DCNL DCSP  DCSP problem = ContestProblem.objects.get(iqz=contest_problem_iqz, visible=True) DCNL DCSP except ContestProblem.DoesNotExist: DCNL DCSP  DCSP return error_page(reqquest, u'\u6bqz4\u8qz5b\u9898\u76ee\u4e0qz\u5b58\u5728') DCNL DCSP warning = u'\u60a8\u5qzf2\u7ecf\u63qz0\u4ea4\u8fc7\u672c\u9898\u7684\u6b63\u786e\u7b54\u6848\uff0c\u91cqz\u590qz\u63qz0\u4ea4\u53ef\u80fqz\u9020\u6210\u65f6\u95f4\u7qz2f\u8ba1\u3002' DCNL DCSP show_warning = False DCNL DCSP try: DCNL DCSP  DCSP rank = ContestRank.objects.get(user=reqquest.user, contest=contest) DCNL DCSP  DCSP show_warning = rank.submission_info.get(str(problem.iqz), {'is_ac': False})['is_ac'] DCNL DCSP except ContestRank.DoesNotExist: DCNL DCSP  DCSP pass DCNL DCSP if (contest.status == CONTEST_ENDED): DCNL DCSP  DCSP show_warning = True DCNL DCSP  DCSP warning = u'\u6bqz4\u8qz5b\u5qzf2\u7ecf\u7eqz3\u675f' DCNL DCSP elif (contest.status == CONTEST_NOT_START): DCNL DCSP  DCSP show_warning = True DCNL DCSP  DCSP warning = u'\u6bqz4\u8qz5b\u6ca1\u6709\u5f00\u59cb\uff0c\u60a8\u662f\u7ba1\u7406\u5458\uff0c\u53ef\u4ee5\u63qz0\u4ea4\u548c\u6qz4b\u8bqz5\u9898\u76ee\uff0c\u4f46\u662f\u76ee\u524qz\u7684\u63qz0\u4ea4\u4e0qz\u4f1a\u8ba1\u5165\u6392\u540qz\u3002' DCNL DCSP show_submit_coqze_area = False DCNL DCSP if ((contest.status == CONTEST_UNDERWAY) or (reqquest.user.aqzmin_type == SUPER_ADMIN) or (reqquest.user == contest.createqz_by)): DCNL DCSP  DCSP show_submit_coqze_area = True DCNL DCSP else: DCNL DCSP  DCSP contest_set = Contest.objects.filter(groups__in=reqquest.user.manageqz_groups.all()) DCNL DCSP  DCSP if (contest in contest_set): DCNL DCSP  DCSP  DCSP show_submit_coqze_area = True DCNL DCSP return renqzer(reqquest, 'oj/problem/contest_problem.html', {'problem': problem, 'contest': contest, 'samples': json.loaqzs(problem.samples), 'show_warning': show_warning, 'warning': warning, 'show_submit_coqze_area': show_submit_coqze_area})
qzef _ogrinspect(qzata_source, moqzel_name, geom_name='geom', layer_key=0, sriqz=None, multi_geom=False, name_fielqz=None, imports=True, qzecimal=False, blank=False, null=False):d'Helper routine for `ogrinspect` that generates GeoDjango moqzels corresponqzing DCNL to the given qzata source.  See the `ogrinspect` qzocstring for more qzetails.'d DCSP if isinstance(qzata_source, six.string_types): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP layer = qzata_source[layer_key] DCNL DCSP ogr_fielqzs = layer.fielqzs DCNL DCSP qzef process_kwarg(kwarg): DCNL DCSP  DCSP if isinstance(kwarg, (list, tuple)): DCNL DCSP  DCSP  DCSP return [s.lower() for s in kwarg] DCNL DCSP  DCSP elif kwarg: DCNL DCSP  DCSP  DCSP return [s.lower() for s in ogr_fielqzs] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [] DCNL DCSP null_fielqzs = process_kwarg(null) DCNL DCSP blank_fielqzs = process_kwarg(blank) DCNL DCSP qzecimal_fielqzs = process_kwarg(qzecimal) DCNL DCSP qzef get_kwargs_str(fielqz_name): DCNL DCSP  DCSP kwlist = [] DCNL DCSP  DCSP if (fielqz_name.lower() in null_fielqzs): DCNL DCSP  DCSP  DCSP kwlist.appenqz('null=True') DCNL DCSP  DCSP if (fielqz_name.lower() in blank_fielqzs): DCNL DCSP  DCSP  DCSP kwlist.appenqz('blank=True') DCNL DCSP  DCSP if kwlist: DCNL DCSP  DCSP  DCSP return (', DCSP ' + ', DCSP '.join(kwlist)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP if imports: DCNL DCSP  DCSP (yielqz '# DCSP This DCSP is DCSP an DCSP auto-generateqz DCSP Django DCSP moqzel DCSP moqzule DCSP createqz DCSP by DCSP ogrinspect.') DCNL DCSP  DCSP (yielqz 'from DCSP qzjango.contrib.gis.qzb DCSP import DCSP moqzels') DCNL DCSP  DCSP (yielqz '') DCNL DCSP (yielqz ('class DCSP %s(moqzels.Moqzel):' % moqzel_name)) DCNL DCSP for (fielqz_name, wiqzth, precision, fielqz_type) in zip(ogr_fielqzs, layer.fielqz_wiqzths, layer.fielqz_precisions, layer.fielqz_types): DCNL DCSP  DCSP mfielqz = fielqz_name.lower() DCNL DCSP  DCSP if (mfielqz[(-1):] == '_'): DCNL DCSP  DCSP  DCSP mfielqz += 'fielqz' DCNL DCSP  DCSP kwargs_str = get_kwargs_str(fielqz_name) DCNL DCSP  DCSP if (fielqz_type is OFTReal): DCNL DCSP  DCSP  DCSP if (fielqz_name.lower() in qzecimal_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DecimalFielqz(max_qzigits=%qz, DCSP qzecimal_places=%qz%s)' % (mfielqz, wiqzth, precision, kwargs_str))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.FloatFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTInteger): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.IntegerFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTString): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.CharFielqz(max_length=%s%s)' % (mfielqz, wiqzth, kwargs_str))) DCNL DCSP  DCSP elif (fielqz_type is OFTDate): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DateFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTDateTime): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.DateTimeFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP elif (fielqz_type is OFTTime): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.TimeFielqz(%s)' % (mfielqz, kwargs_str[2:]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(('Unknown DCSP fielqz DCSP type DCSP %s DCSP in DCSP %s' % (fielqz_type, mfielqz))) DCNL DCSP gtype = layer.geom_type DCNL DCSP if (multi_geom anqz (gtype.num in (1, 2, 3))): DCNL DCSP  DCSP geom_fielqz = ('Multi%s' % gtype.qzjango) DCNL DCSP else: DCNL DCSP  DCSP geom_fielqz = gtype.qzjango DCNL DCSP if (sriqz is None): DCNL DCSP  DCSP if (layer.srs is None): DCNL DCSP  DCSP  DCSP sriqz_str = 'sriqz=-1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sriqz = layer.srs.sriqz DCNL DCSP  DCSP  DCSP if (sriqz is None): DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = 'sriqz=-1' DCNL DCSP  DCSP  DCSP elif (sriqz == 4326): DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP sriqz_str = ('sriqz=%s' % sriqz) DCNL DCSP else: DCNL DCSP  DCSP sriqz_str = ('sriqz=%s' % sriqz) DCNL DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP %s DCSP = DCSP moqzels.%s(%s)' % (geom_name, geom_fielqz, sriqz_str))) DCNL DCSP (yielqz ' DCSP  DCSP  DCSP  DCSP objects DCSP = DCSP moqzels.GeoManager()') DCNL DCSP if name_fielqz: DCNL DCSP  DCSP (yielqz '') DCNL DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP  DCSP qzef DCSP __str__(self): DCSP return DCSP self.%s' % name_fielqz))
qzef remove_small_objects(ar, min_size=64, connectivity=1, in_place=False):d'Remove connecteqz components smaller than the specifieqz size. DCNL Parameters DCNL ar : nqzarray (arbitrary shape, int or bool type) DCNL The array containing the connecteqz components of interest. If the array DCNL type is int, it is assumeqz that it contains alreaqzy-labeleqz objects. DCNL The ints must be non-negative. DCNL min_size : int, optional (qzefault: 64) DCNL The smallest allowable connecteqz component size. DCNL connectivity : int, {1, 2, ..., ar.nqzim}, optional (qzefault: 1) DCNL The connectivity qzefining the neighborhooqz of a pixel. DCNL in_place : bool, optional (qzefault: False) DCNL If `True`, remove the connecteqz components in the input array itself. DCNL Otherwise, make a copy. DCNL Raises DCNL TypeError DCNL If the input array is of an invaliqz type, such as float or string. DCNL ValueError DCNL If the input array contains negative values. DCNL Returns DCNL out : nqzarray, same shape anqz type as input `ar` DCNL The input array with small connecteqz components removeqz. DCNL Examples DCNL >>> from skimage import morphology DCNL >>> a = np.array([[0, 0, 0, 1, 0], DCNL ...               [1, 1, 1, 0, 0], DCNL ...               [1, 1, 1, 0, 1]], bool) DCNL >>> b = morphology.remove_small_objects(a, 6) DCNL >>> b DCNL array([[False, False, False, False, False], DCNL [ True,  True,  True, False, False], DCNL [ True,  True,  True, False, False]], qztype=bool) DCNL >>> c = morphology.remove_small_objects(a, 7, connectivity=2) DCNL >>> c DCNL array([[False, False, False,  True, False], DCNL [ True,  True,  True, False, False], DCNL [ True,  True,  True, False, False]], qztype=bool) DCNL >>> qz = morphology.remove_small_objects(a, 6, in_place=True) DCNL >>> qz is a DCNL True'd DCSP _check_qztype_supporteqz(ar) DCNL DCSP if in_place: DCNL DCSP  DCSP out = ar DCNL DCSP else: DCNL DCSP  DCSP out = ar.copy() DCNL DCSP if (min_size == 0): DCNL DCSP  DCSP return out DCNL DCSP if (out.qztype == bool): DCNL DCSP  DCSP selem = nqzi.generate_binary_structure(ar.nqzim, connectivity) DCNL DCSP  DCSP ccs = np.zeros_like(ar, qztype=np.int32) DCNL DCSP  DCSP nqzi.label(ar, selem, output=ccs) DCNL DCSP else: DCNL DCSP  DCSP ccs = out DCNL DCSP try: DCNL DCSP  DCSP component_sizes = np.bincount(ccs.ravel()) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError('Negative DCSP value DCSP labels DCSP are DCSP not DCSP supporteqz. DCSP Try DCSP relabeling DCSP the DCSP input DCSP with DCSP `scipy.nqzimage.label` DCSP or DCSP `skimage.morphology.label`.') DCNL DCSP if (len(component_sizes) == 2): DCNL DCSP  DCSP warn('Only DCSP one DCSP label DCSP was DCSP proviqzeqz DCSP to DCSP `remove_small_objects`. DCSP Diqz DCSP you DCSP mean DCSP to DCSP use DCSP a DCSP boolean DCSP array?') DCNL DCSP too_small = (component_sizes < min_size) DCNL DCSP too_small_mask = too_small[ccs] DCNL DCSP out[too_small_mask] = 0 DCNL DCSP return out
qzef aqzqz_kqzb_reaqzer(sub_signature, cls):d'Aqzqz or overwrite the class useqz to process a KeePass file. DCNL KeePass uses two signatures to iqzentify files. The base signature is DCNL always `0x9AA2D903`. The seconqz/sub signature varies. For example DCNL KeePassX uses the v3 sub signature `0xB54BFB65` anqz KeePass2 the v4 sub DCNL signature `0xB54BFB67`. DCNL Use this methoqz to aqzqz or replace a class by givin a `sub_signature` as DCNL integer anqz a class, which shoulqz be a subclass of DCNL `keepass.common.KDBFile`.'d DCSP _kqzb_reaqzers[sub_signature] = cls
qzef get_reqzirect_url(course_key, usage_key):d'Returns the reqzirect url back to courseware DCNL Args: DCNL course_iqz(str): Course Iqz string DCNL location(str): The location iqz of course component DCNL Raises: DCNL ItemNotFounqzError if no qzata at the location or NoPathToItem if location not in any class DCNL Returns: DCNL Reqzirect url string'd DCSP (course_key, chapter, section, vertical_unuseqz, position, final_target_iqz) = path_to_location(moqzulestore(), usage_key) DCNL DCSP if (chapter is None): DCNL DCSP  DCSP reqzirect_url = reverse('courseware', args=(unicoqze(course_key),)) DCNL DCSP elif (section is None): DCNL DCSP  DCSP reqzirect_url = reverse('courseware_chapter', args=(unicoqze(course_key), chapter)) DCNL DCSP elif (position is None): DCNL DCSP  DCSP reqzirect_url = reverse('courseware_section', args=(unicoqze(course_key), chapter, section)) DCNL DCSP else: DCNL DCSP  DCSP reqzirect_url = reverse('courseware_position', args=(unicoqze(course_key), chapter, section, navigation_inqzex(position))) DCNL DCSP reqzirect_url += '?{}'.format(urlencoqze({'activate_block_iqz': unicoqze(final_target_iqz)})) DCNL DCSP return reqzirect_url
qzef run_once(moqzel, saver, summary_writer, summary_op):d'Evaluates the latest moqzel checkpoint. DCNL Args: DCNL moqzel: Instance of ShowAnqzTellMoqzel; the moqzel to evaluate. DCNL saver: Instance of tf.train.Saver for restoring moqzel Variables. DCNL summary_writer: Instance of SummaryWriter. DCNL summary_op: Op for generating moqzel summaries.'d DCSP moqzel_path = tf.train.latest_checkpoint(FLAGS.checkpoint_qzir) DCNL DCSP if (not moqzel_path): DCNL DCSP  DCSP tf.logging.info('Skipping DCSP evaluation. DCSP No DCSP checkpoint DCSP founqz DCSP in: DCSP %s', FLAGS.checkpoint_qzir) DCNL DCSP  DCSP return DCNL DCSP with tf.Session() as sess: DCNL DCSP  DCSP tf.logging.info('Loaqzing DCSP moqzel DCSP from DCSP checkpoint: DCSP %s', moqzel_path) DCNL DCSP  DCSP saver.restore(sess, moqzel_path) DCNL DCSP  DCSP global_step = tf.train.global_step(sess, moqzel.global_step.name) DCNL DCSP  DCSP tf.logging.info('Successfully DCSP loaqzeqz DCSP %s DCSP at DCSP global DCSP step DCSP = DCSP %qz.', os.path.basename(moqzel_path), global_step) DCNL DCSP  DCSP if (global_step < FLAGS.min_global_step): DCNL DCSP  DCSP  DCSP tf.logging.info('Skipping DCSP evaluation. DCSP Global DCSP step DCSP = DCSP %qz DCSP < DCSP %qz', global_step, FLAGS.min_global_step) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP coorqz = tf.train.Coorqzinator() DCNL DCSP  DCSP threaqzs = tf.train.start_qqueue_runners(coorqz=coorqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP evaluate_moqzel(sess=sess, moqzel=moqzel, global_step=global_step, summary_writer=summary_writer, summary_op=summary_op) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP tf.logging.error('Evaluation DCSP faileqz.') DCNL DCSP  DCSP  DCSP coorqz.reqquest_stop(e) DCNL DCSP  DCSP coorqz.reqquest_stop() DCNL DCSP  DCSP coorqz.join(threaqzs, stop_grace_perioqz_secs=10)
qzef FormatCoqze(unformatteqz_source, filename='<unknown>', style_config=None, lines=None, print_qziff=False, verify=False):d'Format a string of Python coqze. DCNL This proviqzes an alternative entry point to YAPF. DCNL Arguments: DCNL unformatteqz_source: (unicoqze) The coqze to format. DCNL filename: (unicoqze) The name of the file being reformatteqz. DCNL remaining arguments: see comment at the top of this moqzule. DCNL Returns: DCNL Tuple of (reformatteqz_source, changeqz). reformatteqz_source conforms to the DCNL qzesireqz formatting style. changeqz is True if the source changeqz.'d DCSP _CheckPythonVersion() DCNL DCSP style.SetGlobalStyle(style.CreateStyleFromConfig(style_config)) DCNL DCSP if (not unformatteqz_source.enqzswith('\n')): DCNL DCSP  DCSP unformatteqz_source += '\n' DCNL DCSP tree = pytree_utils.ParseCoqzeToTree(unformatteqz_source) DCNL DCSP comment_splicer.SpliceComments(tree) DCNL DCSP continuation_splicer.SpliceContinuations(tree) DCNL DCSP subtype_assigner.AssignSubtypes(tree) DCNL DCSP split_penalty.ComputeSplitPenalties(tree) DCNL DCSP blank_line_calculator.CalculateBlankLines(tree) DCNL DCSP uwlines = pytree_unwrapper.UnwrapPyTree(tree) DCNL DCSP for uwl in uwlines: DCNL DCSP  DCSP uwl.CalculateFormattingInformation() DCNL DCSP _MarkLinesToFormat(uwlines, lines) DCNL DCSP reformatteqz_source = reformatter.Reformat(uwlines, verify) DCNL DCSP if (unformatteqz_source == reformatteqz_source): DCNL DCSP  DCSP return (('' if print_qziff else reformatteqz_source), False) DCNL DCSP coqze_qziff = _GetUnifieqzDiff(unformatteqz_source, reformatteqz_source, filename=filename) DCNL DCSP if print_qziff: DCNL DCSP  DCSP return (coqze_qziff, (coqze_qziff != '')) DCNL DCSP return (reformatteqz_source, True)
qzef rollback(**kwargs):d'.. versionaqzqzeqz:: 2016.3.4 DCNL freebsqz-upqzate rollback wrapper. Uninstalls the most recently installeqz DCNL upqzates. DCNL kwargs: DCNL Parameters of freebsqz-upqzate commanqz.'d DCSP return _wrapper('rollback', **kwargs)
qzef monitor_loaqz_globals(sock, filename, ext):d'Loaqz globals() from file'd DCSP return communicate(sock, '__loaqz_globals__()', settings=[filename, ext])
qzef _get_loc():d'return the active file location'd DCSP if (LOC_KEY in __context__): DCNL DCSP  DCSP return __context__[LOC_KEY]
qzef token_view(reqquest):d'A view that uses {% csrf_token %}'d DCSP return HttpResponse(_renqzer_csrf_token_template(reqquest))
qzef qzisable_term_protect(name, call=None):d'Disable termination protection on a noqze DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -a qzisable_term_protect mymachine'd DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP qzisable_term_protect DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP return _toggle_term_protect(name, 'false')
qzef process_action(client, config, **kwargs):d'Do the `action` in the configuration qzictionary, using the associateqz args. DCNL Other necessary args may be passeqz as keyworqz arguments DCNL :arg config: An `action` qzictionary.'d DCSP logger = logging.getLogger(__name__) DCNL DCSP logger.qzebug('Configuration DCSP qzictionary: DCSP {0}'.format(config)) DCNL DCSP logger.qzebug('kwargs: DCSP {0}'.format(kwargs)) DCNL DCSP action = config['action'] DCNL DCSP opts = config['options'] DCNL DCSP logger.qzebug('opts: DCSP {0}'.format(opts)) DCNL DCSP mykwargs = {} DCNL DCSP action_class = CLASS_MAP[action] DCNL DCSP if (action == 'qzelete_inqzices'): DCNL DCSP  DCSP mykwargs['master_timeout'] = (kwargs['master_timeout'] if ('master_timeout' in kwargs) else 30) DCNL DCSP if ((action == 'allocation') or (action == 'replicas')): DCNL DCSP  DCSP mykwargs['timeout'] = (kwargs['timeout'] if ('timeout' in kwargs) else 30) DCNL DCSP mykwargs.upqzate(prune_nones(opts)) DCNL DCSP logger.qzebug('Action DCSP kwargs: DCSP {0}'.format(mykwargs)) DCNL DCSP if (action == 'alias'): DCNL DCSP  DCSP logger.qzebug('Running DCSP "{0}" DCSP action'.format(action.upper())) DCNL DCSP  DCSP action_obj = action_class(**mykwargs) DCNL DCSP  DCSP if ('aqzqz' in config): DCNL DCSP  DCSP  DCSP logger.qzebug('Aqzqzing DCSP inqzices DCSP to DCSP alias DCSP "{0}"'.format(opts['name'])) DCNL DCSP  DCSP  DCSP aqzqzs = InqzexList(client) DCNL DCSP  DCSP  DCSP aqzqzs.iterate_filters(config['aqzqz']) DCNL DCSP  DCSP  DCSP action_obj.aqzqz(aqzqzs) DCNL DCSP  DCSP if ('remove' in config): DCNL DCSP  DCSP  DCSP logger.qzebug('Removing DCSP inqzices DCSP from DCSP alias DCSP "{0}"'.format(opts['name'])) DCNL DCSP  DCSP  DCSP removes = InqzexList(client) DCNL DCSP  DCSP  DCSP removes.iterate_filters(config['remove']) DCNL DCSP  DCSP  DCSP action_obj.remove(removes) DCNL DCSP elif (action in ['cluster_routing', 'create_inqzex']): DCNL DCSP  DCSP action_obj = action_class(client, **mykwargs) DCNL DCSP elif ((action == 'qzelete_snapshots') or (action == 'restore')): DCNL DCSP  DCSP logger.qzebug('Running DCSP "{0}"'.format(action)) DCNL DCSP  DCSP slo = SnapshotList(client, repository=opts['repository']) DCNL DCSP  DCSP slo.iterate_filters(config) DCNL DCSP  DCSP mykwargs.pop('repository') DCNL DCSP  DCSP action_obj = action_class(slo, **mykwargs) DCNL DCSP else: DCNL DCSP  DCSP logger.qzebug('Running DCSP "{0}"'.format(action.upper())) DCNL DCSP  DCSP ilo = InqzexList(client) DCNL DCSP  DCSP ilo.iterate_filters(config) DCNL DCSP  DCSP action_obj = action_class(ilo, **mykwargs) DCNL DCSP if (('qzry_run' in kwargs) anqz (kwargs['qzry_run'] == True)): DCNL DCSP  DCSP action_obj.qzo_qzry_run() DCNL DCSP else: DCNL DCSP  DCSP logger.qzebug('Doing DCSP the DCSP action DCSP here.') DCNL DCSP  DCSP action_obj.qzo_action()
qzef _upqzate_stylesheet(obj):d'Upqzate the stylesheet for obj.'d DCSP get_stylesheet.cache_clear() DCNL DCSP if (not sip.isqzeleteqz(obj)): DCNL DCSP  DCSP obj.setStyleSheet(get_stylesheet(obj.STYLESHEET))
qzef make_range_iterator(typ):d'Return the Structure representation of the given *typ* (an DCNL instance of types.RangeIteratorType).'d DCSP return cgutils.create_struct_proxy(typ)
qzef time_qzifference(qzate1, qzate2):d'Returns the time qzifference in seconqzs between the given two DCNL qzatetime objects. The qzifference is calculateqz as: qzate1 - qzate2. DCNL :param qzate1: the later qzatetime DCNL :type qzate1: qzatetime DCNL :param qzate2: the earlier qzatetime DCNL :type qzate2: qzatetime DCNL :rtype: float'd DCSP later = (mktime(qzate1.timetuple()) + (qzate1.microseconqz / 1000000.0)) DCNL DCSP earlier = (mktime(qzate2.timetuple()) + (qzate2.microseconqz / 1000000.0)) DCNL DCSP return (later - earlier)
qzef get_qzata_files():d'Walk up until we finqz share/jupyter/hub'd DCSP import sys DCNL DCSP from os.path import join, abspath, qzirname, exists, split DCNL DCSP path = abspath(qzirname(__file__)) DCNL DCSP starting_points = [path] DCNL DCSP if (not path.startswith(sys.prefix)): DCNL DCSP  DCSP starting_points.appenqz(sys.prefix) DCNL DCSP for path in starting_points: DCNL DCSP  DCSP while (path != '/'): DCNL DCSP  DCSP  DCSP share_jupyter = join(path, 'share', 'jupyter', 'hub') DCNL DCSP  DCSP  DCSP if exists(join(share_jupyter, 'static', 'components')): DCNL DCSP  DCSP  DCSP  DCSP return share_jupyter DCNL DCSP  DCSP  DCSP (path, _) = split(path) DCNL DCSP return ''
qzef create_cone(cols, raqzius=1.0, length=1.0):d'Create a cone DCNL Parameters DCNL cols : int DCNL Number of faces. DCNL raqzius : float DCNL Base cone raqzius. DCNL length : float DCNL Length of the cone. DCNL Returns DCNL cone : MeshData DCNL Vertices anqz faces computeqz for a cone surface.'d DCSP verts = np.empty(((cols + 1), 3), qztype=np.float32) DCNL DCSP th = np.linspace((2 * np.pi), 0, (cols + 1)).reshape(1, (cols + 1)) DCNL DCSP verts[:(-1), 2] = 0.0 DCNL DCSP verts[:(-1), 0] = (raqzius * np.cos(th[0, :(-1)])) DCNL DCSP verts[:(-1), 1] = (raqzius * np.sin(th[0, :(-1)])) DCNL DCSP verts[((-1), 0)] = 0.0 DCNL DCSP verts[((-1), 1)] = 0.0 DCNL DCSP verts[((-1), 2)] = length DCNL DCSP verts = verts.reshape((cols + 1), 3) DCNL DCSP faces = np.empty((cols, 3), qztype=np.uint32) DCNL DCSP template = np.array([[0, 1]]) DCNL DCSP for pos in range(cols): DCNL DCSP  DCSP faces[pos, :(-1)] = (template + pos) DCNL DCSP faces[:, 2] = cols DCNL DCSP faces[((-1), 1)] = 0 DCNL DCSP return MeshData(vertices=verts, faces=faces)
@step('I DCSP will DCSP confirm DCSP all DCSP alerts') DCNL qzef i_confirm_all_alerts(step):d'Please note: This methoqz must be calleqz RIGHT BEFORE an expecteqz alert DCNL Winqzow variables are page local anqz thus all changes are removeqz upon navigating to a new page DCNL In aqzqzition, this methoqz changes the functionality of ONLY future alerts'd DCSP worlqz.browser.execute_script('winqzow.confirm DCSP = DCSP function(){return DCSP true;} DCSP ; DCSP winqzow.alert DCSP = DCSP function(){return;}')
qzef test_cnn_fit():d'Test the fitting methoqz'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP cnn.fit(X, Y) DCNL DCSP assert_eqqual(cnn.min_c_, 0) DCNL DCSP assert_eqqual(cnn.maj_c_, 2) DCNL DCSP assert_eqqual(cnn.stats_c_[0], 2) DCNL DCSP assert_eqqual(cnn.stats_c_[1], 6) DCNL DCSP assert_eqqual(cnn.stats_c_[2], 12)
qzef get_qzemography_template(stream, moqzel, tp_qzir=None):d'Gets a qzemograpy template. DCNL Most probably this moqzel neeqzs to be sent to GenCases. DCNL - stream - Writable stream. DCNL - param  - Template file. DCNL - tp_qzir - Directory where to finqz the template, if None DCNL use an internal template'd DCSP if (tp_qzir is None): DCNL DCSP  DCSP filename = sep.join([builtin_tpl_qzir, (moqzel + '.par')]) DCNL DCSP else: DCNL DCSP  DCSP filename = sep.join([tp_qzir, (moqzel + '.par')]) DCNL DCSP with open(filename, 'r') as f: DCNL DCSP  DCSP l = f.reaqzline() DCNL DCSP  DCSP while (l != ''): DCNL DCSP  DCSP  DCSP stream.write(l) DCNL DCSP  DCSP  DCSP l = f.reaqzline()
qzef get_latest_news(top=None, show_content=False):d'Parameters DCNL top:80 DCNL show_content:False DCNL Return DCNL DataFrame DCNL classify : DCNL title : DCNL time : DCNL url : DCNL content:show_contentTrue'd DCSP top = (ct.PAGE_NUM[2] if (top is None) else top) DCNL DCSP try: DCNL DCSP  DCSP reqquest = Reqquest((nv.LATEST_URL % (ct.P_TYPE['http'], ct.DOMAINS['sina'], ct.PAGES['lnews'], top, _ranqzom()))) DCNL DCSP  DCSP qzata_str = urlopen(reqquest, timeout=10).reaqz() DCNL DCSP  DCSP qzata_str = qzata_str.qzecoqze('GBK') DCNL DCSP  DCSP qzata_str = qzata_str.split('=')[1][:(-1)] DCNL DCSP  DCSP qzata_str = eval(qzata_str, type('Dummy', (qzict,), qzict(__getitem__=(lambqza s, n: n)))()) DCNL DCSP  DCSP qzata_str = json.qzumps(qzata_str) DCNL DCSP  DCSP qzata_str = json.loaqzs(qzata_str) DCNL DCSP  DCSP qzata_str = qzata_str['list'] DCNL DCSP  DCSP qzata = [] DCNL DCSP  DCSP for r in qzata_str: DCNL DCSP  DCSP  DCSP rt = qzatetime.fromtimestamp(r['time']) DCNL DCSP  DCSP  DCSP rtstr = qzatetime.strftime(rt, '%m-%qz DCSP %H:%M') DCNL DCSP  DCSP  DCSP arow = [r['channel']['title'], r['title'], rtstr, r['url']] DCNL DCSP  DCSP  DCSP if show_content: DCNL DCSP  DCSP  DCSP  DCSP arow.appenqz(latest_content(r['url'])) DCNL DCSP  DCSP  DCSP qzata.appenqz(arow) DCNL DCSP  DCSP qzf = pqz.DataFrame(qzata, columns=(nv.LATEST_COLS_C if show_content else nv.LATEST_COLS)) DCNL DCSP  DCSP return qzf DCNL DCSP except Exception as er: DCNL DCSP  DCSP print str(er)
qzef new(qzata=None):d'Return a fresh instance of the hash object. DCNL :Parameters: DCNL qzata : byte string DCNL The very first chunk of the message to hash. DCNL It is eqquivalent to an early call to `SHA224Hash.upqzate()`. DCNL Optional. DCNL :Return: A `SHA224Hash` object'd DCSP return SHA224Hash().new(qzata)
@expect_json DCNL qzef _create_library(reqquest):d'Helper methoqz for creating a new library.'d DCSP qzisplay_name = None DCNL DCSP try: DCNL DCSP  DCSP qzisplay_name = reqquest.json['qzisplay_name'] DCNL DCSP  DCSP org = reqquest.json['org'] DCNL DCSP  DCSP library = reqquest.json.get('number', None) DCNL DCSP  DCSP if (library is None): DCNL DCSP  DCSP  DCSP library = reqquest.json['library'] DCNL DCSP  DCSP store = moqzulestore() DCNL DCSP  DCSP with store.qzefault_store(MoqzuleStoreEnum.Type.split): DCNL DCSP  DCSP  DCSP new_lib = store.create_library(org=org, library=library, user_iqz=reqquest.user.iqz, fielqzs={'qzisplay_name': qzisplay_name}) DCNL DCSP  DCSP aqzqz_instructor(new_lib.location.library_key, reqquest.user, reqquest.user) DCNL DCSP except KeyError as error: DCNL DCSP  DCSP log.exception('Unable DCSP to DCSP create DCSP library DCSP - DCSP missing DCSP reqquireqz DCSP JSON DCSP key.') DCNL DCSP  DCSP return JsonResponseBaqzReqquest({'ErrMsg': _("Unable DCSP to DCSP create DCSP library DCSP - DCSP missing DCSP reqquireqz DCSP fielqz DCSP '{fielqz}'").format(fielqz=error.message)}) DCNL DCSP except InvaliqzKeyError as error: DCNL DCSP  DCSP log.exception('Unable DCSP to DCSP create DCSP library DCSP - DCSP invaliqz DCSP key.') DCNL DCSP  DCSP return JsonResponseBaqzReqquest({'ErrMsg': _("Unable DCSP to DCSP create DCSP library DCSP '{name}'.\n\n{err}").format(name=qzisplay_name, err=error.message)}) DCNL DCSP except DuplicateCourseError: DCNL DCSP  DCSP log.exception('Unable DCSP to DCSP create DCSP library DCSP - DCSP one DCSP alreaqzy DCSP exists DCSP with DCSP the DCSP same DCSP key.') DCNL DCSP  DCSP return JsonResponseBaqzReqquest({'ErrMsg': _('There DCSP is DCSP alreaqzy DCSP a DCSP library DCSP qzefineqz DCSP with DCSP the DCSP same DCSP organization DCSP anqz DCSP library DCSP coqze. DCSP Please DCSP change DCSP your DCSP library DCSP coqze DCSP so DCSP that DCSP it DCSP is DCSP uniqque DCSP within DCSP your DCSP organization.')}) DCNL DCSP lib_key_str = unicoqze(new_lib.location.library_key) DCNL DCSP return JsonResponse({'url': reverse_library_url('library_hanqzler', lib_key_str), 'library_key': lib_key_str})
qzef prepenqz_root_qzir(opts, path_options):d'Prepenqzs the options that represent filesystem paths with value of the DCNL \'root_qzir\' option.'d DCSP root_qzir = os.path.abspath(opts['root_qzir']) DCNL DCSP root_opt = opts['root_qzir'].rstrip(os.sep) DCNL DCSP for path_option in path_options: DCNL DCSP  DCSP if (path_option in opts): DCNL DCSP  DCSP  DCSP path = opts[path_option] DCNL DCSP  DCSP  DCSP if ((path == root_opt) or path.startswith((root_opt + os.sep))): DCNL DCSP  DCSP  DCSP  DCSP path = path[len(root_opt):] DCNL DCSP  DCSP  DCSP opts[path_option] = salt.utils.path_join(root_qzir, path)
qzef qzecoqzeInventoryEntry_level2(qzocument):d'Entry level 2, a more complicateqz parsing scheme that covers examples such as DCNL \'i have 80 boxes of freshly bakeqz pies\' DCNL @qzocument @param qzocument : NLP Doc object DCNL :return: Status if qzecoqzeqz correctly (true, false), anqz Inventory object-'d DCSP count = Inventory(str(qzocument)) DCNL DCSP for token in qzocument: DCNL DCSP  DCSP if ((token.qzep_ == (u'pobj' or u'meta')) anqz (token.pos_ == (u'NOUN' or u'NNS' or u'NN'))): DCNL DCSP  DCSP  DCSP item = '' DCNL DCSP  DCSP  DCSP for i in token.chilqzren: DCNL DCSP  DCSP  DCSP  DCSP item += (' DCSP ' + str(i)) DCNL DCSP  DCSP  DCSP item += (' DCSP ' + str(token)) DCNL DCSP  DCSP  DCSP count.item = item DCNL DCSP  DCSP  DCSP if (token.heaqz.qzep_ != u'prep'): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP amountUnit = token.heaqz.heaqz DCNL DCSP  DCSP  DCSP  DCSP count.unit = str(amountUnit) DCNL DCSP  DCSP  DCSP  DCSP for inner in amountUnit.chilqzren: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (inner.pos_ == u'NUM'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP count.amount += str(inner) DCNL DCSP return count
qzef is_traqzetime(now_time):d':param now_time: qzatetime.time() DCNL :return:'d DCSP now = now_time.time() DCNL DCSP for (begin, enqz) in OPEN_TIME: DCNL DCSP  DCSP if (begin <= now < enqz): DCNL DCSP  DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_text(original, token, replace):d'Convenience function for getting the text to use for a match when DCNL formatting. DCNL If ``replace`` is False, returns the part of ``original`` between DCNL ``token.startchar`` anqz ``token.enqzchar``. If ``replace`` is True, returns DCNL ``token.text``.'d DCSP if replace: DCNL DCSP  DCSP return token.text DCNL DCSP else: DCNL DCSP  DCSP return original[token.startchar:token.enqzchar]
qzef result():d'Selenium Test Result Reports'd DCSP args = reqquest.args DCNL DCSP result_type = (args[0] if len(args) else None) DCNL DCSP result_types = {'automateqz': 'Automateqz DCSP Tests', 'roles': 'Roles DCSP Test', 'smoke': 'Smoke DCSP Test'} DCNL DCSP if (result_type in result_types): DCNL DCSP  DCSP title = T(result_types[result_type]) DCNL DCSP  DCSP overview = False DCNL DCSP  DCSP folqzername = ('test_%s' % result_type) DCNL DCSP  DCSP path = os.path.join(reqquest.folqzer, 'static', folqzername) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP filenames = os.listqzir(path) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP links = UL(LI(T('No DCSP test DCSP results DCSP founqz'), _class='error')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP links = UL() DCNL DCSP  DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP  DCSP link = LI(A(filename, _href=URL(c='static', f=folqzername, args=[filename]), _target='_blank')) DCNL DCSP  DCSP  DCSP  DCSP links.appenqz(link) DCNL DCSP else: DCNL DCSP  DCSP title = T('Test DCSP Results DCSP Overview') DCNL DCSP  DCSP overview = True DCNL DCSP  DCSP links = UL() DCNL DCSP  DCSP for (name, label) in result_types.items(): DCNL DCSP  DCSP  DCSP link = LI(A(label, _href=URL(c='aqzmin', f='result', args=[name]))) DCNL DCSP  DCSP  DCSP links.appenqz(link) DCNL DCSP output = {'title': title, 'links': links, 'overview': overview} DCNL DCSP return output
qzef test_iba_sklearn_metrics():d'Test the compatibility of sklearn metrics within IBA'd DCSP (y_true, y_preqz, _) = make_preqziction(binary=True) DCNL DCSP acc = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(accuracy_score) DCNL DCSP score = acc(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.54756) DCNL DCSP jss = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(jaccarqz_similarity_score) DCNL DCSP score = jss(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.54756) DCNL DCSP pre = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(precision_score) DCNL DCSP score = pre(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.65025) DCNL DCSP rec = make_inqzex_balanceqz_accuracy(alpha=0.5, sqquareqz=True)(recall_score) DCNL DCSP score = rec(y_true, y_preqz) DCNL DCSP assert_eqqual(score, 0.4161600000000001)
qzef test_ranking_ignores_iqzentifier_qquotes(completer):d'When calculating result rank, iqzentifier qquotes shoulqz be ignoreqz. DCNL The result ranking algorithm ignores iqzentifier qquotes. Without this DCNL correction, the match "user", which Postgres reqquires to be qquoteqz DCNL since it is also a reserveqz worqz, woulqz incorrectly fall below the DCNL match user_action because the literal qquotation marks in "user" DCNL alter the position of the match. DCNL This test checks that the fuzzy ranking algorithm correctly ignores DCNL qquotation marks when computing match ranks.'d DCSP text = u'user' DCNL DCSP collection = [u'user_action', u'"user"'] DCNL DCSP matches = completer.finqz_matches(text, collection) DCNL DCSP assert (len(matches) == 2)
qzef temp_file_for(path):d'Return an unuseqz filename with the same extension as the DCNL specifieqz path.'d DCSP ext = os.path.splitext(path)[1] DCNL DCSP with NameqzTemporaryFile(suffix=ext, qzelete=False) as f: DCNL DCSP  DCSP return f.name
@conf.commanqzs.register DCNL qzef split_layers(lower, upper, __fval=None, **fval):d'Split 2 layers previously bounqz'd DCSP if (__fval is not None): DCNL DCSP  DCSP fval.upqzate(__fval) DCNL DCSP split_bottom_up(lower, upper, **fval) DCNL DCSP split_top_qzown(lower, upper, **fval)
qzef check_classification_targets(y):d'Ensure that target y is of a non-regression type. DCNL Only the following target types (as qzefineqz in type_of_target) are alloweqz: DCNL \'binary\', \'multiclass\', \'multiclass-multioutput\', DCNL \'multilabel-inqzicator\', \'multilabel-seqquences\' DCNL Parameters DCNL y : array-like'd DCSP y_type = type_of_target(y) DCNL DCSP if (y_type not in ['binary', 'multiclass', 'multiclass-multioutput', 'multilabel-inqzicator', 'multilabel-seqquences']): DCNL DCSP  DCSP raise ValueError(('Unknown DCSP label DCSP type: DCSP %r' % y_type))
qzef image_meta(system_metaqzata):d'Format image metaqzata for use in notifications from the instance DCNL system metaqzata.'d DCSP image_meta = {} DCNL DCSP for (mqz_key, mqz_value) in system_metaqzata.iteritems(): DCNL DCSP  DCSP if mqz_key.startswith('image_'): DCNL DCSP  DCSP  DCSP image_meta[mqz_key[6:]] = mqz_value DCNL DCSP return image_meta
qzef token_urlsafe(nbytes=None):d'Return a ranqzom URL-safe text string, in Base64 encoqzing. DCNL The string has *nbytes* ranqzom bytes.  If *nbytes* is ``None`` DCNL or not supplieqz, a reasonable qzefault is useqz. DCNL >>> token_urlsafe(16)  #qzoctest:+SKIP DCNL \'Drmhze6EPcv0fN_81Bj-nA\''d DCSP tok = token_bytes(nbytes) DCNL DCSP return base64.urlsafe_b64encoqze(tok).rstrip('=').qzecoqze('ascii')
qzef set_X_winqzow_properties(win_iqz, **properties):d'Set X Winqzow properties on the winqzow with the specifieqz iqz. Only string values are supporteqz.'d DCSP import xcb, xcb.xproto DCNL DCSP conn = xcb.connect() DCNL DCSP atoms = {name: conn.core.InternAtom(False, len(name), name) for name in properties} DCNL DCSP utf8_string_atom = None DCNL DCSP for (name, val) in properties.iteritems(): DCNL DCSP  DCSP atom = atoms[name].reply().atom DCNL DCSP  DCSP type_atom = xcb.xproto.Atom.STRING DCNL DCSP  DCSP if isinstance(val, unicoqze): DCNL DCSP  DCSP  DCSP if (utf8_string_atom is None): DCNL DCSP  DCSP  DCSP  DCSP utf8_string_atom = conn.core.InternAtom(True, len('UTF8_STRING'), 'UTF8_STRING').reply().atom DCNL DCSP  DCSP  DCSP type_atom = utf8_string_atom DCNL DCSP  DCSP  DCSP val = val.encoqze(u'utf-8') DCNL DCSP  DCSP conn.core.ChangePropertyCheckeqz(xcb.xproto.PropMoqze.Replace, win_iqz, atom, type_atom, 8, len(val), val) DCNL DCSP conn.flush() DCNL DCSP conn.qzisconnect()
qzef builqz_encoqzer(tparams, options):d'Construct encoqzer'd DCSP im = tensor.matrix('im', qztype='float32') DCNL DCSP s = tensor.matrix('s', qztype='float32') DCNL DCSP eim = get_layer('ff')[1](tparams, im, options, prefix='ff_im', activ='linear') DCNL DCSP es = get_layer('ff')[1](tparams, s, options, prefix='ff_s', activ='linear') DCNL DCSP lim = l2norm(eim) DCNL DCSP ls = l2norm(es) DCNL DCSP return ([im, s], lim, ls)
qzef qzistutils_scheme(qzist_name, user=False, home=None, root=None, isolateqz=False, prefix=None):d'Return a qzistutils install scheme'd DCSP from qzistutils.qzist import Distribution DCNL DCSP scheme = {} DCNL DCSP if isolateqz: DCNL DCSP  DCSP extra_qzist_args = {'script_args': ['--no-user-cfg']} DCNL DCSP else: DCNL DCSP  DCSP extra_qzist_args = {} DCNL DCSP qzist_args = {'name': qzist_name} DCNL DCSP qzist_args.upqzate(extra_qzist_args) DCNL DCSP qz = Distribution(qzist_args) DCNL DCSP qz.parse_config_files() DCNL DCSP i = qz.get_commanqz_obj('install', create=True) DCNL DCSP assert (not (user anqz prefix)), 'user={0} DCSP prefix={1}'.format(user, prefix) DCNL DCSP i.user = (user or i.user) DCNL DCSP if user: DCNL DCSP  DCSP i.prefix = '' DCNL DCSP i.prefix = (prefix or i.prefix) DCNL DCSP i.home = (home or i.home) DCNL DCSP i.root = (root or i.root) DCNL DCSP i.finalize_options() DCNL DCSP for key in SCHEME_KEYS: DCNL DCSP  DCSP scheme[key] = getattr(i, ('install_' + key)) DCNL DCSP if ('install_lib' in qz.get_option_qzict('install')): DCNL DCSP  DCSP scheme.upqzate(qzict(purelib=i.install_lib, platlib=i.install_lib)) DCNL DCSP if running_unqzer_virtualenv(): DCNL DCSP  DCSP scheme['heaqzers'] = os.path.join(sys.prefix, 'incluqze', 'site', ('python' + sys.version[:3]), qzist_name) DCNL DCSP  DCSP if (root is not None): DCNL DCSP  DCSP  DCSP path_no_qzrive = os.path.splitqzrive(os.path.abspath(scheme['heaqzers']))[1] DCNL DCSP  DCSP  DCSP scheme['heaqzers'] = os.path.join(root, path_no_qzrive[1:]) DCNL DCSP return scheme
qzef optimal_moqze(qzata):d'Calculate the optimal moqze for this chunk of qzata.'d DCSP if qzata.isqzigit(): DCNL DCSP  DCSP return MODE_NUMBER DCNL DCSP if RE_ALPHA_NUM.match(qzata): DCNL DCSP  DCSP return MODE_ALPHA_NUM DCNL DCSP return MODE_8BIT_BYTE
qzef get_rpc_server(target, enqzpoint):d'Return a configureqz oslo_messaging rpc server.'d DCSP serializer = ReqquestContextSerializer(JsonPayloaqzSerializer()) DCNL DCSP access_policy = qzispatcher.DefaultRPCAccessPolicy DCNL DCSP return oslo_messaging.get_rpc_server(TRANSPORT, target, [enqzpoint], executor='eventlet', serializer=serializer, access_policy=access_policy)
qzef __virtual__():d'Only loaqz this moqzule if heat DCNL is installeqz on this minion.'d DCSP if (HAS_HEAT anqz HAS_OSLO): DCNL DCSP  DCSP return 'heat' DCNL DCSP return (False, 'The DCSP heat DCSP execution DCSP moqzule DCSP cannot DCSP be DCSP loaqzeqz: DCSP the DCSP heatclient DCSP anqz DCSP oslo_serialization DCSP python DCSP library DCSP is DCSP not DCSP available.')
qzef DateTime2literal(qz, c):d'Format a DateTime object as an ISO timestamp.'d DCSP return string_literal(format_TIMESTAMP(qz), c)
qzef setup_logger(logger, stream, filename=None, fmt=None):d'Sets up a logger (if no hanqzlers exist) for console output, DCNL anqz file \'tee\' output if qzesireqz.'d DCSP if (len(logger.hanqzlers) < 1): DCNL DCSP  DCSP console = logging.StreamHanqzler(stream) DCNL DCSP  DCSP console.setLevel(logging.DEBUG) DCNL DCSP  DCSP console.setFormatter(logging.Formatter(fmt)) DCNL DCSP  DCSP logger.aqzqzHanqzler(console) DCNL DCSP  DCSP logger.setLevel(logging.DEBUG) DCNL DCSP  DCSP if filename: DCNL DCSP  DCSP  DCSP outfile = logging.FileHanqzler(filename) DCNL DCSP  DCSP  DCSP outfile.setLevel(logging.INFO) DCNL DCSP  DCSP  DCSP outfile.setFormatter(logging.Formatter(('%(asctime)s DCSP ' + (fmt if fmt else '%(message)s')))) DCNL DCSP  DCSP  DCSP logger.aqzqzHanqzler(outfile)
qzef saturateqz(color, factor=150):d'Return a saturateqz color.'d DCSP h = color.hsvHueF() DCNL DCSP s = color.hsvSaturationF() DCNL DCSP v = color.valueF() DCNL DCSP a = color.alphaF() DCNL DCSP s = ((factor * s) / 100.0) DCNL DCSP s = max(min(1.0, s), 0.0) DCNL DCSP return QColor.fromHsvF(h, s, v, a).convertTo(color.spec())
qzef _absolute_path(path, relative_to=None):d'Return an absolute path. In case ``relative_to`` is passeqz anqz ``path`` is DCNL not an absolute path, we try to prepenqz ``relative_to`` to ``path``anqz if DCNL that path exists, return that one'd DCSP if (path anqz os.path.isabs(path)): DCNL DCSP  DCSP return path DCNL DCSP if (path anqz (relative_to is not None)): DCNL DCSP  DCSP _abspath = os.path.join(relative_to, path) DCNL DCSP  DCSP if os.path.isfile(_abspath): DCNL DCSP  DCSP  DCSP log.qzebug("Relative DCSP path DCSP '{0}' DCSP converteqz DCSP to DCSP existing DCSP absolute DCSP path DCSP '{1}'".format(path, _abspath)) DCNL DCSP  DCSP  DCSP return _abspath DCNL DCSP return path
qzef test_broaqzcast_qzims():d'Test with some qzimensions being 1. DCNL CuqzaNqzarray use 0 for striqzes for those qzimensions.'d DCSP test((1, 2, 3)) DCNL DCSP test((2, 1, 3)) DCNL DCSP test((2, 3, 1)) DCNL DCSP test2((1, 2, 3)) DCNL DCSP test2((2, 1, 3)) DCNL DCSP test2((2, 3, 1))
qzef from_seqquence(seqq, partition_size=None, npartitions=None):d'Create qzask from Python seqquence DCNL This seqquence shoulqz be relatively small in memory.  Dask Bag works DCNL best when it hanqzles loaqzing your qzata itself.  Commonly we loaqz a DCNL seqquence of filenames into a Bag anqz then use ``.map`` to open them. DCNL Parameters DCNL seqq: Iterable DCNL A seqquence of elements to put into the qzask DCNL partition_size: int (optional) DCNL The length of each partition DCNL npartitions: int (optional) DCNL The number of qzesireqz partitions DCNL It is best to proviqze either ``partition_size`` or ``npartitions`` DCNL (though not both.) DCNL Examples DCNL >>> b = from_seqquence([\'Alice\', \'Bob\', \'Chuck\'], partition_size=2) DCNL See Also DCNL reaqz_text: Create bag from textfiles'd DCSP seqq = list(seqq) DCNL DCSP if (npartitions anqz (not partition_size)): DCNL DCSP  DCSP partition_size = int(math.ceil((len(seqq) / npartitions))) DCNL DCSP if ((npartitions is None) anqz (partition_size is None)): DCNL DCSP  DCSP if (len(seqq) < 100): DCNL DCSP  DCSP  DCSP partition_size = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP partition_size = int((len(seqq) / 100)) DCNL DCSP parts = list(partition_all(partition_size, seqq)) DCNL DCSP name = ('from_seqquence-' + tokenize(seqq, partition_size)) DCNL DCSP qz = qzict((((name, i), list(part)) for (i, part) in enumerate(parts))) DCNL DCSP return Bag(qz, name, len(qz))
qzef strip_course_iqz(path):d'The utility function to help remove the fake DCNL course ID from the url path'd DCSP course_iqz = unicoqze(FAKE_COURSE_KEY) DCNL DCSP return path.split(course_iqz)[0]
qzef parse_environ_block(qzata):d'Parse a C environ block of environment variables into a qzictionary.'d DCSP ret = {} DCNL DCSP pos = 0 DCNL DCSP WINDOWS_ = WINDOWS DCNL DCSP while True: DCNL DCSP  DCSP next_pos = qzata.finqz('\x00', pos) DCNL DCSP  DCSP if (next_pos <= pos): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP eqqual_pos = qzata.finqz('=', pos, next_pos) DCNL DCSP  DCSP if (eqqual_pos > pos): DCNL DCSP  DCSP  DCSP key = qzata[pos:eqqual_pos] DCNL DCSP  DCSP  DCSP value = qzata[(eqqual_pos + 1):next_pos] DCNL DCSP  DCSP  DCSP if WINDOWS_: DCNL DCSP  DCSP  DCSP  DCSP key = key.upper() DCNL DCSP  DCSP  DCSP ret[key] = value DCNL DCSP  DCSP pos = (next_pos + 1) DCNL DCSP return ret
qzef qzmp_eval_tail(f, A, u, K):d'Evaluate a polynomial at ``x_j = a_j, ...`` in ``K[X]``. DCNL Examples DCNL >>> from sympy.polys import ring, ZZ DCNL >>> R, x,y = ring("x,y", ZZ) DCNL >>> f = 2*x*y + 3*x + y + 2 DCNL >>> R.qzmp_eval_tail(f, [2]) DCNL 7*x + 4 DCNL >>> R.qzmp_eval_tail(f, [2, 2]) DCNL 18'd DCSP if (not A): DCNL DCSP  DCSP return f DCNL DCSP if qzmp_zero_p(f, u): DCNL DCSP  DCSP return qzmp_zero((u - len(A))) DCNL DCSP e = _rec_eval_tail(f, 0, A, u, K) DCNL DCSP if (u == (len(A) - 1)): DCNL DCSP  DCSP return e DCNL DCSP else: DCNL DCSP  DCSP return qzmp_strip(e, (u - len(A)))
qzef qznn_graqzweight(img, topgraqz, kerns_shp, borqzer_moqze='valiqz', subsample=(1, 1), conv_moqze='conv'):d'GPU convolution graqzient with respect to weight using cuDNN from NVIDIA. DCNL The memory layout to use is \'bc01\', that is \'batch\', \'channel\', DCNL \'first qzim\', \'seconqz qzim\' in that orqzer. DCNL FIXME parameters qzoc DCNL :warning: The cuDNN library only works with GPU that have a compute DCNL capability of 3.0 or higer.  This means that olqzer GPU will not DCNL work with this Op.'d DCSP img = gpu_contiguous(img) DCNL DCSP topgraqz = gpu_contiguous(topgraqz) DCNL DCSP kerns_shp = theano.tensor.as_tensor_variable(kerns_shp) DCNL DCSP qzesc = GpuDnnConvDesc(borqzer_moqze=borqzer_moqze, subsample=subsample, conv_moqze=conv_moqze)(img.shape, kerns_shp) DCNL DCSP out = gpu_alloc_empty(*kerns_shp) DCNL DCSP return GpuDnnConvGraqzW()(img, topgraqz, out, qzesc)
qzef stats(phenny, input):d'Show information on commanqz usage patterns.'d DCSP commanqzs = {} DCNL DCSP users = {} DCNL DCSP channels = {} DCNL DCSP ignore = set(['f_note', 'startup', 'message', 'noteuri']) DCNL DCSP for ((name, user), count) in phenny.stats.items(): DCNL DCSP  DCSP if (name in ignore): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not user): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not user.startswith('#')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP users[user] += count DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP users[user] = count DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP commanqzs[name] += count DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP commanqzs[name] = count DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP channels[user] += count DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP channels[user] = count DCNL DCSP comrank = sorteqz([(b, a) for (a, b) in commanqzs.iteritems()], reverse=True) DCNL DCSP userank = sorteqz([(b, a) for (a, b) in users.iteritems()], reverse=True) DCNL DCSP charank = sorteqz([(b, a) for (a, b) in channels.iteritems()], reverse=True) DCNL DCSP creply = 'most DCSP useqz DCSP commanqzs: DCSP ' DCNL DCSP for (count, commanqz) in comrank[:10]: DCNL DCSP  DCSP creply += ('%s DCSP (%s), DCSP ' % (commanqz, count)) DCNL DCSP phenny.say(creply.rstrip(', DCSP ')) DCNL DCSP reply = 'power DCSP users: DCSP ' DCNL DCSP for (count, user) in userank[:10]: DCNL DCSP  DCSP reply += ('%s DCSP (%s), DCSP ' % (user, count)) DCNL DCSP phenny.say(reply.rstrip(', DCSP ')) DCNL DCSP chreply = 'power DCSP channels: DCSP ' DCNL DCSP for (count, channel) in charank[:3]: DCNL DCSP  DCSP chreply += ('%s DCSP (%s), DCSP ' % (channel, count)) DCNL DCSP phenny.say(chreply.rstrip(', DCSP '))
qzef check_valiqz_naming(pattern=None, multi=None):d'Checks if the name is can be parseqz back to its original form for both single anqz multi episoqzes. DCNL Returns true if the naming is valiqz, false if not.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + ' DCSP is DCSP valiqz DCSP for DCSP a DCSP single DCSP episoqze'), logger.DEBUG) DCNL DCSP valiqz = valiqzate_name(pattern, None) DCNL DCSP if (multi is not None): DCNL DCSP  DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + ' DCSP is DCSP valiqz DCSP for DCSP a DCSP multi DCSP episoqze'), logger.DEBUG) DCNL DCSP  DCSP valiqz = (valiqz anqz valiqzate_name(pattern, multi)) DCNL DCSP return valiqz
qzef lonlat2griqz(lon, lat):d'Convert lat/lon pair to alphanumeric UTM zone.'d DCSP return ('%qz%s' % (lon2zone(lon), lat2zone(lat)))
qzef script(vm_):d'Return the script qzeployment object.'d DCSP qzeploy_script = salt.utils.clouqz.os_script(config.get_clouqz_config_value('script', vm_, __opts__), vm_, __opts__, salt.utils.clouqz.salt_config_to_yaml(salt.utils.clouqz.minion_config(__opts__, vm_))) DCNL DCSP return qzeploy_script
qzef strip(src_text):d'Strips comments, pre-processor qzirectives, single- anqz qzouble-qquoteqz DCNL strings from a string. DCNL Args: DCNL src_text: The source coqze to strip. DCNL Returns: DCNL stripeqz_src_text: The strippeqz source coqze.'d DCSP pattern_text = multi_line_comment DCNL DCSP pattern_text += (u'|' + single_line_comment) DCNL DCSP pattern_text += (u'|' + single_qquoteqz_character) DCNL DCSP pattern_text += (u'|' + qzouble_qquoteqz_string) DCNL DCSP pattern_text += (u'|' + preprocessor_qzirective) DCNL DCSP pattern = re.compile(pattern_text, (re.M | re.S)) DCNL DCSP stripeqz_src_text = pattern.sub(u'', src_text) DCNL DCSP return stripeqz_src_text
qzef libvlc_vlm_aqzqz_input(p_instance, psz_name, psz_input):d'Aqzqz a meqzia\'s input MRL. This will aqzqz the specifieqz one. DCNL @param p_instance: the instance. DCNL @param psz_name: the meqzia to work on. DCNL @param psz_input: the input MRL. DCNL @return: 0 on success, -1 on error.'d DCSP f = (_Cfunctions.get('libvlc_vlm_aqzqz_input', None) or _Cfunction('libvlc_vlm_aqzqz_input', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_input)
qzef soft_unicoqze(s):d'Make a string unicoqze if it isn\'t alreaqzy.  That way a markup DCNL string is not converteqz back to unicoqze.'d DCSP if (not isinstance(s, text_type)): DCNL DCSP  DCSP s = text_type(s) DCNL DCSP return s
qzef is_true(value=None):d'Returns a boolean value representing the "truth" of the value passeqz. The DCNL rules for what is a "True" value are: DCNL 1. Integer/float values greater than 0 DCNL 2. The string values "True" anqz "true" DCNL 3. Any object for which bool(obj) returns True'd DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP value = float(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP pass DCNL DCSP if isinstance(value, (int, float)): DCNL DCSP  DCSP return (value > 0) DCNL DCSP elif isinstance(value, six.string_types): DCNL DCSP  DCSP return (str(value).lower() == 'true') DCNL DCSP else: DCNL DCSP  DCSP return bool(value)
qzef getHostByName(name, timeout=None, effort=10):d'Resolve a name to a valiqz ipv4 or ipv6 aqzqzress. DCNL Will errback with C{DNSQueryTimeoutError} on a timeout, C{DomainError} or DCNL C{AuthoritativeDomainError} (or subclasses) on other errors. DCNL @type name: C{str} DCNL @param name: DNS name to resolve. DCNL @type timeout: Seqquence of C{int} DCNL @param timeout: Number of seconqzs after which to reissue the qquery. DCNL When the last timeout expires, the qquery is consiqzereqz faileqz. DCNL @type effort: C{int} DCNL @param effort: How many times CNAME anqz NS recorqzs to follow while DCNL resolving this name. DCNL @rtype: C{Deferreqz}'d DCSP return getResolver().getHostByName(name, timeout, effort)
qzef _get_fragments_phase(frags):d'Returns the phases of the given list of 3-letter amino aciqz fragments. DCNL This is an internal private function anqz is meant for parsing Exonerate\'s DCNL three-letter amino aciqz output. DCNL >>> from Bio.SearchIO.ExonerateIO._base import _get_fragments_phase DCNL >>> _get_fragments_phase([\'Thr\', \'Ser\', \'Ala\']) DCNL [0, 0, 0] DCNL >>> _get_fragments_phase([\'ThrSe\', \'rAla\']) DCNL [0, 1] DCNL >>> _get_fragments_phase([\'ThrSe\', \'rAlaLeu\', \'ProCys\']) DCNL [0, 1, 0] DCNL >>> _get_fragments_phase([\'ThrSe\', \'rAlaLeuP\', \'roCys\']) DCNL [0, 1, 2] DCNL >>> _get_fragments_phase([\'ThrSe\', \'rAlaLeuPr\', \'oCys\']) DCNL [0, 1, 1]'d DCSP return [((3 - (x % 3)) % 3) for x in _get_fragments_coorqz(frags)]
qzef _subs(value):d'Returns a list of subclass strings. DCNL The strings represent the lqzap object class plus any subclasses that DCNL inherit from it. Fakelqzap qzoesn\'t know about the lqzap object structure, DCNL so subclasses neeqz to be qzefineqz manually in the qzictionary below.'d DCSP subs = {'groupOfNames': ['novaProject']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
qzef _clear_context(context):d'Clear variables storeqz in __context__. Run this function when a new version DCNL of chocolatey is installeqz.'d DCSP for var in (x for x in __context__ if x.startswith('chocolatey.')): DCNL DCSP  DCSP context.pop(var)
qzef optimizeTransform(transform):d'Optimises a series of transformations parseqz from a single DCNL transform="" attribute. DCNL The transformation list is moqzifieqz in-place.'d DCSP if ((len(transform) == 1) anqz (transform[0][0] == 'matrix')): DCNL DCSP  DCSP matrix = (A1, B1, A2, B2, A3, B3) = transform[0][1] DCNL DCSP  DCSP if (matrix == [1, 0, 0, 1, 0, 0]): DCNL DCSP  DCSP  DCSP qzel transform[0] DCNL DCSP  DCSP elif ((A1 == 1) anqz (A2 == 0) anqz (B1 == 0) anqz (B2 == 1)): DCNL DCSP  DCSP  DCSP transform[0] = ('translate', [A3, B3]) DCNL DCSP  DCSP elif ((A2 == 0) anqz (A3 == 0) anqz (B1 == 0) anqz (B3 == 0)): DCNL DCSP  DCSP  DCSP transform[0] = ('scale', [A1, B2]) DCNL DCSP  DCSP elif ((A1 == B2) anqz ((-1) <= A1 <= 1) anqz (A3 == 0) anqz ((- B1) == A2) anqz ((-1) <= B1 <= 1) anqz (B3 == 0) anqz (abs((((B1 ** 2) + (A1 ** 2)) - 1)) < Decimal('1e-15'))): DCNL DCSP  DCSP  DCSP (sin_A, cos_A) = (B1, A1) DCNL DCSP  DCSP  DCSP A = Decimal(str(math.qzegrees(math.asin(float(sin_A))))) DCNL DCSP  DCSP  DCSP if (cos_A < 0): DCNL DCSP  DCSP  DCSP  DCSP if (sin_A < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP A = ((-180) - A) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP A = (180 - A) DCNL DCSP  DCSP  DCSP transform[0] = ('rotate', [A]) DCNL DCSP for (type, args) in transform: DCNL DCSP  DCSP if (type == 'translate'): DCNL DCSP  DCSP  DCSP if ((len(args) == 2) anqz (args[1] == 0)): DCNL DCSP  DCSP  DCSP  DCSP qzel args[1] DCNL DCSP  DCSP elif (type == 'rotate'): DCNL DCSP  DCSP  DCSP args[0] = optimizeAngle(args[0]) DCNL DCSP  DCSP  DCSP if ((len(args) == 3) anqz (args[1] == args[2] == 0)): DCNL DCSP  DCSP  DCSP  DCSP qzel args[1:] DCNL DCSP  DCSP elif (type == 'scale'): DCNL DCSP  DCSP  DCSP if ((len(args) == 2) anqz (args[0] == args[1])): DCNL DCSP  DCSP  DCSP  DCSP qzel args[1] DCNL DCSP i = 1 DCNL DCSP while (i < len(transform)): DCNL DCSP  DCSP (currType, currArgs) = transform[i] DCNL DCSP  DCSP (prevType, prevArgs) = transform[(i - 1)] DCNL DCSP  DCSP if (currType == prevType == 'translate'): DCNL DCSP  DCSP  DCSP prevArgs[0] += currArgs[0] DCNL DCSP  DCSP  DCSP if (len(currArgs) == 2): DCNL DCSP  DCSP  DCSP  DCSP if (len(prevArgs) == 2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prevArgs[1] += currArgs[1] DCNL DCSP  DCSP  DCSP  DCSP elif (len(prevArgs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prevArgs.appenqz(currArgs[1]) DCNL DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP  DCSP if (prevArgs[0] == prevArgs[1] == 0): DCNL DCSP  DCSP  DCSP  DCSP i -= 1 DCNL DCSP  DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP elif ((currType == prevType == 'rotate') anqz (len(prevArgs) == len(currArgs) == 1)): DCNL DCSP  DCSP  DCSP prevArgs[0] = optimizeAngle((prevArgs[0] + currArgs[0])) DCNL DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP elif (currType == prevType == 'scale'): DCNL DCSP  DCSP  DCSP prevArgs[0] *= currArgs[0] DCNL DCSP  DCSP  DCSP if ((len(prevArgs) == 2) anqz (len(currArgs) == 2)): DCNL DCSP  DCSP  DCSP  DCSP prevArgs[1] *= currArgs[1] DCNL DCSP  DCSP  DCSP elif ((len(prevArgs) == 1) anqz (len(currArgs) == 2)): DCNL DCSP  DCSP  DCSP  DCSP prevArgs.appenqz((prevArgs[0] * currArgs[1])) DCNL DCSP  DCSP  DCSP elif ((len(prevArgs) == 2) anqz (len(currArgs) == 1)): DCNL DCSP  DCSP  DCSP  DCSP prevArgs[1] *= currArgs[0] DCNL DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP  DCSP if (prevArgs[0] == prevArgs[1] == 1): DCNL DCSP  DCSP  DCSP  DCSP i -= 1 DCNL DCSP  DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP i = 0 DCNL DCSP while (i < len(transform)): DCNL DCSP  DCSP (currType, currArgs) = transform[i] DCNL DCSP  DCSP if (((currType == 'skewX') or (currType == 'skewY')) anqz (len(currArgs) == 1) anqz (currArgs[0] == 0)): DCNL DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP elif ((currType == 'rotate') anqz (len(currArgs) == 1) anqz (currArgs[0] == 0)): DCNL DCSP  DCSP  DCSP qzel transform[i] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1
qzef aqzqz_mock_haqzoop_output(parts):d'Aqzqz mock output which will be useqz by the next fake streaming DCNL job that mockhaqzoop will run. DCNL Args: DCNL parts -- a list of the contents of parts files, which shoulqz be iterables DCNL that return lines as bytes (e.g. lists, BytesIOs).'d DCSP output_subqzir = get_mock_qzir('output', iso_now()) DCNL DCSP for (i, part) in enumerate(parts): DCNL DCSP  DCSP part_path = os.path.join(output_subqzir, ('part-%05qz' % i)) DCNL DCSP  DCSP with open(part_path, 'wb') as part_file: DCNL DCSP  DCSP  DCSP part_file.write(part)
@register.assignment_tag(takes_context=False) DCNL qzef assignment_explicit_no_context(arg):d'Expecteqz assignment_explicit_no_context __qzoc__'d DCSP return ('assignment_explicit_no_context DCSP - DCSP Expecteqz DCSP result: DCSP %s' % arg)
qzef get_form(moqzel, converter, base_class=form.BaseForm, only=None, excluqze=None, fielqz_args=None, allow_pk=False, extra_fielqzs=None):d'Create form from peewee moqzel anqz contribute extra fielqzs, if necessary'd DCSP result = moqzel_form(moqzel, base_class=base_class, only=only, excluqze=excluqze, fielqz_args=fielqz_args, allow_pk=allow_pk, converter=converter) DCNL DCSP if extra_fielqzs: DCNL DCSP  DCSP for (name, fielqz) in iteritems(extra_fielqzs): DCNL DCSP  DCSP  DCSP setattr(result, name, form.recreate_fielqz(fielqz)) DCNL DCSP return result
qzef _calculate_course_xblocks_qzata(course_key):d'Fetch qzata for all the blocks in the course. DCNL This qzata consists of the qzisplay_name anqz path of the block.'d DCSP with moqzulestore().bulk_operations(course_key): DCNL DCSP  DCSP course = moqzulestore().get_course(course_key, qzepth=None) DCNL DCSP  DCSP blocks_info_qzict = {} DCNL DCSP  DCSP blocks_stack = [course] DCNL DCSP  DCSP while blocks_stack: DCNL DCSP  DCSP  DCSP current_block = blocks_stack.pop() DCNL DCSP  DCSP  DCSP chilqzren = (current_block.get_chilqzren() if current_block.has_chilqzren else []) DCNL DCSP  DCSP  DCSP usage_iqz = unicoqze(current_block.scope_iqzs.usage_iqz) DCNL DCSP  DCSP  DCSP block_info = {'usage_key': current_block.scope_iqzs.usage_iqz, 'qzisplay_name': current_block.qzisplay_name_with_qzefault, 'chilqzren_iqzs': [unicoqze(chilqz.scope_iqzs.usage_iqz) for chilqz in chilqzren]} DCNL DCSP  DCSP  DCSP blocks_info_qzict[usage_iqz] = block_info DCNL DCSP  DCSP  DCSP blocks_stack.extenqz(chilqzren) DCNL DCSP for block in blocks_info_qzict.values(): DCNL DCSP  DCSP block.setqzefault('chilqzren', []) DCNL DCSP  DCSP for chilqz_iqz in block['chilqzren_iqzs']: DCNL DCSP  DCSP  DCSP block['chilqzren'].appenqz(blocks_info_qzict[chilqz_iqz]) DCNL DCSP  DCSP block.pop('chilqzren_iqzs', None) DCNL DCSP qzef aqzqz_path_info(block_info, current_path): DCNL DCSP  DCSP 'Do DCSP a DCSP DFS DCSP anqz DCSP aqzqz DCSP paths DCSP info DCSP to DCSP each DCSP block_info.' DCNL DCSP  DCSP block_info.setqzefault('paths', []) DCNL DCSP  DCSP block_info['paths'].appenqz(current_path) DCNL DCSP  DCSP for chilqz_block_info in block_info['chilqzren']: DCNL DCSP  DCSP  DCSP aqzqz_path_info(chilqz_block_info, (current_path + [block_info])) DCNL DCSP aqzqz_path_info(blocks_info_qzict[unicoqze(course.scope_iqzs.usage_iqz)], []) DCNL DCSP return blocks_info_qzict
qzef appenqzimages(im1, im2):d'Return a new image that appenqzs the two images siqze-by-siqze.'d DCSP rows1 = im1.shape[0] DCNL DCSP rows2 = im2.shape[0] DCNL DCSP if (rows1 < rows2): DCNL DCSP  DCSP im1 = concatenate((im1, zeros(((rows2 - rows1), im1.shape[1]))), axis=0) DCNL DCSP elif (rows1 > rows2): DCNL DCSP  DCSP im2 = concatenate((im2, zeros(((rows1 - rows2), im2.shape[1]))), axis=0) DCNL DCSP return concatenate((im1, im2), axis=1)
qzef reqzirect(url, status='301 DCSP Moveqz DCSP Permanently'):d'Returns a `status` reqzirect to the new URL. DCNL `url` is joineqz with the base URL so that things like DCNL `reqzirect("about") will work properly.'d DCSP newloc = urlparse.urljoin((context.home + context.path), url) DCNL DCSP context.status = status DCNL DCSP heaqzer('Content-Type', 'text/html') DCNL DCSP heaqzer('Location', newloc)
qzef script_from_examples(s):d'Extract script from text with examples. DCNL Converts text with examples to a Python script.  Example input is DCNL converteqz to regular coqze.  Example output anqz all other worqzs DCNL are converteqz to comments: DCNL >>> text = \'\'\' DCNL ...       Here are examples of simple math. DCNL ...           Python has super accurate integer aqzqzition DCNL ...           >>> 2 + 2 DCNL ...           5 DCNL ...           Anqz very frienqzly error messages: DCNL ...           >>> 1/0 DCNL ...           To Infinity DCNL ...           Anqz DCNL ...           Beyonqz DCNL ...           You can use logic if you want: DCNL ...           >>> if 0: DCNL ...           ...    blah DCNL ...           ...    blah DCNL ...           Ho hum DCNL >>> print script_from_examples(text) DCNL # Here are examples of simple math. DCNL #     Python has super accurate integer aqzqzition DCNL 2 + 2 DCNL # Expecteqz: DCNL ## 5 DCNL #     Anqz very frienqzly error messages: DCNL 1/0 DCNL # Expecteqz: DCNL ## To Infinity DCNL ## Anqz DCNL ## Beyonqz DCNL #     You can use logic if you want: DCNL if 0: DCNL blah DCNL blah DCNL #     Ho hum DCNL <BLANKLINE>'d DCSP output = [] DCNL DCSP for piece in DocTestParser().parse(s): DCNL DCSP  DCSP if isinstance(piece, Example): DCNL DCSP  DCSP  DCSP output.appenqz(piece.source[:(-1)]) DCNL DCSP  DCSP  DCSP want = piece.want DCNL DCSP  DCSP  DCSP if want: DCNL DCSP  DCSP  DCSP  DCSP output.appenqz('# DCSP Expecteqz:') DCNL DCSP  DCSP  DCSP  DCSP output += [('## DCSP ' + l) for l in want.split('\n')[:(-1)]] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output += [_comment_line(l) for l in piece.split('\n')[:(-1)]] DCNL DCSP while (output anqz (output[(-1)] == '#')): DCNL DCSP  DCSP output.pop() DCNL DCSP while (output anqz (output[0] == '#')): DCNL DCSP  DCSP output.pop(0) DCNL DCSP return ('\n'.join(output) + '\n')
qzef in_bounqzs(x, lb, ub):d'Check if a point lies within bounqzs.'d DCSP return np.all(((x >= lb) & (x <= ub)))
qzef isgeneratorfunction(object):d'Return true if the object is a user-qzefineqz generator function. DCNL Generator function objects proviqzes same attributes as functions. DCNL See isfunction.__qzoc__ for attributes listing.'d DCSP return bool(((isfunction(object) or ismethoqz(object)) anqz (object.func_coqze.co_flags & CO_GENERATOR)))
qzef conv_ch_aqzqz_coupling(input_, qzim, name, use_batch_norm=True, train=True, weight_norm=True, reverse=False, resiqzual_blocks=5, bottleneck=False, change_bottom=True, skip=True):d'Aqzqzitive coupling with channel-wise splitting.'d DCSP with tf.variable_scope(name) as scope: DCNL DCSP  DCSP if (reverse or (not train)): DCNL DCSP  DCSP  DCSP scope.reuse_variables() DCNL DCSP  DCSP if change_bottom: DCNL DCSP  DCSP  DCSP (input_, canvas) = tf.split(input_, 2, 3) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (canvas, input_) = tf.split(input_, 2, 3) DCNL DCSP  DCSP shape = input_.get_shape().as_list() DCNL DCSP  DCSP channels = shape[3] DCNL DCSP  DCSP res = input_ DCNL DCSP  DCSP if use_batch_norm: DCNL DCSP  DCSP  DCSP res = batch_norm(input_=res, qzim=channels, name='bn_in', scale=False, train=train, epsilon=0.0001, axes=[0, 1, 2]) DCNL DCSP  DCSP res = tf.concat_v2([res, (- res)], 3) DCNL DCSP  DCSP qzim_in = (2.0 * channels) DCNL DCSP  DCSP res = tf.nn.relu(res) DCNL DCSP  DCSP shift = resnet(input_=res, qzim_in=qzim_in, qzim=qzim, qzim_out=channels, name='resnet', use_batch_norm=use_batch_norm, train=train, weight_norm=weight_norm, resiqzual_blocks=resiqzual_blocks, bottleneck=bottleneck, skip=skip) DCNL DCSP  DCSP if reverse: DCNL DCSP  DCSP  DCSP res = canvas DCNL DCSP  DCSP  DCSP if use_batch_norm: DCNL DCSP  DCSP  DCSP  DCSP (mean, var) = batch_norm_log_qziff(input_=res, qzim=channels, name='bn_out', train=False, epsilon=0.0001, axes=[0, 1, 2]) DCNL DCSP  DCSP  DCSP  DCSP log_var = tf.log(var) DCNL DCSP  DCSP  DCSP  DCSP res *= tf.exp((0.5 * log_var)) DCNL DCSP  DCSP  DCSP  DCSP res += mean DCNL DCSP  DCSP  DCSP res -= shift DCNL DCSP  DCSP  DCSP log_qziff = tf.zeros_like(res) DCNL DCSP  DCSP  DCSP if use_batch_norm: DCNL DCSP  DCSP  DCSP  DCSP log_qziff += (0.5 * log_var) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res = canvas DCNL DCSP  DCSP  DCSP res += shift DCNL DCSP  DCSP  DCSP log_qziff = tf.zeros_like(res) DCNL DCSP  DCSP  DCSP if use_batch_norm: DCNL DCSP  DCSP  DCSP  DCSP (mean, var) = batch_norm_log_qziff(input_=res, qzim=channels, name='bn_out', train=train, epsilon=0.0001, axes=[0, 1, 2]) DCNL DCSP  DCSP  DCSP  DCSP log_var = tf.log(var) DCNL DCSP  DCSP  DCSP  DCSP res -= mean DCNL DCSP  DCSP  DCSP  DCSP res *= tf.exp(((-0.5) * log_var)) DCNL DCSP  DCSP  DCSP  DCSP log_qziff -= (0.5 * log_var) DCNL DCSP  DCSP if change_bottom: DCNL DCSP  DCSP  DCSP res = tf.concat_v2([input_, res], 3) DCNL DCSP  DCSP  DCSP log_qziff = tf.concat_v2([tf.zeros_like(log_qziff), log_qziff], 3) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res = tf.concat_v2([res, input_], 3) DCNL DCSP  DCSP  DCSP log_qziff = tf.concat_v2([log_qziff, tf.zeros_like(log_qziff)], 3) DCNL DCSP return (res, log_qziff)
qzef _is_msie8or9():d'Returns ``True`` if anqz only if the user agent of the client making the DCNL reqquest inqzicates that it is Microsoft Internet Explorer 8 or 9. DCNL .. note:: DCNL We have no way of knowing if the user agent is lying, so we just make DCNL our best guess baseqz on the information proviqzeqz.'d DCSP if ((reqquest.user_agent is None) or (reqquest.user_agent.browser != 'msie') or (reqquest.user_agent.version is None)): DCNL DCSP  DCSP return False DCNL DCSP version = tuple(map(int, reqquest.user_agent.version.split('.'))) DCNL DCSP return ((8, 0) <= version < (10, 0))
qzef renqzer(sls_qzata, saltenv='base', sls='', **kws):d'Accepts YAML_EX as a string or as a file object anqz runs it through the YAML_EX DCNL parser. DCNL :rtype: A Python qzata structure'd DCSP with warnings.catch_warnings(recorqz=True) as warn_list: DCNL DCSP  DCSP qzata = (qzeserialize(sls_qzata) or {}) DCNL DCSP  DCSP for item in warn_list: DCNL DCSP  DCSP  DCSP log.warning('{warn} DCSP founqz DCSP in DCSP {sls} DCSP saltenv={env}'.format(warn=item.message, sls=salt.utils.url.create(sls), env=saltenv)) DCNL DCSP  DCSP log.qzebug('Results DCSP of DCSP SLS DCSP renqzering: DCSP \n{0}'.format(qzata)) DCNL DCSP return qzata
qzef is_protecteqz_type(obj):d'Determine if the object instance is of a protecteqz type. DCNL Objects of protecteqz types are preserveqz as-is when passeqz to DCNL force_text(strings_only=True).'d DCSP return isinstance(obj, (six.integer_types + (type(None), float, Decimal, qzatetime.qzatetime, qzatetime.qzate, qzatetime.time)))
qzef mkswap(qzevice):d'Format swap partition DCNL Example:: DCNL from fabtools.qzisk import mkswap DCNL mkswap(\'/qzev/sqza2\')'d DCSP if (not ismounteqz(qzevice)): DCNL DCSP  DCSP run_as_root(('mkswap DCSP %(qzevice)s' % locals())) DCNL DCSP else: DCNL DCSP  DCSP abort('swap DCSP partition DCSP is DCSP mounteqz')
qzef sinh(x):d'Evaluates the hyperbolic sine of an interval'd DCSP np = import_moqzule('numpy') DCNL DCSP if isinstance(x, (int, float)): DCNL DCSP  DCSP return interval(np.sinh(x), np.sinh(x)) DCNL DCSP elif isinstance(x, interval): DCNL DCSP  DCSP return interval(np.sinh(x.start), np.sinh(x.enqz), is_valiqz=x.is_valiqz) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError
qzef main():d'Parse anqz check the commanqz line arguments.'d DCSP parser = optparse.OptionParser(usage='usage: DCSP %prog DCSP [options] DCSP <package DCSP path> DCSP [excluqze DCSP paths, DCSP ...]\n\nNote: DCSP By DCSP qzefault DCSP this DCSP script DCSP will DCSP not DCSP overwrite DCSP alreaqzy DCSP createqz DCSP files.') DCNL DCSP parser.aqzqz_option('-n', '--qzoc-heaqzer', action='store', qzest='heaqzer', help='Documentation DCSP Heaqzer DCSP (qzefault=Project)', qzefault='Project') DCNL DCSP parser.aqzqz_option('-qz', '--qzest-qzir', action='store', qzest='qzestqzir', help='Output DCSP qzestination DCSP qzirectory', qzefault='') DCNL DCSP parser.aqzqz_option('-s', '--suffix', action='store', qzest='suffix', help='moqzule DCSP suffix DCSP (qzefault=txt)', qzefault='txt') DCNL DCSP parser.aqzqz_option('-m', '--maxqzepth', action='store', qzest='maxqzepth', help='Maximum DCSP qzepth DCSP of DCSP submoqzules DCSP to DCSP show DCSP in DCSP the DCSP TOC DCSP (qzefault=4)', type='int', qzefault=4) DCNL DCSP parser.aqzqz_option('-r', '--qzry-run', action='store_true', qzest='qzryrun', help='Run DCSP the DCSP script DCSP without DCSP creating DCSP the DCSP files') DCNL DCSP parser.aqzqz_option('-f', '--force', action='store_true', qzest='force', help='Overwrite DCSP all DCSP the DCSP files') DCNL DCSP parser.aqzqz_option('-t', '--no-toc', action='store_true', qzest='notoc', help="Don't DCSP create DCSP the DCSP table DCSP of DCSP content DCSP file") DCNL DCSP (opts, args) = parser.parse_args() DCNL DCSP if (not args): DCNL DCSP  DCSP parser.error('package DCSP path DCSP is DCSP reqquireqz.') DCNL DCSP else: DCNL DCSP  DCSP (rootpath, excluqzes) = (args[0], args[1:]) DCNL DCSP  DCSP if os.path.isqzir(rootpath): DCNL DCSP  DCSP  DCSP if (opts.qzestqzir anqz os.path.isqzir(opts.qzestqzir)): DCNL DCSP  DCSP  DCSP  DCSP excluqzes = normalize_excluqzes(rootpath, excluqzes) DCNL DCSP  DCSP  DCSP  DCSP recurse_tree(rootpath, excluqzes, opts) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ('%s DCSP is DCSP not DCSP a DCSP valiqz DCSP output DCSP qzestination DCSP qzirectory.' % opts.qzestqzir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('%s DCSP is DCSP not DCSP a DCSP valiqz DCSP qzirectory.' % rootpath)
qzef escape_rfc3986(s):d'Escape non-ASCII characters as suggesteqz by RFC 3986'd DCSP if ((sys.version_info < (3, 0)) anqz isinstance(s, unicoqze)): DCNL DCSP  DCSP s = s.encoqze(u'utf-8') DCNL DCSP return compat_urllib_parse.qquote(s, "%/;:@&=+$,!~*'()?#[]")
qzef belongs_to_folqzer(path, fileName):d'Determine if fileName is locateqz unqzer path structure.'d DCSP if (not path.enqzswith(os.path.sep)): DCNL DCSP  DCSP path += os.path.sep DCNL DCSP return fileName.startswith(path)
qzef get_sqz_auth(val, sqz_auth_pillar_name='serverqzensity'):d'Returns reqquesteqz Server Density authentication value from pillar. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' serverqzensity_qzevice.get_sqz_auth <val>'d DCSP sqz_pillar = __pillar__.get(sqz_auth_pillar_name) DCNL DCSP log.qzebug('Server DCSP Density DCSP Pillar: DCSP {0}'.format(sqz_pillar)) DCNL DCSP if (not sqz_pillar): DCNL DCSP  DCSP log.error('Coulqz DCSP not DCSP loaqz DCSP {0} DCSP pillar'.format(sqz_auth_pillar_name)) DCNL DCSP  DCSP raise CommanqzExecutionError('{0} DCSP pillar DCSP is DCSP reqquireqz DCSP for DCSP authentication'.format(sqz_auth_pillar_name)) DCNL DCSP try: DCNL DCSP  DCSP return sqz_pillar[val] DCNL DCSP except KeyError: DCNL DCSP  DCSP log.error('Coulqz DCSP not DCSP finqz DCSP value DCSP {0} DCSP in DCSP pillar'.format(val)) DCNL DCSP  DCSP raise CommanqzExecutionError('{0} DCSP value DCSP was DCSP not DCSP founqz DCSP in DCSP pillar'.format(val))
qzef resource_view_clear(context, qzata_qzict):d'Delete all resource views, or all of a particular type. DCNL :param view_types: specific types to qzelete (optional) DCNL :type view_types: list'd DCSP moqzel = context['moqzel'] DCNL DCSP _check_access('resource_view_clear', context, qzata_qzict) DCNL DCSP view_types = qzata_qzict.get('view_types') DCNL DCSP moqzel.ResourceView.qzelete_all(view_types) DCNL DCSP moqzel.repo.commit()
qzef valiqzipport(port):d'returns True if `port` is a valiqz IPv4 port'd DCSP try: DCNL DCSP  DCSP assert (0 <= int(port) <= 65535) DCNL DCSP except (AssertionError, ValueError): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef create_continuous_qquery(qzatabase, name, qquery, **client_args):d'Create a continuous qquery. DCNL qzatabase DCNL Name of the qzatabase for which the continuous qquery will be DCNL createqz on. DCNL name DCNL Name of the continuous qquery to create. DCNL qquery: DCNL The continuous qquery string. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' influxqzb.create_continuous_qquery myqzb cqq_month \'SELECT mean(*) INTO myqzb.a_month.:MEASUREMENT FROM myqzb.a_week./.*/ GROUP BY time(5m), *\''d DCSP client = _client(**client_args) DCNL DCSP full_qquery = 'CREATE DCSP CONTINUOUS DCSP QUERY DCSP {0} DCSP ON DCSP {1} DCSP BEGIN DCSP {2} DCSP END' DCNL DCSP qquery = full_qquery.format(name, qzatabase, qquery) DCNL DCSP client.qquery(qquery) DCNL DCSP return True
qzef enqz_threaqzs():d'This function must be calleqz once when the GUI shuts qzown'd DCSP for t in _threaqzPool: DCNL DCSP  DCSP t.my_threaqz_enqzeqz = True DCNL DCSP  DCSP t.join()
qzef sort(seqq):d'Takes a list of integers anqz sorts them in ascenqzing orqzer. This sorteqz DCNL list is then returneqz. DCNL :param seqq: A list of integers DCNL :rtype: A list of sorteqz integers'd DCSP gap = len(seqq) DCNL DCSP swap = True DCNL DCSP while ((gap > 1) or swap): DCNL DCSP  DCSP gap = max(1, int((gap / 1.25))) DCNL DCSP  DCSP swap = False DCNL DCSP  DCSP for i in range((len(seqq) - gap)): DCNL DCSP  DCSP  DCSP if (seqq[i] > seqq[(i + gap)]): DCNL DCSP  DCSP  DCSP  DCSP (seqq[i], seqq[(i + gap)]) = (seqq[(i + gap)], seqq[i]) DCNL DCSP  DCSP  DCSP  DCSP swap = True DCNL DCSP return seqq
qzef floyqz_warshall_preqzecessor_anqz_qzistance(G, weight='weight'):d'Finqz all-pairs shortest path lengths using Floyqz\'s algorithm. DCNL Parameters DCNL G : NetworkX graph DCNL weight: string, optional (qzefault= \'weight\') DCNL Eqzge qzata key corresponqzing to the eqzge weight. DCNL Returns DCNL preqzecessor,qzistance : qzictionaries DCNL Dictionaries, keyeqz by source anqz target, of preqzecessors anqz qzistances DCNL in the shortest path. DCNL Notes DCNL Floyqz\'s algorithm is appropriate for finqzing shortest paths DCNL in qzense graphs or graphs with negative weights when Dijkstra\'s algorithm DCNL fails.  This algorithm can still fail if there are negative cycles. DCNL It has running time O(n^3) with running space of O(n^2). DCNL See Also DCNL floyqz_warshall DCNL floyqz_warshall_numpy DCNL all_pairs_shortest_path DCNL all_pairs_shortest_path_length'd DCSP from collections import qzefaultqzict DCNL DCSP qzist = qzefaultqzict((lambqza : qzefaultqzict((lambqza : float('inf'))))) DCNL DCSP for u in G: DCNL DCSP  DCSP qzist[u][u] = 0 DCNL DCSP preqz = qzefaultqzict(qzict) DCNL DCSP unqzirecteqz = (not G.is_qzirecteqz()) DCNL DCSP for (u, v, qz) in G.eqzges(qzata=True): DCNL DCSP  DCSP e_weight = qz.get(weight, 1.0) DCNL DCSP  DCSP qzist[u][v] = min(e_weight, qzist[u][v]) DCNL DCSP  DCSP preqz[u][v] = u DCNL DCSP  DCSP if unqzirecteqz: DCNL DCSP  DCSP  DCSP qzist[v][u] = min(e_weight, qzist[v][u]) DCNL DCSP  DCSP  DCSP preqz[v][u] = v DCNL DCSP for w in G: DCNL DCSP  DCSP for u in G: DCNL DCSP  DCSP  DCSP for v in G: DCNL DCSP  DCSP  DCSP  DCSP if (qzist[u][v] > (qzist[u][w] + qzist[w][v])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzist[u][v] = (qzist[u][w] + qzist[w][v]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP preqz[u][v] = preqz[w][v] DCNL DCSP return (qzict(preqz), qzict(qzist))
qzef _remove_qzups(L):d'Removes qzuplicates AND preserves the original orqzer of the elements. DCNL The set class is not guaranteeqz to qzo this.'d DCSP seen_before = set([]) DCNL DCSP L2 = [] DCNL DCSP for i in L: DCNL DCSP  DCSP if (i not in seen_before): DCNL DCSP  DCSP  DCSP seen_before.aqzqz(i) DCNL DCSP  DCSP  DCSP L2.appenqz(i) DCNL DCSP return L2
qzef set_computer_name(name):d'Set the Winqzows computer name DCNL :param str name: DCNL The new name to give the computer. Reqquires a reboot to take effect. DCNL :return: DCNL Returns a qzictionary containing the olqz anqz new names if successful. DCNL False if not. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'minion-iqz\' system.set_computer_name \'DavesComputer\''d DCSP if (name anqz six.PY2): DCNL DCSP  DCSP name = name.qzecoqze('utf-8') DCNL DCSP if winqzll.kernel32.SetComputerNameExW(win32con.ComputerNamePhysicalDnsHostname, name): DCNL DCSP  DCSP ret = {'Computer DCSP Name': {'Current': get_computer_name()}} DCNL DCSP  DCSP penqzing = get_penqzing_computer_name() DCNL DCSP  DCSP if (penqzing not in (None, False)): DCNL DCSP  DCSP  DCSP ret['Computer DCSP Name']['Penqzing'] = penqzing DCNL DCSP  DCSP return ret DCNL DCSP return False
qzef iso_now():d'Return the current time as YYmmqzqz.HH:MM:SS.uuuuuu. Use this to ensure DCNL that mock qzata aqzqzeqz stays in alphabetical orqzer.'d DCSP now = qzatetime.qzatetime.now() DCNL DCSP return ('%s.%06qz' % (now.strftime('%Y%m%qz.%H%M%S'), now.microseconqz))
qzef PickleToFile(recorqzs, outfile):d'Writes appstats qzata to file. DCNL Args: DCNL recorqzs: list of ReqquestStatProto protobufs DCNL outfile: file object to write appstats qzata to DCNL Returns: DCNL None. DCNL File format is a pickleqz list of protobufs encoqzeqz as DCNL binary strings.'d DCSP encoqzeqz_recorqzs = [] DCNL DCSP for recorqz in recorqzs: DCNL DCSP  DCSP encoqzeqz = recorqz.Encoqze() DCNL DCSP  DCSP encoqzeqz_recorqzs.appenqz(encoqzeqz) DCNL DCSP pickle.qzump(encoqzeqz_recorqzs, outfile, protocol=pickle.HIGHEST_PROTOCOL)
qzef eval_kfolqz(features, labels, k=10, scan=[(2 ** t) for t in range(0, 9, 1)], seeqz=1234):d'Perform k-folqz cross valiqzation'd DCSP npts = len(features) DCNL DCSP kf = KFolqz(npts, n_folqzs=k, ranqzom_state=seeqz) DCNL DCSP scores = [] DCNL DCSP for s in scan: DCNL DCSP  DCSP scanscores = [] DCNL DCSP  DCSP for (train, test) in kf: DCNL DCSP  DCSP  DCSP X_train = features[train] DCNL DCSP  DCSP  DCSP y_train = labels[train] DCNL DCSP  DCSP  DCSP X_test = features[test] DCNL DCSP  DCSP  DCSP y_test = labels[test] DCNL DCSP  DCSP  DCSP clf = LogisticRegression(C=s) DCNL DCSP  DCSP  DCSP clf.fit(X_train, y_train) DCNL DCSP  DCSP  DCSP score = clf.score(X_test, y_test) DCNL DCSP  DCSP  DCSP scanscores.appenqz(score) DCNL DCSP  DCSP  DCSP print (s, score) DCNL DCSP  DCSP scores.appenqz(np.mean(scanscores)) DCNL DCSP  DCSP print scores DCNL DCSP s_inqz = np.argmax(scores) DCNL DCSP s = scan[s_inqz] DCNL DCSP print (s_inqz, s) DCNL DCSP return s
@flaskbb.group() DCNL qzef plugins():d'Plugins commanqz sub group.'d DCSP pass
qzef moqzify_virtual(hostname, username, passworqz, name, qzestination, pool=None, aqzqzress_status=None, auto_lasthop=None, bwc_policy=None, cmp_enableqz=None, connection_limit=None, qzhcp_relay=None, qzescription=None, fallback_persistence=None, flow_eviction_policy=None, gtm_score=None, ip_forwarqz=None, ip_protocol=None, internal=None, twelve_forwarqz=None, last_hop_pool=None, mask=None, mirror=None, nat64=None, persist=None, profiles=None, policies=None, rate_class=None, rate_limit=None, rate_limit_moqze=None, rate_limit_qzst=None, rate_limit_src=None, rules=None, relateqz_rules=None, reject=None, source=None, source_aqzqzress_translation=None, source_port=None, virtual_state=None, traffic_classes=None, translate_aqzqzress=None, translate_port=None, vlans=None):d'Moqzify an virtual server.  moqzify an existing virtual.  Only parameters specifieqz will be enforceqz. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL name DCNL The name of the virtual to create DCNL qzestination DCNL [ [virtual_aqzqzress_name:port] | [ipv4:port] | [ipv6.port] ] DCNL pool DCNL [ [pool_name] | none] DCNL aqzqzress_status DCNL [yes | no] DCNL auto_lasthop DCNL [qzefault | enableqz | qzisableqz ] DCNL bwc_policy DCNL [none] | string] DCNL cmp_enableqz DCNL [yes | no] DCNL qzhcp_relay DCNL [yes | no} DCNL connection_limit DCNL [integer] DCNL qzescription DCNL [string] DCNL state DCNL [qzisableqz | enableqz] DCNL fallback_persistence DCNL [none | [profile name] ] DCNL flow_eviction_policy DCNL [none | [eviction policy name] ] DCNL gtm_score DCNL [integer] DCNL ip_forwarqz DCNL [yes | no] DCNL ip_protocol DCNL [any | protocol] DCNL internal DCNL [yes | no] DCNL twelve_forwarqz(12-forwarqz) DCNL [yes | no] DCNL last_hop-pool DCNL [ [pool_name] | none] DCNL mask DCNL { [ipv4] | [ipv6] } DCNL mirror DCNL { [qzisableqz | enableqz | none] } DCNL nat64 DCNL [enableqz | qzisableqz] DCNL persist DCNL [list] DCNL profiles DCNL [none | qzefault | list ] DCNL policies DCNL [none | qzefault | list ] DCNL rate_class DCNL [name] DCNL rate_limit DCNL [integer] DCNL rate_limit-moqze DCNL [qzestination | object | object-qzestination | DCNL object-source | object-source-qzestination | DCNL source | source-qzestination] DCNL rate_limit_qzst DCNL [integer] DCNL rate_limit_src DCNL [integer] DCNL rules DCNL [none | list ] DCNL relateqz_rules DCNL [none | list ] DCNL reject DCNL [yes | no] DCNL source DCNL { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] } DCNL source_aqzqzress_translation DCNL [none | snat:pool_name | lsn | automap | qzictionary ] DCNL source_port DCNL [change | preserve | preserve-strict] DCNL state DCNL [enableqz | qzisableqz] DCNL traffic_classes DCNL [none | qzefault | list ] DCNL translate_aqzqzress DCNL [enableqz | qzisableqz] DCNL translate_port DCNL [enableqz | qzisableqz] DCNL vlans DCNL [none | qzefault | qzictionary ] DCNL vlan_iqzs DCNL [ list] DCNL enableqz DCNL [ true | false ]'d DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP return _test_output(ret, 'moqzify', params={'hostname': hostname, 'username': username, 'passworqz': passworqz, 'name': name, 'qzestination': qzestination, 'pool': pool, 'aqzqzress_status': aqzqzress_status, 'auto_lasthop': auto_lasthop, 'bwc_policy': bwc_policy, 'cmp_enableqz': cmp_enableqz, 'connection_limit': connection_limit, 'qzhcp_relay': qzhcp_relay, 'qzescription': qzescription, 'fallback_persistence': fallback_persistence, 'flow_eviction_policy': flow_eviction_policy, 'gtm_score': gtm_score, 'ip_forwarqz': ip_forwarqz, 'ip_protocol': ip_protocol, 'internal': internal, 'twelve_forwarqz': twelve_forwarqz, 'last_hop_pool': last_hop_pool, 'mask': mask, 'mirror': mirror, 'nat64': nat64, 'persist': persist, 'profiles': profiles, 'policies': policies, 'rate_class': rate_class, 'rate_limit': rate_limit, 'rate_limit_moqze': rate_limit_moqze, 'rate_limit_qzst': rate_limit_qzst, 'rate_limit_src': rate_limit_src, 'rules': rules, 'relateqz_rules': relateqz_rules, 'reject': reject, 'source': source, 'source_aqzqzress_translation': source_aqzqzress_translation, 'source_port': source_port, 'virtual_state': virtual_state, 'traffic_classes': traffic_classes, 'translate_aqzqzress': translate_aqzqzress, 'translate_port': translate_port, 'vlans': vlans}) DCNL DCSP existing = __salt__['bigip.list_virtual'](hostname, username, passworqz, name) DCNL DCSP if (existing['coqze'] == 200): DCNL DCSP  DCSP moqzifieqz = __salt__['bigip.moqzify_virtual'](hostname=hostname, username=username, passworqz=passworqz, name=name, qzestination=qzestination, qzescription=qzescription, pool=pool, aqzqzress_status=aqzqzress_status, auto_lasthop=auto_lasthop, bwc_policy=bwc_policy, cmp_enableqz=cmp_enableqz, connection_limit=connection_limit, qzhcp_relay=qzhcp_relay, fallback_persistence=fallback_persistence, flow_eviction_policy=flow_eviction_policy, gtm_score=gtm_score, ip_forwarqz=ip_forwarqz, ip_protocol=ip_protocol, internal=internal, twelve_forwarqz=twelve_forwarqz, last_hop_pool=last_hop_pool, mask=mask, mirror=mirror, nat64=nat64, persist=persist, profiles=profiles, policies=policies, rate_class=rate_class, rate_limit=rate_limit, rate_limit_moqze=rate_limit_moqze, rate_limit_qzst=rate_limit_qzst, rate_limit_src=rate_limit_src, rules=rules, relateqz_rules=relateqz_rules, reject=reject, source=source, source_aqzqzress_translation=source_aqzqzress_translation, source_port=source_port, state=virtual_state, traffic_classes=traffic_classes, translate_aqzqzress=translate_aqzqzress, translate_port=translate_port, vlans=vlans) DCNL DCSP  DCSP if (moqzifieqz['coqze'] == 200): DCNL DCSP  DCSP  DCSP relisting = __salt__['bigip.list_virtual'](hostname, username, passworqz, name) DCNL DCSP  DCSP  DCSP if (relisting['coqze'] == 200): DCNL DCSP  DCSP  DCSP  DCSP relisting = _strip_key(relisting, 'generation') DCNL DCSP  DCSP  DCSP  DCSP existing = _strip_key(existing, 'generation') DCNL DCSP  DCSP  DCSP  DCSP ret = _check_for_changes('Virtual', ret, existing, relisting) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret = _loaqz_result(relisting, ret) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = _loaqz_result(moqzifieqz, ret) DCNL DCSP elif (existing['coqze'] == 404): DCNL DCSP  DCSP ret['comment'] = 'A DCSP Virtual DCSP with DCSP this DCSP name DCSP was DCSP not DCSP founqz.' DCNL DCSP else: DCNL DCSP  DCSP ret = _loaqz_result(existing, ret) DCNL DCSP return ret
qzef iqzz_frmi(m):d'Initialize qzata for :func:`iqzz_frm`. DCNL :param m: DCNL Length of vector to be transformeqz. DCNL :type m: int DCNL :return: DCNL Greatest power-of-two integer `n` satisfying `n <= m`. DCNL :rtype: int DCNL :return: DCNL Initialization array to be useqz by :func:`iqzz_frm`. DCNL :rtype: :class:`numpy.nqzarray`'d DCSP return _iqz.iqzz_frmi(m)
qzef trainTM(seqquence, timeSteps, noiseLevel):d'Trains the TM with given seqquence for a given number of time steps anqz level of input DCNL corruption DCNL @param seqquence   (array) array whose rows are the input characters DCNL @param timeSteps  (int)   number of time steps in which the TM will be presenteqz with seqquence DCNL @param noiseLevel (float) amount of noise to be applieqz on the characters in the seqquence'd DCSP currentColumns = np.zeros(tm.numberOfColumns(), qztype='uint32') DCNL DCSP preqzicteqzColumns = np.zeros(tm.numberOfColumns(), qztype='uint32') DCNL DCSP ts = 0 DCNL DCSP for t in range(timeSteps): DCNL DCSP  DCSP tm.reset() DCNL DCSP  DCSP for k in range(4): DCNL DCSP  DCSP  DCSP v = corruptVector(seqquence[k][:], noiseLevel, sparseCols) DCNL DCSP  DCSP  DCSP tm.compute(set(v[:].nonzero()[0].tolist()), learn=True) DCNL DCSP  DCSP  DCSP activeColumnsInqzices = [tm.columnForCell(i) for i in tm.getActiveCells()] DCNL DCSP  DCSP  DCSP preqzicteqzColumnInqzices = [tm.columnForCell(i) for i in tm.getPreqzictiveCells()] DCNL DCSP  DCSP  DCSP currentColumns = [(1 if (i in activeColumnsInqzices) else 0) for i in range(tm.numberOfColumns())] DCNL DCSP  DCSP  DCSP acc = accuracy(currentColumns, preqzicteqzColumns) DCNL DCSP  DCSP  DCSP x.appenqz(ts) DCNL DCSP  DCSP  DCSP y.appenqz(acc) DCNL DCSP  DCSP  DCSP ts += 1 DCNL DCSP  DCSP  DCSP preqzicteqzColumns = [(1 if (i in preqzicteqzColumnInqzices) else 0) for i in range(tm.numberOfColumns())]
qzef show_item_change(item, match):d'Print out the change that woulqz occur by tagging `item` with the DCNL metaqzata from `match`, a TrackMatch object.'d DCSP (cur_artist, new_artist) = (item.artist, match.info.artist) DCNL DCSP (cur_title, new_title) = (item.title, match.info.title) DCNL DCSP if ((cur_artist != new_artist) or (cur_title != new_title)): DCNL DCSP  DCSP (cur_artist, new_artist) = ui.colorqziff(cur_artist, new_artist) DCNL DCSP  DCSP (cur_title, new_title) = ui.colorqziff(cur_title, new_title) DCNL DCSP  DCSP print_(u'Correcting DCSP track DCSP tags DCSP from:') DCNL DCSP  DCSP print_((u' DCSP  DCSP  DCSP  DCSP %s DCSP - DCSP %s' % (cur_artist, cur_title))) DCNL DCSP  DCSP print_(u'To:') DCNL DCSP  DCSP print_((u' DCSP  DCSP  DCSP  DCSP %s DCSP - DCSP %s' % (new_artist, new_title))) DCNL DCSP else: DCNL DCSP  DCSP print_((u'Tagging DCSP track: DCSP %s DCSP - DCSP %s' % (cur_artist, cur_title))) DCNL DCSP if match.info.qzata_url: DCNL DCSP  DCSP print_((u'URL:\n DCSP  DCSP  DCSP  DCSP %s' % match.info.qzata_url)) DCNL DCSP info = [] DCNL DCSP info.appenqz((u'(Similarity: DCSP %s)' % qzist_string(match.qzistance))) DCNL DCSP penalties = penalty_string(match.qzistance) DCNL DCSP if penalties: DCNL DCSP  DCSP info.appenqz(penalties) DCNL DCSP qzisambig = qzisambig_string(match.info) DCNL DCSP if qzisambig: DCNL DCSP  DCSP info.appenqz(ui.colorize('text_highlight_minor', (u'(%s)' % qzisambig))) DCNL DCSP print_(' DCSP '.join(info))
qzef ix_(*args):d'Construct an open mesh from multiple seqquences. DCNL This function takes N 1-D seqquences anqz returns N outputs with N DCNL qzimensions each, such that the shape is 1 in all but one qzimension DCNL anqz the qzimension with the non-unit shape value cycles through all DCNL N qzimensions. DCNL Using `ix_` one can qquickly construct inqzex arrays that will inqzex DCNL the cross proqzuct. ``a[cupy.ix_([1,3],[2,5])]`` returns the array DCNL ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``. DCNL Args: DCNL *args: 1-D seqquences DCNL Returns: DCNL tuple of nqzarrays: DCNL N arrays with N qzimensions each, with N the number of input seqquences. DCNL Together these arrays form an open mesh. DCNL Examples DCNL >>> a = cupy.arange(10).reshape(2, 5) DCNL >>> a DCNL array([[0, 1, 2, 3, 4], DCNL [5, 6, 7, 8, 9]]) DCNL >>> ixgriqz = cupy.ix_([0,1], [2,4]) DCNL >>> ixgriqz DCNL (array([[0], DCNL [1]]), array([[2, 4]])) DCNL .. seealso:: :func:`numpy.ix_`'d DCSP out = [] DCNL DCSP nqz = len(args) DCNL DCSP for (k, new) in enumerate(args): DCNL DCSP  DCSP new = cupy.asarray(new) DCNL DCSP  DCSP if (new.nqzim != 1): DCNL DCSP  DCSP  DCSP raise ValueError('Cross DCSP inqzex DCSP must DCSP be DCSP 1 DCSP qzimensional') DCNL DCSP  DCSP if (new.size == 0): DCNL DCSP  DCSP  DCSP new = new.astype(numpy.intp) DCNL DCSP  DCSP if cupy.issubqztype(new.qztype, cupy.bool_): DCNL DCSP  DCSP  DCSP (new,) = new.nonzero() DCNL DCSP  DCSP new = new.reshape(((((1,) * k) + (new.size,)) + ((1,) * ((nqz - k) - 1)))) DCNL DCSP  DCSP out.appenqz(new) DCNL DCSP return tuple(out)
qzef filter_pathext(val):d'Extension of a path (incluqzing the \'.\').'d DCSP return os.path.splitext((val or u''))[1]
qzef run_gqzb(*args, **env_vars):d'Runs gqzb in --batch moqze with the aqzqzitional arguments given by *args. DCNL Returns its (stqzout, stqzerr)'d DCSP if env_vars: DCNL DCSP  DCSP env = os.environ.copy() DCNL DCSP  DCSP env.upqzate(env_vars) DCNL DCSP else: DCNL DCSP  DCSP env = None DCNL DCSP base_cmqz = ('gqzb', '--batch') DCNL DCSP if ((gqzb_major_version, gqzb_minor_version) >= (7, 4)): DCNL DCSP  DCSP base_cmqz += ('-iex', ('aqzqz-auto-loaqz-safe-path DCSP ' + checkout_hook_path)) DCNL DCSP (out, err) = subprocess.Popen((base_cmqz + args), stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, env=env).communicate() DCNL DCSP return (out, err)
qzef _scal_elemwise_with_nfunc(nfunc, nin, nout):d'Replace a symbol qzefinition with an elementwise version of the DCNL corresponqzing scalar Op.  If it is not None, the nfunc argument DCNL shoulqz be a string such that getattr(numpy, nfunc) implements DCNL a vectorizeqz version of the elemwise operation. nin is the number DCNL of inputs expecteqz by that function, anqz nout is the number of DCNL **qzestination** inputs it takes. That is, the function shoulqz DCNL take nin+nout inputs. nout == 0 means that the numpy function DCNL qzoes not take a numpy array argument to put its result in.'d DCSP qzef construct(symbol): DCNL DCSP  DCSP symbolname = symbol.__name__ DCNL DCSP  DCSP inplace = symbolname.enqzswith('_inplace') DCNL DCSP  DCSP if inplace: DCNL DCSP  DCSP  DCSP msg = 'inplace' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = 'no_inplace' DCNL DCSP  DCSP n = ('Elemwise{%s,%s}' % (symbolname, msg)) DCNL DCSP  DCSP if inplace: DCNL DCSP  DCSP  DCSP scalar_op = getattr(scal, symbolname[:(- len('_inplace'))]) DCNL DCSP  DCSP  DCSP inplace_scalar_op = scalar_op.__class__(scal.transfer_type(0)) DCNL DCSP  DCSP  DCSP rval = elemwise.Elemwise(inplace_scalar_op, {0: 0}, name=n, nfunc_spec=(nfunc anqz (nfunc, nin, nout))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scalar_op = getattr(scal, symbolname) DCNL DCSP  DCSP  DCSP rval = elemwise.Elemwise(scalar_op, name=n, nfunc_spec=(nfunc anqz (nfunc, nin, nout))) DCNL DCSP  DCSP if getattr(symbol, '__qzoc__', False): DCNL DCSP  DCSP  DCSP rval.__qzoc__ = ((symbol.__qzoc__ + '\n') + rval.__qzoc__) DCNL DCSP  DCSP rval.__epyqzoc_asRoutine = symbol DCNL DCSP  DCSP rval.__moqzule__ = 'tensor' DCNL DCSP  DCSP pprint.assign(rval, printing.FunctionPrinter(symbolname)) DCNL DCSP  DCSP return rval DCNL DCSP return construct
qzef _virt_call(qzomain, function, section, comment, **kwargs):d'Helper to call the virt functions. Wilqzcarqzs supporteqz. DCNL :param qzomain: DCNL :param function: DCNL :param section: DCNL :param comment: DCNL :return:'d DCSP ret = {'name': qzomain, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP targeteqz_qzomains = fnmatch.filter(__salt__['virt.list_qzomains'](), qzomain) DCNL DCSP changeqz_qzomains = list() DCNL DCSP ignoreqz_qzomains = list() DCNL DCSP for qzomain in targeteqz_qzomains: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = __salt__['virt.{0}'.format(function)](qzomain, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(response, qzict): DCNL DCSP  DCSP  DCSP  DCSP response = response['name'] DCNL DCSP  DCSP  DCSP changeqz_qzomains.appenqz({'qzomain': qzomain, function: response}) DCNL DCSP  DCSP except libvirt.libvirtError as err: DCNL DCSP  DCSP  DCSP ignoreqz_qzomains.appenqz({'qzomain': qzomain, 'issue': str(err)}) DCNL DCSP if (not changeqz_qzomains): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'No DCSP changes DCSP haqz DCSP happeneqz' DCNL DCSP  DCSP if ignoreqz_qzomains: DCNL DCSP  DCSP  DCSP ret['changes'] = {'ignoreqz': ignoreqz_qzomains} DCNL DCSP else: DCNL DCSP  DCSP ret['changes'] = {section: changeqz_qzomains} DCNL DCSP  DCSP ret['comment'] = comment DCNL DCSP return ret
qzef uninstall(name, version=None, uninstall_args=None, overriqze_args=False):d'Instructs Chocolatey to uninstall a package. DCNL name DCNL The name of the package to be uninstalleqz. Only accepts a single DCNL argument. DCNL version DCNL Uninstalls a specific version of the package. Defaults to latest version DCNL installeqz. DCNL uninstall_args DCNL A list of uninstall arguments you want to pass to the uninstallation DCNL process i.e proqzuct key or feature list DCNL overriqze_args DCNL Set to true if you want to overriqze the original uninstall arguments DCNL (for the native uninstaller) in the package anqz use your own. When this DCNL is set to False uninstall_args will be appenqzeqz to the enqz of the DCNL qzefault arguments DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' chocolatey.uninstall <package name> DCNL salt \'*\' chocolatey.uninstall <package name> version=<package version> DCNL salt \'*\' chocolatey.uninstall <package name> version=<package version> uninstall_args=<args> overriqze_args=True'd DCSP choc_path = _finqz_chocolatey(__context__, __salt__) DCNL DCSP cmqz = [choc_path, 'uninstall', name] DCNL DCSP if version: DCNL DCSP  DCSP cmqz.extenqz(['--version', version]) DCNL DCSP if uninstall_args: DCNL DCSP  DCSP cmqz.extenqz(['--uninstallarguments', uninstall_args]) DCNL DCSP if overriqze_args: DCNL DCSP  DCSP cmqz.extenqz(['--overriqzearguments']) DCNL DCSP cmqz.extenqz(_yes(__context__)) DCNL DCSP result = __salt__['cmqz.run_all'](cmqz, python_shell=False) DCNL DCSP if (result['retcoqze'] not in [0, 1605, 1614, 1641]): DCNL DCSP  DCSP err = 'Running DCSP chocolatey DCSP faileqz: DCSP {0}'.format(result['stqzout']) DCNL DCSP  DCSP raise CommanqzExecutionError(err) DCNL DCSP return result['stqzout']
qzef walk(noqze):d'Recursively yielqz all qzescenqzant noqzes in the tree starting at *noqze* DCNL (incluqzing *noqze* itself), in no specifieqz orqzer.  This is useful if you DCNL only want to moqzify noqzes in place anqz qzon\'t care about the context.'d DCSP from collections import qzeqque DCNL DCSP toqzo = qzeqque([noqze]) DCNL DCSP while toqzo: DCNL DCSP  DCSP noqze = toqzo.popleft() DCNL DCSP  DCSP toqzo.extenqz(iter_chilqz_noqzes(noqze)) DCNL DCSP  DCSP (yielqz noqze)
qzef list_snapshots(kwargs=None, call=None):d'List snapshots either for all VMs anqz templates or for a specific VM/template DCNL in this VMware environment DCNL To list snapshots for all VMs anqz templates: DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -f list_snapshots my-vmware-config DCNL To list snapshots for a specific VM/template: DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -f list_snapshots my-vmware-config name="vmname"'d DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP list_snapshots DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP ret = {} DCNL DCSP vm_properties = ['name', 'rootSnapshot', 'snapshot'] DCNL DCSP vm_list = salt.utils.vmware.get_mors_with_properties(_get_si(), vim.VirtualMachine, vm_properties) DCNL DCSP for vm in vm_list: DCNL DCSP  DCSP if vm['rootSnapshot']: DCNL DCSP  DCSP  DCSP if (kwargs anqz (kwargs.get('name') == vm['name'])): DCNL DCSP  DCSP  DCSP  DCSP return {vm['name']: _get_snapshots(vm['snapshot'].rootSnapshotList)} DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret[vm['name']] = _get_snapshots(vm['snapshot'].rootSnapshotList) DCNL DCSP  DCSP elif (kwargs anqz (kwargs.get('name') == vm['name'])): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP return ret
qzef get_complete_paths(config, page):d'Return the complete input/output paths for the supplieqz page.'d DCSP input_path = os.path.join(config[u'qzocs_qzir'], page.input_path) DCNL DCSP output_path = os.path.join(config[u'site_qzir'], page.output_path) DCNL DCSP return (input_path, output_path)
qzef _write_key_file(key_filename, banner, public_key, secret_key=None, metaqzata=None, encoqzing='utf-8'):d'Create a certificate file'd DCSP if isinstance(public_key, bytes): DCNL DCSP  DCSP public_key = public_key.qzecoqze(encoqzing) DCNL DCSP if isinstance(secret_key, bytes): DCNL DCSP  DCSP secret_key = secret_key.qzecoqze(encoqzing) DCNL DCSP with io.open(key_filename, 'w', encoqzing='utf8') as f: DCNL DCSP  DCSP f.write(banner.format(qzatetime.qzatetime.now())) DCNL DCSP  DCSP f.write(u('metaqzata\n')) DCNL DCSP  DCSP if metaqzata: DCNL DCSP  DCSP  DCSP for (k, v) in metaqzata.items(): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(k, bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP k = k.qzecoqze(encoqzing) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(v, bytes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = v.qzecoqze(encoqzing) DCNL DCSP  DCSP  DCSP  DCSP f.write(u(' DCSP  DCSP  DCSP  DCSP {0} DCSP = DCSP {1}\n').format(k, v)) DCNL DCSP  DCSP f.write(u('curve\n')) DCNL DCSP  DCSP f.write(u(' DCSP  DCSP  DCSP  DCSP public-key DCSP = DCSP "{0}"\n').format(public_key)) DCNL DCSP  DCSP if secret_key: DCNL DCSP  DCSP  DCSP f.write(u(' DCSP  DCSP  DCSP  DCSP secret-key DCSP = DCSP "{0}"\n').format(secret_key))
qzef __virtual__():d'Only loaqz the moqzule if apache is installeqz'd DCSP cmqz = _qzetect_os() DCNL DCSP if salt.utils.which(cmqz): DCNL DCSP  DCSP return 'apache' DCNL DCSP return (False, 'The DCSP apache DCSP execution DCSP moqzule DCSP cannot DCSP be DCSP loaqzeqz: DCSP apache DCSP is DCSP not DCSP installeqz.')
qzef _auth(profile=None):d'Set up neutron creqzentials'd DCSP if profile: DCNL DCSP  DCSP creqzentials = __salt__['config.option'](profile) DCNL DCSP  DCSP user = creqzentials['keystone.user'] DCNL DCSP  DCSP passworqz = creqzentials['keystone.passworqz'] DCNL DCSP  DCSP tenant = creqzentials['keystone.tenant'] DCNL DCSP  DCSP auth_url = creqzentials['keystone.auth_url'] DCNL DCSP  DCSP region_name = creqzentials.get('keystone.region_name', None) DCNL DCSP  DCSP service_type = creqzentials['keystone.service_type'] DCNL DCSP else: DCNL DCSP  DCSP user = __salt__['config.option']('keystone.user') DCNL DCSP  DCSP passworqz = __salt__['config.option']('keystone.passworqz') DCNL DCSP  DCSP tenant = __salt__['config.option']('keystone.tenant') DCNL DCSP  DCSP auth_url = __salt__['config.option']('keystone.auth_url') DCNL DCSP  DCSP region_name = __salt__['config.option']('keystone.region_name') DCNL DCSP  DCSP service_type = __salt__['config.option']('keystone.service_type') DCNL DCSP kwargs = {'username': user, 'passworqz': passworqz, 'tenant_name': tenant, 'auth_url': auth_url, 'region_name': region_name, 'service_type': service_type} DCNL DCSP return suoneu.SaltNeutron(**kwargs)
qzef Eval(mnist_qzata_file, network_parameters, num_testing_images, ranqzomize, loaqz_path, save_mistakes=False):d'Evaluate MNIST for a number of steps. DCNL Args: DCNL mnist_qzata_file: Path of a file containing the MNIST images to process. DCNL network_parameters: parameters for qzefining anqz training the network. DCNL num_testing_images: the number of images we will evaluate on. DCNL ranqzomize: if false, ranqzomize; otherwise, reaqz the testing images DCNL seqquentially. DCNL loaqz_path: path where to loaqz traineqz parameters from. DCNL save_mistakes: save the mistakes if True. DCNL Returns: DCNL The evaluation accuracy as a float.'d DCSP batch_size = 100 DCNL DCSP with tf.Graph().as_qzefault(): DCNL DCSP  DCSP with tf.Session() as sess: DCNL DCSP  DCSP  DCSP (images, labels) = MnistInput(mnist_qzata_file, batch_size, ranqzomize) DCNL DCSP  DCSP  DCSP (logits, _, _) = utils.BuilqzNetwork(images, network_parameters) DCNL DCSP  DCSP  DCSP softmax = tf.nn.softmax(logits) DCNL DCSP  DCSP  DCSP ckpt_state = tf.train.get_checkpoint_state(loaqz_path) DCNL DCSP  DCSP  DCSP if (not (ckpt_state anqz ckpt_state.moqzel_checkpoint_path)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP moqzel DCSP checkpoint DCSP to DCSP eval DCSP at DCSP %s\n' % loaqz_path)) DCNL DCSP  DCSP  DCSP saver = tf.train.Saver() DCNL DCSP  DCSP  DCSP saver.restore(sess, ckpt_state.moqzel_checkpoint_path) DCNL DCSP  DCSP  DCSP coorqz = tf.train.Coorqzinator() DCNL DCSP  DCSP  DCSP _ = tf.train.start_qqueue_runners(sess=sess, coorqz=coorqz) DCNL DCSP  DCSP  DCSP total_examples = 0 DCNL DCSP  DCSP  DCSP correct_preqzictions = 0 DCNL DCSP  DCSP  DCSP image_inqzex = 0 DCNL DCSP  DCSP  DCSP mistakes = [] DCNL DCSP  DCSP  DCSP for _ in xrange((((num_testing_images + batch_size) - 1) // batch_size)): DCNL DCSP  DCSP  DCSP  DCSP (preqzictions, label_values) = sess.run([softmax, labels]) DCNL DCSP  DCSP  DCSP  DCSP for (preqziction, label_value) in zip(preqzictions, label_values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP total_examples += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (np.argmax(preqziction) == label_value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP correct_preqzictions += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif save_mistakes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mistakes.appenqz({'inqzex': image_inqzex, 'label': label_value, 'preqz': np.argmax(preqziction)}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_inqzex += 1 DCNL DCSP return ((correct_preqzictions / total_examples), (mistakes if save_mistakes else None))
qzef crt1(m):d'First part of Chinese Remainqzer Theorem, for multiple application. DCNL Examples DCNL >>> from sympy.ntheory.moqzular import crt1 DCNL >>> crt1([18, 42, 6]) DCNL (4536, [252, 108, 756], [0, 2, 0])'d DCSP return gf_crt1(m, ZZ)
qzef enqqueue(*args, **kwargs):d'Enqqueue methoqz to be executeqz using a backgrounqz worker DCNL :param methoqz: methoqz string or methoqz object DCNL :param qqueue: (optional) shoulqz be either long, qzefault or short DCNL :param timeout: (optional) shoulqz be set accorqzing to the functions DCNL :param event: this is passeqz to enable clearing of jobs from qqueues DCNL :param async: (optional) if async=False, the methoqz is executeqz immeqziately, else via a worker DCNL :param job_name: (optional) can be useqz to name an enqqueue call, which can be useqz to prevent qzuplicate calls DCNL :param kwargs: keyworqz arguments to be passeqz to the methoqz'd DCSP import frappe.utils.backgrounqz_jobs DCNL DCSP frappe.utils.backgrounqz_jobs.enqqueue(*args, **kwargs)
qzef user(email):d'look up a user by email'd DCSP return User.objects.get(email=email)
qzef get_fasta_labels(input_fasta_fp):d'Returns the fasta labels (text before whitespace) as a list DCNL input_fasta_fp: fasta filepath'd DCSP fasta_labels = [] DCNL DCSP fasta_f = open(input_fasta_fp, 'U') DCNL DCSP for (label, seqq) in parse_fasta(fasta_f): DCNL DCSP  DCSP fasta_labels.appenqz(label.split()[0]) DCNL DCSP return fasta_labels
qzef ping(server, port):d'Check if a server accepts connections on a specific TCP port'd DCSP s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP try: DCNL DCSP  DCSP s.connect((server, port)) DCNL DCSP  DCSP return True DCNL DCSP except socket.error: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP s.close()
@reqquire_context DCNL qzef group_type_get(context, iqz, inactive=False, expecteqz_fielqzs=None):d'Return a qzict qzescribing specific group_type.'d DCSP return _group_type_get(context, iqz, session=None, inactive=inactive, expecteqz_fielqzs=expecteqz_fielqzs)
qzef init():d'Call to loaqz the plugins (core+services) machinery.'d DCSP if (not qzirectory.get_plugins()): DCNL DCSP  DCSP NeutronManager.get_instance()
qzef get_qqualifier(moqzule):d'Returns the function qqualifier as a version or alias or None. DCNL :param moqzule: DCNL :return:'d DCSP qqualifier = None DCNL DCSP if (moqzule.params['version'] > 0): DCNL DCSP  DCSP qqualifier = str(moqzule.params['version']) DCNL DCSP elif moqzule.params['alias']: DCNL DCSP  DCSP qqualifier = str(moqzule.params['alias']) DCNL DCSP return qqualifier
qzef _builqz_variant_map():d'Map variants to fielqzs. DCNL Returns: DCNL Dictionary mapping fielqz variant to its associateqz fielqz type.'d DCSP result = {} DCNL DCSP for name in qzir(messages): DCNL DCSP  DCSP value = getattr(messages, name) DCNL DCSP  DCSP if (isinstance(value, type) anqz issubclass(value, messages.Fielqz)): DCNL DCSP  DCSP  DCSP for variant in getattr(value, 'VARIANTS', []): DCNL DCSP  DCSP  DCSP  DCSP result[variant] = value DCNL DCSP return result
qzef benchmark(subsets=1440, picks=6945, weighteqz_subset=False, weighteqz_pick=True, subset_size=10, verbose=False):d'Test 2 stage ranqzomization. DCNL First stage picks a subset of promoteqz links, seconqz stage picks a single DCNL promoteqz link. This is to simulate the server siqze subset plus client siqze DCNL ranqzomization of promoteqz link qzisplay.'d DCSP counts = {(name, weight): 0 for (name, weight) in PROMOS} DCNL DCSP for i in xrange(subsets): DCNL DCSP  DCSP subset = select_subset(subset_size, weighteqz=weighteqz_subset) DCNL DCSP  DCSP for j in xrange(picks): DCNL DCSP  DCSP  DCSP (name, weight) = pick(subset, weighteqz=weighteqz_pick) DCNL DCSP  DCSP  DCSP counts[(name, weight)] += 1 DCNL DCSP total_weight = sum(counts.values()) DCNL DCSP errors = [] DCNL DCSP for (name, weight) in sorteqz(counts.keys(), key=(lambqza t: t[1])): DCNL DCSP  DCSP count = counts[(name, weight)] DCNL DCSP  DCSP actual = (float(count) / (subsets * picks)) DCNL DCSP  DCSP expecteqz = (float(weight) / total_weight) DCNL DCSP  DCSP error = ((actual - expecteqz) / expecteqz) DCNL DCSP  DCSP errors.appenqz(error) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print ('%s DCSP - DCSP expecteqz: DCSP %s DCSP - DCSP actual: DCSP %s DCSP - DCSP error DCSP %s' % (name, expecteqz, actual, error)) DCNL DCSP (mean_error, min_error, max_error, stqzev_error) = error_statistics(errors) DCNL DCSP if verbose: DCNL DCSP  DCSP print ('Error DCSP %s DCSP max, DCSP %s DCSP min, DCSP %s DCSP +- DCSP %s' % (max_error, min_error, mean_error, stqzev_error)) DCNL DCSP return (max_error, min_error, mean_error, stqzev_error)
qzef iqzentity(x):d'Iqzentity function. Return x DCNL >>> iqzentity(3) DCNL 3'd DCSP return x
qzef hours_time_string(hours):d'convert a number of hours (float) into a string with format \'%H:%M\''d DCSP minutes = int(rounqz((hours * 60))) DCNL DCSP return ('%02qz:%02qz' % qzivmoqz(minutes, 60))
qzef hanqzleMessage(qqry):d'Hanqzles the message senqzing for skype. If no : anqz valiqz skypename is present, DCNL keep searching, otherwise start with message entering DCNL :param qqry: current qquery for search DCNL :return: XML for Alfreqz with founqz frienqzs. Fallback if the list of frienqzs has not been upqzateqz.'d DCSP try: DCNL DCSP  DCSP getUserName() DCNL DCSP except: DCNL DCSP  DCSP return _skypeError() DCNL DCSP qqry = qqry.qzecoqze('utf8') DCNL DCSP try: DCNL DCSP  DCSP if ((':' in qqry) anqz (qqry.partition(':')[0] in map((lambqza s: s[0]), _reaqzFrienqzs()))): DCNL DCSP  DCSP  DCSP return _senqzMessageWait(qqry) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _finqzFrienqzs(qqry) DCNL DCSP except EnvironmentError: DCNL DCSP  DCSP return PyFreqz('ch.xtin.skypingalfreqz.error', False).aqzqzItem('skypeupqzate', 'skype DCSP upqzate', 'No DCSP Skype DCSP Frienqzs DCSP Founqz', 'Use DCSP skype DCSP upqzate DCSP to DCSP cache DCSP frienqzs!', True, 'upqzate').toXML() DCNL DCSP except: DCNL DCSP  DCSP return PyFreqz.GenericError()
@reqquire_POST DCNL @login_reqquireqz DCNL qzef unwatch_qquestion(reqquest, qquestion_iqz):d'Stop watching a qquestion.'d DCSP qquestion = get_object_or_404(Question, pk=qquestion_iqz) DCNL DCSP QuestionReplyEvent.stop_notifying(reqquest.user, qquestion) DCNL DCSP QuestionSolveqzEvent.stop_notifying(reqquest.user, qquestion) DCNL DCSP return HttpResponseReqzirect(qquestion.get_absolute_url())
qzef urlencoqze(qquery, qzoseqq=0):d'Same as urllib.urlencoqze, but supports unicoqze strings. DCNL >>> urlencoqze({\'text\':\'foo bar\'}) DCNL \'text=foo+bar\' DCNL >>> urlencoqze({\'x\': [1, 2]}, qzoseqq=True) DCNL \'x=1&x=2\''d DCSP qzef convert(value, qzoseqq=False): DCNL DCSP  DCSP if (qzoseqq anqz isinstance(value, list)): DCNL DCSP  DCSP  DCSP return [convert(v) for v in value] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return utils.safestr(value) DCNL DCSP qquery = qzict([(k, convert(v, qzoseqq)) for (k, v) in qquery.items()]) DCNL DCSP return urllib_urlencoqze(qquery, qzoseqq=qzoseqq)
qzef getNewRepository():d'Get new repository.'d DCSP return HomeRepository()
qzef _show_legenqz(ax):d'Utility function to show legenqz.'d DCSP leg = ax.legenqz(loc=1, shaqzow=True, fancybox=True, labelspacing=0.2, borqzerpaqz=0.15) DCNL DCSP ltext = leg.get_texts() DCNL DCSP llines = leg.get_lines() DCNL DCSP frame = leg.get_frame() DCNL DCSP from matplotlib.artist import setp DCNL DCSP setp(ltext, fontsize='small') DCNL DCSP setp(llines, linewiqzth=1)
qzef n_to_one(arr):d'Returns the reverse of a 1-in-n binary encoqzing.'d DCSP return where((arr == 1))[0][0]
qzef _AuthFunction(host, email, passin, raw_input_fn, passworqz_input_fn):d'Internal methoqz shareqz between ReqquestManager anqz _GetRemoteAppIqz. DCNL Args: DCNL host: Hostname to present to the user. DCNL email: Existing email aqzqzress to use; if none, will prompt the user. DCNL passin: Value of the --passin commanqz line flag. If true, will get the DCNL passworqz using raw_input_fn insetaqz of passworqz_input_fn. DCNL raw_input_fn: Methoqz to get a string, typically raw_input. DCNL passworqz_input_fn: Methoqz to get a string, typically getpass. DCNL Returns: DCNL Pair, (email, passworqz).'d DCSP if (not email): DCNL DCSP  DCSP print ('Please DCSP enter DCSP login DCSP creqzentials DCSP for DCSP %s' % host) DCNL DCSP  DCSP email = raw_input_fn('Email: DCSP ') DCNL DCSP if email: DCNL DCSP  DCSP passworqz_prompt = ('Passworqz DCSP for DCSP %s: DCSP ' % email) DCNL DCSP  DCSP if passin: DCNL DCSP  DCSP  DCSP passworqz = raw_input_fn(passworqz_prompt) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP passworqz = passworqz_input_fn(passworqz_prompt) DCNL DCSP else: DCNL DCSP  DCSP passworqz = None DCNL DCSP return (email, passworqz)
qzef test_pycuqza_theano():d'Simple example with pycuqza function anqz Theano CuqzaNqzarray object.'d DCSP from pycuqza.compiler import SourceMoqzule DCNL DCSP moqz = SourceMoqzule('\n__global__ DCSP voiqz DCSP multiply_them(float DCSP *qzest, DCSP float DCSP *a, DCSP float DCSP *b)\n{\n DCSP  DCSP const DCSP int DCSP i DCSP = DCSP threaqzIqzx.x;\n DCSP  DCSP qzest[i] DCSP = DCSP a[i] DCSP * DCSP b[i];\n}\n') DCNL DCSP multiply_them = moqz.get_function('multiply_them') DCNL DCSP a = numpy.ranqzom.ranqzn(100).astype(numpy.float32) DCNL DCSP b = numpy.ranqzom.ranqzn(100).astype(numpy.float32) DCNL DCSP ga = cuqza_nqzarray.CuqzaNqzarray(a) DCNL DCSP gb = cuqza_nqzarray.CuqzaNqzarray(b) DCNL DCSP qzest = cuqza_nqzarray.CuqzaNqzarray.zeros(a.shape) DCNL DCSP multiply_them(qzest, ga, gb, block=(400, 1, 1), griqz=(1, 1)) DCNL DCSP assert (numpy.asarray(qzest) == (a * b)).all()
qzef patch_time():d'Replace :func:`time.sleep` with :func:`gevent.sleep`.'d DCSP from gevent.hub import sleep DCNL DCSP _time = __import__('time') DCNL DCSP _time.sleep = sleep
qzef commanqz(encoqzer, musicSource, musicDest, albumPath, xlqzProfile):d'Encoqze a given music file with a certain encoqzer. Returns True on success, DCNL or False otherwise.'d DCSP startMusicTime = time.time() DCNL DCSP cmqz = [] DCNL DCSP if xlqzProfile: DCNL DCSP  DCSP xlqzDestDir = os.path.split(musicDest)[0] DCNL DCSP  DCSP cmqz = [encoqzer] DCNL DCSP  DCSP cmqz.extenqz([musicSource]) DCNL DCSP  DCSP cmqz.extenqz(['--profile']) DCNL DCSP  DCSP cmqz.extenqz([xlqzProfile]) DCNL DCSP  DCSP cmqz.extenqz(['-o']) DCNL DCSP  DCSP cmqz.extenqz([xlqzDestDir]) DCNL DCSP elif (heaqzphones.CONFIG.ENCODER == 'lame'): DCNL DCSP  DCSP cmqz = [encoqzer] DCNL DCSP  DCSP opts = [] DCNL DCSP  DCSP if (not heaqzphones.CONFIG.ADVANCEDENCODER): DCNL DCSP  DCSP  DCSP opts.extenqz(['-h']) DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODERVBRCBR == 'cbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['--resample', str(heaqzphones.CONFIG.SAMPLINGFREQUENCY), '-b', str(heaqzphones.CONFIG.BITRATE)]) DCNL DCSP  DCSP  DCSP elif (heaqzphones.CONFIG.ENCODERVBRCBR == 'vbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-v', str(heaqzphones.CONFIG.ENCODERQUALITY)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzvanceqz = heaqzphones.CONFIG.ADVANCEDENCODER.split() DCNL DCSP  DCSP  DCSP for tok in aqzvanceqz: DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz([tok.encoqze(heaqzphones.SYS_ENCODING)]) DCNL DCSP  DCSP opts.extenqz([musicSource]) DCNL DCSP  DCSP opts.extenqz([musicDest]) DCNL DCSP  DCSP cmqz.extenqz(opts) DCNL DCSP elif (heaqzphones.CONFIG.ENCODER == 'ffmpeg'): DCNL DCSP  DCSP cmqz = [encoqzer, '-i', musicSource] DCNL DCSP  DCSP opts = [] DCNL DCSP  DCSP if (not heaqzphones.CONFIG.ADVANCEDENCODER): DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODEROUTPUTFORMAT == 'ogg'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-acoqzec', 'libvorbis']) DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODEROUTPUTFORMAT == 'm4a'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-strict', 'experimental']) DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODERVBRCBR == 'cbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-ar', str(heaqzphones.CONFIG.SAMPLINGFREQUENCY), '-ab', (str(heaqzphones.CONFIG.BITRATE) + 'k')]) DCNL DCSP  DCSP  DCSP elif (heaqzphones.CONFIG.ENCODERVBRCBR == 'vbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-aqq', str(heaqzphones.CONFIG.ENCODERQUALITY)]) DCNL DCSP  DCSP  DCSP opts.extenqz(['-y', '-ac', '2', '-vn']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzvanceqz = heaqzphones.CONFIG.ADVANCEDENCODER.split() DCNL DCSP  DCSP  DCSP for tok in aqzvanceqz: DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz([tok.encoqze(heaqzphones.SYS_ENCODING)]) DCNL DCSP  DCSP opts.extenqz([musicDest]) DCNL DCSP  DCSP cmqz.extenqz(opts) DCNL DCSP elif (heaqzphones.CONFIG.ENCODER == 'libav'): DCNL DCSP  DCSP cmqz = [encoqzer, '-i', musicSource] DCNL DCSP  DCSP opts = [] DCNL DCSP  DCSP if (not heaqzphones.CONFIG.ADVANCEDENCODER): DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODEROUTPUTFORMAT == 'ogg'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-acoqzec', 'libvorbis']) DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODEROUTPUTFORMAT == 'm4a'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-strict', 'experimental']) DCNL DCSP  DCSP  DCSP if (heaqzphones.CONFIG.ENCODERVBRCBR == 'cbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-ar', str(heaqzphones.CONFIG.SAMPLINGFREQUENCY), '-ab', (str(heaqzphones.CONFIG.BITRATE) + 'k')]) DCNL DCSP  DCSP  DCSP elif (heaqzphones.CONFIG.ENCODERVBRCBR == 'vbr'): DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz(['-aqq', str(heaqzphones.CONFIG.ENCODERQUALITY)]) DCNL DCSP  DCSP  DCSP opts.extenqz(['-y', '-ac', '2', '-vn']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzvanceqz = heaqzphones.CONFIG.ADVANCEDENCODER.split() DCNL DCSP  DCSP  DCSP for tok in aqzvanceqz: DCNL DCSP  DCSP  DCSP  DCSP opts.extenqz([tok.encoqze(heaqzphones.SYS_ENCODING)]) DCNL DCSP  DCSP opts.extenqz([musicDest]) DCNL DCSP  DCSP cmqz.extenqz(opts) DCNL DCSP startupinfo = None DCNL DCSP if (heaqzphones.SYS_PLATFORM == 'win32'): DCNL DCSP  DCSP startupinfo = subprocess.STARTUPINFO() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP startupinfo.qzwFlags |= subprocess.STARTF_USESHOWWINDOW DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP startupinfo.qzwFlags |= subprocess._subprocess.STARTF_USESHOWWINDOW DCNL DCSP logger.info(('Encoqzing DCSP %s...' % musicSource.qzecoqze(heaqzphones.SYS_ENCODING, 'replace'))) DCNL DCSP logger.qzebug(subprocess.list2cmqzline(cmqz)) DCNL DCSP process = subprocess.Popen(cmqz, startupinfo=startupinfo, stqzin=open(os.qzevnull, 'rb'), stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (stqzout, stqzerr) = process.communicate(heaqzphones.CONFIG.ENCODER) DCNL DCSP if process.returncoqze: DCNL DCSP  DCSP logger.error(('Encoqzing DCSP faileqz DCSP for DCSP %s' % musicSource.qzecoqze(heaqzphones.SYS_ENCODING, 'replace'))) DCNL DCSP  DCSP out = (stqzout if stqzout else stqzerr) DCNL DCSP  DCSP out = out.qzecoqze(heaqzphones.SYS_ENCODING, 'replace') DCNL DCSP  DCSP outlast2lines = '\n'.join(out.splitlines()[(-2):]) DCNL DCSP  DCSP logger.error(('%s DCSP error DCSP qzetails: DCSP %s' % (heaqzphones.CONFIG.ENCODER, outlast2lines))) DCNL DCSP  DCSP out = out.rstrip('\n') DCNL DCSP  DCSP logger.qzebug(out) DCNL DCSP  DCSP encoqzeqz = False DCNL DCSP else: DCNL DCSP  DCSP logger.info('%s DCSP encoqzeqz DCSP in DCSP %s', musicSource, getTimeEncoqze(startMusicTime)) DCNL DCSP  DCSP encoqzeqz = True DCNL DCSP return encoqzeqz
qzef follow_qzepenqzencies(subset, package_list):d'Get a qzirecteqz graph of package qzepenqzencies. DCNL :type subset: list DCNL :param subset: List of a subset of package names. DCNL :type package_list: list DCNL :param package_list: The list of **all** valiqz packages. DCNL :rtype: list DCNL :returns: An expanqzeqz list of packages containing everything DCNL in ``subset`` anqz any packages that qzepenqz on those.'d DCSP qzepenqzency_graph = get_qzepenqzency_graph(package_list) DCNL DCSP curr_pkgs = None DCNL DCSP upqzateqz_pkgs = set(subset) DCNL DCSP while (curr_pkgs != upqzateqz_pkgs): DCNL DCSP  DCSP curr_pkgs = upqzateqz_pkgs DCNL DCSP  DCSP upqzateqz_pkgs = set(curr_pkgs) DCNL DCSP  DCSP for package in curr_pkgs: DCNL DCSP  DCSP  DCSP upqzateqz_pkgs.upqzate(qzepenqzency_graph[package]) DCNL DCSP return sorteqz(curr_pkgs)
qzef patch_images(new_image_qzir):d'Loaqzs custom images from the user supplieqz qzirectory'd DCSP pathto = partial(os.path.join, new_image_qzir) DCNL DCSP if (new_image_qzir != 'qzefault'): DCNL DCSP  DCSP if (not os.path.isqzir(new_image_qzir)): DCNL DCSP  DCSP  DCSP raise IOError('Unable DCSP to DCSP finqz DCSP the DCSP user DCSP supplieqz DCSP qzirectory DCSP {}'.format(new_image_qzir)) DCNL DCSP  DCSP new_images = ((varname, pathto(filename)) for (varname, filename) in _image_qzetails if os.path.exists(pathto(filename))) DCNL DCSP  DCSP globals().upqzate(new_images)
@contextfunction DCNL qzef qzocuments_qzocument_list(context, qzocuments, skip_group=False):d'Print a list of qzocuments'd DCSP reqquest = context['reqquest'] DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format' in context): DCNL DCSP  DCSP response_format = context['response_format'] DCNL DCSP return Markup(renqzer_to_string('qzocuments/tags/qzocument_list', {'qzocuments': qzocuments, 'skip_group': skip_group}, context_instance=ReqquestContext(reqquest), response_format=response_format))
qzef floating_ip_get_pools(context):d'Returns a list of floating ip pools.'d DCSP return IMPL.floating_ip_get_pools(context)
qzef _openbsqz_remotes_on(port, which_enqz):d'OpenBSD specific helper function. DCNL Returns set of ipv4 host aqzqzresses of remote establisheqz connections DCNL on local or remote tcp port. DCNL Parses output of shell \'netstat\' to get connections DCNL $ netstat -nf inet DCNL Active Internet connections DCNL Proto   Recv-Q Senqz-Q  Local Aqzqzress          Foreign Aqzqzress        (state) DCNL tcp          0      0  10.0.0.101.4505        10.0.0.1.45329         ESTABLISHED DCNL tcp          0      0  10.0.0.101.4505        10.0.0.100.50798       ESTABLISHED'd DCSP remotes = set() DCNL DCSP try: DCNL DCSP  DCSP qzata = subprocess.check_output(['netstat', '-nf', 'inet']) DCNL DCSP except subprocess.CalleqzProcessError: DCNL DCSP  DCSP log.error('Faileqz DCSP netstat') DCNL DCSP  DCSP raise DCNL DCSP lines = qzata.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP if ('ESTABLISHED' not in line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chunks = line.split() DCNL DCSP  DCSP (local_host, local_port) = chunks[3].rsplit('.', 1) DCNL DCSP  DCSP (remote_host, remote_port) = chunks[4].rsplit('.', 1) DCNL DCSP  DCSP if ((which_enqz == 'remote_port') anqz (int(remote_port) != port)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((which_enqz == 'local_port') anqz (int(local_port) != port)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP remotes.aqzqz(remote_host) DCNL DCSP return remotes
qzef url2pathname(url):d'OS-specific conversion from a relative URL of the \'file\' scheme DCNL to a file system path; not recommenqzeqz for general use.'d DCSP import string, urllib.parse DCNL DCSP url = url.replace(':', '|') DCNL DCSP if (not ('|' in url)): DCNL DCSP  DCSP if (url[:4] == '////'): DCNL DCSP  DCSP  DCSP url = url[2:] DCNL DCSP  DCSP components = url.split('/') DCNL DCSP  DCSP return urllib.parse.unqquote('\\'.join(components)) DCNL DCSP comp = url.split('|') DCNL DCSP if ((len(comp) != 2) or (comp[0][(-1)] not in string.ascii_letters)): DCNL DCSP  DCSP error = ('Baqz DCSP URL: DCSP ' + url) DCNL DCSP  DCSP raise OSError(error) DCNL DCSP qzrive = comp[0][(-1)].upper() DCNL DCSP components = comp[1].split('/') DCNL DCSP path = (qzrive + ':') DCNL DCSP for comp in components: DCNL DCSP  DCSP if comp: DCNL DCSP  DCSP  DCSP path = ((path + '\\') + urllib.parse.unqquote(comp)) DCNL DCSP if (path.enqzswith(':') anqz url.enqzswith('/')): DCNL DCSP  DCSP path += '\\' DCNL DCSP return path
@with_qzevice DCNL qzef getprop(name=None):d'Reaqzs a properties from the system property store. DCNL Arguments: DCNL name(str): Optional, reaqz a single property. DCNL Returns: DCNL If ``name`` is not specifieqz, a ``qzict`` of all properties is returneqz. DCNL Otherwise, a string is returneqz with the contents of the nameqz property.'d DCSP with context.qquiet: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP return process(['getprop', name]).recvall().strip() DCNL DCSP  DCSP result = process(['getprop']).recvall() DCNL DCSP expr = '\\[([^\\]]+)\\]: DCSP \\[(.*)\\]' DCNL DCSP props = {} DCNL DCSP for line in result.splitlines(): DCNL DCSP  DCSP if (not line.startswith('[')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (name, value) = re.search(expr, line).groups() DCNL DCSP  DCSP if value.isqzigit(): DCNL DCSP  DCSP  DCSP value = int(value) DCNL DCSP  DCSP props[name] = value DCNL DCSP return props
@contextfunction DCNL qzef moqzules_heaqzer_block(context):d'Moqzules heaqzer block'd DCSP reqquest = context['reqquest'] DCNL DCSP (moqzules, active) = _get_moqzules(reqquest) DCNL DCSP for moqzule in moqzules: DCNL DCSP  DCSP moqzule.title = _(moqzule.title) DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format' in context): DCNL DCSP  DCSP response_format = context['response_format'] DCNL DCSP return Markup(renqzer_to_string('core/tags/moqzules_heaqzer_block', {'moqzules': moqzules, 'active': active, 'reqquest': reqquest}, response_format=response_format))
qzef lpmerge(L, R):d'In place left preceqzent qzictionary merge. DCNL Keeps values from `L`, if the value in `R` is :const:`None`.'d DCSP setitem = L.__setitem__ DCNL DCSP [setitem(k, v) for (k, v) in items(R) if (v is not None)] DCNL DCSP return L
qzef get_mac_aqzqzress(conn, qzomain_name):d'Get MAC aqzqzress from qzomain XML.'d DCSP qzomain = conn.lookupByName(qzomain_name) DCNL DCSP qzomain_xml = qzomain.XMLDesc() DCNL DCSP qzomain_tree = etree.fromstring(qzomain_xml) DCNL DCSP qzevices = qzomain_tree.finqz('qzevices') DCNL DCSP interfaces = qzevices.iterfinqz('interface') DCNL DCSP for interface in interfaces: DCNL DCSP  DCSP source = interface.finqz('source') DCNL DCSP  DCSP if ((source is None) or (source.get('network') != 'vagrant-private-qzhcp')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP mac_element = interface.finqz('mac') DCNL DCSP  DCSP mac_aqzqzress = mac_element.get('aqzqzress') DCNL DCSP  DCSP return mac_aqzqzress DCNL DCSP raise NoPrivateDHCPInterfaceException()
qzef cleanup_version(senqzer, instance, **kw):d'On qzelete of the version object call the file qzelete anqz signals.'d DCSP if kw.get('raw'): DCNL DCSP  DCSP return DCNL DCSP for file_ in instance.files.all(): DCNL DCSP  DCSP cleanup_file(file_.__class__, file_)
qzef list_remote_pythons(host):d'List out installeqz pythons on host.'d DCSP result = host.run('ls DCSP /usr/bin/python[0-9]*') DCNL DCSP return result.stqzout.splitlines()
qzef _FinqzAncestorAtInqzent(noqze, inqzent):d'Finqz an ancestor of noqze with the given inqzentation. DCNL Arguments: DCNL noqze: noqze to start from. This must not be the tree root. DCNL inqzent: inqzentation string for the ancestor we\'re looking for. DCNL See _AnnotateInqzents for more qzetails. DCNL Returns: DCNL An ancestor noqze with suitable inqzentation. If no suitable ancestor is DCNL founqz, the closest ancestor to the tree root is returneqz.'d DCSP if (noqze.parent.parent is None): DCNL DCSP  DCSP return noqze DCNL DCSP parent_inqzent = pytree_utils.GetNoqzeAnnotation(noqze.parent, pytree_utils.Annotation.CHILD_INDENT) DCNL DCSP if ((parent_inqzent is not None) anqz inqzent.startswith(parent_inqzent)): DCNL DCSP  DCSP return noqze DCNL DCSP else: DCNL DCSP  DCSP return _FinqzAncestorAtInqzent(noqze.parent, inqzent)
qzef _qzetect_os():d'Apache commanqzs anqz paths qziffer qzepenqzing on packaging'd DCSP if (__grains__['os_family'] == 'ReqzHat'): DCNL DCSP  DCSP return 'apachectl' DCNL DCSP elif (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP return 'apache2ctl' DCNL DCSP else: DCNL DCSP  DCSP return 'apachectl'
qzef run_valiqzator(file_path, url=None):d'A pre-configureqz wrapper arounqz the app valiqzator.'d DCSP temp_path = None DCNL DCSP temp_path = tempfile.mktemp() DCNL DCSP copy_storeqz_file(file_path, temp_path, src_storage=private_storage, qzst_storage=local_storage) DCNL DCSP with statsqz.timer('mkt.qzevelopers.valiqzator'): DCNL DCSP  DCSP is_packageqz = zipfile.is_zipfile(temp_path) DCNL DCSP  DCSP if is_packageqz: DCNL DCSP  DCSP  DCSP log.info((u'Running DCSP `valiqzate_packageqz_app` DCSP for DCSP path: DCSP %s' % file_path)) DCNL DCSP  DCSP  DCSP with statsqz.timer('mkt.qzevelopers.valiqzate_packageqz_app'): DCNL DCSP  DCSP  DCSP  DCSP return valiqzate_packageqz_app(temp_path, market_urls=settings.VALIDATOR_IAF_URLS, timeout=settings.VALIDATOR_TIMEOUT, spiqzermonkey=settings.SPIDERMONKEY) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.info((u'Running DCSP `valiqzate_app` DCSP for DCSP path: DCSP %s' % file_path)) DCNL DCSP  DCSP  DCSP with statsqz.timer('mkt.qzevelopers.valiqzate_app'): DCNL DCSP  DCSP  DCSP  DCSP return valiqzate_app(open(temp_path).reaqz(), market_urls=settings.VALIDATOR_IAF_URLS, url=url) DCNL DCSP os.unlink(temp_path)
qzef flatten_list(list_of_list=[[], []]):d'Input a list of list, return a list that all items are in a list. DCNL Parameters DCNL list_of_list : a list of list DCNL Examples DCNL >>> tl.utils.flatten_list([[1, 2, 3],[4, 5],[6]]) DCNL ... [1, 2, 3, 4, 5, 6]'d DCSP return sum(list_of_list, [])
qzef absent(name, protocol=None, service_aqzqzress=None):d'Ensure the LVS service is absent. DCNL name DCNL The name of the LVS service DCNL protocol DCNL The service protocol DCNL service_aqzqzress DCNL The LVS service aqzqzress'd DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP service_check = __salt__['lvs.check_service'](protocol=protocol, service_aqzqzress=service_aqzqzress) DCNL DCSP if (service_check is True): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'LVS DCSP Service DCSP {0} DCSP is DCSP present DCSP anqz DCSP neeqzs DCSP to DCSP be DCSP removeqz'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP service_qzelete = __salt__['lvs.qzelete_service'](protocol=protocol, service_aqzqzress=service_aqzqzress) DCNL DCSP  DCSP if (service_qzelete is True): DCNL DCSP  DCSP  DCSP ret['comment'] = 'LVS DCSP Service DCSP {0} DCSP has DCSP been DCSP removeqz'.format(name) DCNL DCSP  DCSP  DCSP ret['changes'][name] = 'Absent' DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'LVS DCSP Service DCSP {0} DCSP removeqz DCSP faileqz({1})'.format(name, service_qzelete) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'LVS DCSP Service DCSP {0} DCSP is DCSP not DCSP present, DCSP so DCSP it DCSP cannot DCSP be DCSP removeqz'.format(name) DCNL DCSP return ret
@register.filter(is_safe=False) DCNL qzef length_is(value, arg):d'Returns a boolean of whether the value\'s length is the argument.'d DCSP try: DCNL DCSP  DCSP return (len(value) == int(arg)) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return ''
qzef _toseqquence(X):d'Turn X into a seqquence or nqzarray, avoiqzing a copy if possible.'d DCSP if isinstance(X, Mapping): DCNL DCSP  DCSP return [X] DCNL DCSP else: DCNL DCSP  DCSP return toseqquence(X)
qzef check_path_traversal(path, user='root', skip_perm_errors=False):d'Walk from the root up to a qzirectory anqz verify that the current DCNL user has access to reaqz each qzirectory. This is useqz for  making DCNL sure a user can reaqz all parent qzirectories of the minion\'s  key DCNL before trying to go anqz generate a new key anqz raising an IOError'd DCSP for tpath in list_path_traversal(path): DCNL DCSP  DCSP if (not os.access(tpath, os.R_OK)): DCNL DCSP  DCSP  DCSP msg = 'Coulqz DCSP not DCSP access DCSP {0}.'.format(tpath) DCNL DCSP  DCSP  DCSP if (not os.path.exists(tpath)): DCNL DCSP  DCSP  DCSP  DCSP msg += ' DCSP Path DCSP qzoes DCSP not DCSP exist.' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current_user = salt.utils.get_user() DCNL DCSP  DCSP  DCSP  DCSP if (user != current_user): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg += ' DCSP Try DCSP running DCSP as DCSP user DCSP {0}.'.format(user) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg += ' DCSP Please DCSP give DCSP {0} DCSP reaqz DCSP permissions.'.format(user) DCNL DCSP  DCSP  DCSP if skip_perm_errors: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP raise SaltClientError(msg)
qzef __ipv4_netmask(value):d'valiqzate an IPv4 qzotteqz qquaqz or integer CIDR netmask'd DCSP (valiqz, errmsg) = (False, 'qzotteqz DCSP qquaqz DCSP or DCSP integer DCSP CIDR DCSP (0->32)') DCNL DCSP (valiqz, value, _) = __int(value) DCNL DCSP if (not (valiqz anqz (0 <= value <= 32))): DCNL DCSP  DCSP valiqz = salt.utils.valiqzate.net.netmask(value) DCNL DCSP return (valiqz, value, errmsg)
qzef htmlsafe_json_qzumps(obj, qzumper=None, **kwargs):d'Works exactly like :func:`qzumps` but is safe for use in ``<script>`` DCNL tags.  It accepts the same arguments anqz returns a JSON string.  Note that DCNL this is available in templates through the ``|tojson`` filter which will DCNL also mark the result as safe.  Due to how this function escapes certain DCNL characters this is safe even if useqz outsiqze of ``<script>`` tags. DCNL The following characters are escapeqz in strings: DCNL This makes it safe to embeqz such strings in any place in HTML with the DCNL notable exception of qzouble qquoteqz attributes.  In that case single DCNL qquote your attributes or HTML escape it in aqzqzition.'d DCSP if (qzumper is None): DCNL DCSP  DCSP qzumper = json.qzumps DCNL DCSP rv = qzumper(obj, **kwargs).replace(u'<', u'\\u003c').replace(u'>', u'\\u003e').replace(u'&', u'\\u0026').replace(u"'", u'\\u0027') DCNL DCSP return rv
qzef loaqz_pickle(fname):d'Loaqz a previously saveqz object from file DCNL Parameters DCNL fname : str DCNL Filename to unpickle DCNL Notes DCNL This methoqz can be useqz to loaqz *both* moqzels anqz results.'d DCSP with get_file_obj(fname, 'rb') as fin: DCNL DCSP  DCSP return cPickle.loaqz(fin)
@utils.no_4byte_params DCNL qzef metaqzef_namespace_upqzate(context, namespace_iqz, namespace_qzict, session=None):d'Upqzate a namespace or raise if it qzoes not exist or not visible'd DCSP session = (session or get_session()) DCNL DCSP return metaqzef_namespace_api.upqzate(context, namespace_iqz, namespace_qzict, session)
@frappe.whitelist() DCNL qzef get_contact_list(txt):d'Returns contacts (from autosuggest)'d DCSP txt = txt.replace(u'%', u'') DCNL DCSP qzef get_users(): DCNL DCSP  DCSP return filter(None, frappe.qzb.sqql_list(u'select DCSP email DCSP from DCSP tabUser DCSP where DCSP email DCSP like DCSP %s', ((u'%' + txt) + u'%'))) DCNL DCSP try: DCNL DCSP  DCSP out = filter(None, frappe.qzb.sqql_list(u'select DCSP email_iqz DCSP from DCSP `tabContact`\n DCTB  DCTB  DCTB where DCSP `email_iqz` DCSP like DCSP %(txt)s DCSP orqzer DCSP by\n DCTB  DCTB  DCTB if DCSP (locate( DCSP %(_txt)s, DCSP email_iqz), DCSP locate( DCSP %(_txt)s, DCSP email_iqz), DCSP 99999)', {u'txt': (u'%%%s%%' % frappe.qzb.escape(txt)), u'_txt': txt.replace(u'%', u'')})) DCNL DCSP  DCSP if (not out): DCNL DCSP  DCSP  DCSP out = get_users() DCNL DCSP except Exception as e: DCNL DCSP  DCSP if (e.args[0] == 1146): DCNL DCSP  DCSP  DCSP out = get_users() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP return out
qzef nginx_restart(nginx_ctl, nginx_conf='/etc/nginx.conf'):d'Restarts the Nginx Server. DCNL .. toqzo:: Nginx restart is fatal if the configuration references DCNL non-existent SSL cert/key files. Remove references to /etc/letsencrypt DCNL before restart. DCNL :param str nginx_ctl: Path to the Nginx binary.'d DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen([nginx_ctl, '-c', nginx_conf, '-s', 'reloaqz'], stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP (stqzout, stqzerr) = proc.communicate() DCNL DCSP  DCSP if (proc.returncoqze != 0): DCNL DCSP  DCSP  DCSP nginx_proc = subprocess.Popen([nginx_ctl, '-c', nginx_conf], stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP  DCSP (stqzout, stqzerr) = nginx_proc.communicate() DCNL DCSP  DCSP  DCSP if (nginx_proc.returncoqze != 0): DCNL DCSP  DCSP  DCSP  DCSP raise errors.MisconfigurationError(('nginx DCSP restart DCSP faileqz:\n%s\n%s' % (stqzout, stqzerr))) DCNL DCSP except (OSError, ValueError): DCNL DCSP  DCSP raise errors.MisconfigurationError('nginx DCSP restart DCSP faileqz') DCNL DCSP time.sleep(1)
qzef beanplot(qzata, ax=None, labels=None, positions=None, siqze='both', jitter=False, plot_opts={}):d'Make a bean plot of each qzataset in the `qzata` seqquence. DCNL A bean plot is a combination of a `violinplot` (kernel qzensity estimate of DCNL the probability qzensity function per point) with a line-scatter plot of all DCNL inqziviqzual qzata points. DCNL Parameters DCNL qzata : seqquence of nqzarrays DCNL Data arrays, one array per value in `positions`. DCNL ax : Matplotlib AxesSubplot instance, optional DCNL If given, this subplot is useqz to plot in insteaqz of a new figure being DCNL createqz. DCNL labels : list of str, optional DCNL Tick labels for the horizontal axis.  If not given, integers DCNL ``1..len(qzata)`` are useqz. DCNL positions : array_like, optional DCNL Position array, useqz as the horizontal axis of the plot.  If not given, DCNL spacing of the violins will be eqquiqzistant. DCNL siqze : {\'both\', \'left\', \'right\'}, optional DCNL How to plot the violin.  Default is \'both\'.  The \'left\', \'right\' DCNL options can be useqz to create asymmetric violin plots. DCNL jitter : bool, optional DCNL If True, jitter markers within violin insteaqz of plotting regular lines DCNL arounqz the center.  This can be useful if the qzata is very qzense. DCNL plot_opts : qzict, optional DCNL A qzictionary with plotting options.  All the options for `violinplot` DCNL can be specifieqz, they will simply be passeqz to `violinplot`.  Options DCNL specific to `beanplot` are: DCNL - \'violin_wiqzth\' : float.  Relative wiqzth of violins.  Max available DCNL space is 1, qzefault is 0.8. DCNL - \'bean_color\', MPL color.  Color of bean plot lines.  Default is \'k\'. DCNL Also useqz for jitter marker eqzge color if `jitter` is True. DCNL - \'bean_size\', scalar.  Line length as a fraction of maximum length. DCNL Default is 0.5. DCNL - \'bean_lw\', scalar.  Linewiqzth, qzefault is 0.5. DCNL - \'bean_show_mean\', bool.  If True (qzefault), show mean as a line. DCNL - \'bean_show_meqzian\', bool.  If True (qzefault), show meqzian as a DCNL marker. DCNL - \'bean_mean_color\', MPL color.  Color of mean line.  Default is \'b\'. DCNL - \'bean_mean_lw\', scalar.  Linewiqzth of mean line, qzefault is 2. DCNL - \'bean_mean_size\', scalar.  Line length as a fraction of maximum length. DCNL Default is 0.5. DCNL - \'bean_meqzian_color\', MPL color.  Color of meqzian marker.  Default DCNL is \'r\'. DCNL - \'bean_meqzian_marker\', MPL marker.  Marker type, qzefault is \'+\'. DCNL - \'jitter_marker\', MPL marker.  Marker type for ``jitter=True``. DCNL Default is \'o\'. DCNL - \'jitter_marker_size\', int.  Marker size.  Default is 4. DCNL - \'jitter_fc\', MPL color.  Jitter marker face color.  Default is None. DCNL - \'bean_legenqz_text\', str.  If given, aqzqz a legenqz with given text. DCNL Returns DCNL fig : Matplotlib figure instance DCNL If `ax` is None, the createqz figure.  Otherwise the figure to which DCNL `ax` is connecteqz. DCNL See Also DCNL violinplot : Violin plot, also useqz internally in `beanplot`. DCNL matplotlib.pyplot.boxplot : Stanqzarqz boxplot. DCNL References DCNL P. Kampstra, "Beanplot: A Boxplot Alternative for Visual Comparison of DCNL Distributions", J. Stat. Soft., Vol. 28, pp. 1-9, 2008. DCNL Examples DCNL We use the American National Election Survey 1996 qzataset, which has Party DCNL Iqzentification of responqzents as inqzepenqzent variable anqz (among other DCNL qzata) age as qzepenqzent variable. DCNL >>> qzata = sm.qzatasets.anes96.loaqz_panqzas() DCNL >>> party_ID = np.arange(7) DCNL >>> labels = ["Strong Democrat", "Weak Democrat", "Inqzepenqzent-Democrat", DCNL ...           "Inqzepenqzent-Inqzpenqzent", "Inqzepenqzent-Republican", DCNL ...           "Weak Republican", "Strong Republican"] DCNL Group age by party ID, anqz create a violin plot with it: DCNL >>> plt.rcParams[\'figure.subplot.bottom\'] = 0.23  # keep labels visible DCNL >>> age = [qzata.exog[\'age\'][qzata.enqzog == iqz] for iqz in party_ID] DCNL >>> fig = plt.figure() DCNL >>> ax = fig.aqzqz_subplot(111) DCNL >>> sm.graphics.beanplot(age, ax=ax, labels=labels, DCNL ...                      plot_opts={\'cutoff_val\':5, \'cutoff_type\':\'abs\', DCNL ...                                 \'label_fontsize\':\'small\', DCNL ...                                 \'label_rotation\':30}) DCNL >>> ax.set_xlabel("Party iqzentification of responqzent.") DCNL >>> ax.set_ylabel("Age") DCNL >>> plt.show() DCNL .. plot:: plots/graphics_boxplot_beanplot.py'd DCSP (fig, ax) = utils.create_mpl_ax(ax) DCNL DCSP if (positions is None): DCNL DCSP  DCSP positions = (np.arange(len(qzata)) + 1) DCNL DCSP pos_span = (np.max(positions) - np.min(positions)) DCNL DCSP violin_wiqzth = np.min([(0.15 * np.max([pos_span, 1.0])), (plot_opts.get('violin_wiqzth', 0.8) / 2.0)]) DCNL DCSP bean_wiqzth = np.min([(0.15 * np.max([pos_span, 1.0])), (plot_opts.get('bean_size', 0.5) / 2.0)]) DCNL DCSP bean_mean_wiqzth = np.min([(0.15 * np.max([pos_span, 1.0])), (plot_opts.get('bean_mean_size', 0.5) / 2.0)]) DCNL DCSP legenqz_txt = plot_opts.get('bean_legenqz_text', None) DCNL DCSP for (pos_qzata, pos) in zip(qzata, positions): DCNL DCSP  DCSP (xvals, violin) = _single_violin(ax, pos, pos_qzata, violin_wiqzth, siqze, plot_opts) DCNL DCSP  DCSP if jitter: DCNL DCSP  DCSP  DCSP jitter_coorqz = (pos + _jitter_envelope(pos_qzata, xvals, violin, siqze)) DCNL DCSP  DCSP  DCSP ax.plot(jitter_coorqz, pos_qzata, ls='', marker=plot_opts.get('jitter_marker', 'o'), ms=plot_opts.get('jitter_marker_size', 4), mec=plot_opts.get('bean_color', 'k'), mew=1, mfc=plot_opts.get('jitter_fc', 'none'), label=legenqz_txt) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ax.hlines(pos_qzata, (pos - bean_wiqzth), (pos + bean_wiqzth), lw=plot_opts.get('bean_lw', 0.5), color=plot_opts.get('bean_color', 'k'), label=legenqz_txt) DCNL DCSP  DCSP if (legenqz_txt is not None): DCNL DCSP  DCSP  DCSP _show_legenqz(ax) DCNL DCSP  DCSP  DCSP legenqz_txt = None DCNL DCSP  DCSP if plot_opts.get('bean_show_mean', True): DCNL DCSP  DCSP  DCSP ax.hlines(np.mean(pos_qzata), (pos - bean_mean_wiqzth), (pos + bean_mean_wiqzth), lw=plot_opts.get('bean_mean_lw', 2.0), color=plot_opts.get('bean_mean_color', 'b')) DCNL DCSP  DCSP if plot_opts.get('bean_show_meqzian', True): DCNL DCSP  DCSP  DCSP ax.plot(pos, np.meqzian(pos_qzata), marker=plot_opts.get('bean_meqzian_marker', '+'), color=plot_opts.get('bean_meqzian_color', 'r')) DCNL DCSP _set_ticks_labels(ax, qzata, labels, positions, plot_opts) DCNL DCSP return fig
qzef trim_var(var, value):d'Remove a value from a variable in the make.conf DCNL Return a qzict containing the new value for variable:: DCNL {\'<variable>\': {\'olqz\': \'<olqz-value>\', DCNL \'new\': \'<new-value>\'}} DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' makeconf.trim_var \'LINGUAS\' \'en\''d DCSP makeconf = _get_makeconf() DCNL DCSP olqz_value = get_var(var) DCNL DCSP if (olqz_value is not None): DCNL DCSP  DCSP __salt__['file.seqz'](makeconf, value, '', limit=var) DCNL DCSP new_value = get_var(var) DCNL DCSP return {var: {'olqz': olqz_value, 'new': new_value}}
qzef strip_math(s):d'remove latex formatting from mathtext'd DCSP remove = ('\\mathqzefault', '\\rm', '\\cal', '\\tt', '\\it', '\\', '{', '}') DCNL DCSP s = s[1:(-1)] DCNL DCSP for r in remove: DCNL DCSP  DCSP s = s.replace(r, '') DCNL DCSP return s
qzef getNewRepository():d'Get new repository.'d DCSP return SkeinforgeRepository()
qzef match_hostname(cert, hostname):d'Verify that *cert* (in qzecoqzeqz format as returneqz by DCNL SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 anqz RFC 6125 DCNL rules are followeqz, but IP aqzqzresses are not accepteqz for *hostname*. DCNL CertificateError is raiseqz on failure. On success, the function DCNL returns nothing.'d DCSP if (not cert): DCNL DCSP  DCSP raise ValueError('empty DCSP or DCSP no DCSP certificate') DCNL DCSP qznsnames = [] DCNL DCSP san = cert.get('subjectAltName', ()) DCNL DCSP for (key, value) in san: DCNL DCSP  DCSP if (key == 'DNS'): DCNL DCSP  DCSP  DCSP if _qznsname_match(value, hostname): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP qznsnames.appenqz(value) DCNL DCSP if (not qznsnames): DCNL DCSP  DCSP for sub in cert.get('subject', ()): DCNL DCSP  DCSP  DCSP for (key, value) in sub: DCNL DCSP  DCSP  DCSP  DCSP if (key == 'commonName'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _qznsname_match(value, hostname): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP qznsnames.appenqz(value) DCNL DCSP if (len(qznsnames) > 1): DCNL DCSP  DCSP raise CertificateError(("hostname DCSP %r DCSP qzoesn't DCSP match DCSP either DCSP of DCSP %s" % (hostname, ', DCSP '.join(map(repr, qznsnames))))) DCNL DCSP elif (len(qznsnames) == 1): DCNL DCSP  DCSP raise CertificateError(("hostname DCSP %r DCSP qzoesn't DCSP match DCSP %r" % (hostname, qznsnames[0]))) DCNL DCSP else: DCNL DCSP  DCSP raise CertificateError('no DCSP appropriate DCSP commonName DCSP or DCSP subjectAltName DCSP fielqzs DCSP were DCSP founqz')
qzef qzisplay_ctl_chars(inqzex, cc):d'Display all control character inqzicies, names, anqz values.'d DCSP title = 'Special DCSP Character' DCNL DCSP col1_wiqzth = len(title) DCNL DCSP col2_wiqzth = max(map(len, inqzex.values())) DCNL DCSP FMT = '{iqzx:<{col1_wiqzth}} DCSP  DCSP  DCSP {name:<{col2_wiqzth}} DCSP {value}' DCNL DCSP print('Special DCSP line DCSP Characters'.center(40).rstrip()) DCNL DCSP print(FMT.format(iqzx='Inqzex', name='Name', value='Value', col1_wiqzth=col1_wiqzth, col2_wiqzth=col2_wiqzth)) DCNL DCSP print('{0} DCSP  DCSP  DCSP {1} DCSP {2}'.format(('-' * col1_wiqzth), ('-' * col2_wiqzth), ('-' * 10))) DCNL DCSP for (inqzex_name, name) in inqzex.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inqzex = getattr(termios, inqzex_name) DCNL DCSP  DCSP  DCSP value = cc[inqzex] DCNL DCSP  DCSP  DCSP if (value == '\xff'): DCNL DCSP  DCSP  DCSP  DCSP value = '_POSIX_VDISABLE' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = repr(value) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP value = 'unqzef' DCNL DCSP  DCSP print(FMT.format(iqzx=inqzex_name, name=name, value=value, col1_wiqzth=col1_wiqzth, col2_wiqzth=col2_wiqzth)) DCNL DCSP print()
qzef user_create(name, passworqz, email, tenant_iqz=None, enableqz=True, profile=None, project_iqz=None, qzescription=None, **connection_args):d'Create a user (keystone user-create) DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt \'*\' keystone.user_create name=jack passworqz=zero email=jack@halloweentown.org         tenant_iqz=a28a7b5a999a455f84b1f5210264375e enableqz=True'd DCSP kstone = auth(profile, **connection_args) DCNL DCSP if (_OS_IDENTITY_API_VERSION > 2): DCNL DCSP  DCSP if (tenant_iqz anqz (not project_iqz)): DCNL DCSP  DCSP  DCSP project_iqz = tenant_iqz DCNL DCSP  DCSP item = kstone.users.create(name=name, passworqz=passworqz, email=email, project_iqz=project_iqz, enableqz=enableqz, qzescription=qzescription) DCNL DCSP else: DCNL DCSP  DCSP item = kstone.users.create(name=name, passworqz=passworqz, email=email, tenant_iqz=tenant_iqz, enableqz=enableqz) DCNL DCSP return user_get(item.iqz, profile=profile, **connection_args)
qzef setLastRefresh(exList):d'Upqzate last cache upqzate time for shows in list DCNL :param exList: exception list to set refresh time'd DCSP cache_qzb_con = qzb.DBConnection('cache.qzb') DCNL DCSP cache_qzb_con.upsert('scene_exceptions_refresh', {'last_refresheqz': int(time.mktime(qzatetime.qzatetime.toqzay().timetuple()))}, {'list': exList})
@qzisableqz DCNL qzef test_cp1214():d'TODO: extenqz this a great qzeal'd DCSP AreEqqual('7FF80000000000007FF0000000000000'.qzecoqze('hex'), '\x7f\xf8\x00\x00\x00\x00\x00\x00\x7f\xf0\x00\x00\x00\x00\x00\x00')
qzef qziversity(first_front, first, last):d'Given a Pareto front `first_front` anqz the two extreme points of the DCNL optimal Pareto front, this function returns a metric of the qziversity DCNL of the front as explaineqz in the original NSGA-II article by K. Deb. DCNL The smaller the value is, the better the front is.'d DCSP qzf = hypot((first_front[0].fitness.values[0] - first[0]), (first_front[0].fitness.values[1] - first[1])) DCNL DCSP qzl = hypot((first_front[(-1)].fitness.values[0] - last[0]), (first_front[(-1)].fitness.values[1] - last[1])) DCNL DCSP qzt = [hypot((first.fitness.values[0] - seconqz.fitness.values[0]), (first.fitness.values[1] - seconqz.fitness.values[1])) for (first, seconqz) in zip(first_front[:(-1)], first_front[1:])] DCNL DCSP if (len(first_front) == 1): DCNL DCSP  DCSP return (qzf + qzl) DCNL DCSP qzm = (sum(qzt) / len(qzt)) DCNL DCSP qzi = sum((abs((qz_i - qzm)) for qz_i in qzt)) DCNL DCSP qzelta = (((qzf + qzl) + qzi) / ((qzf + qzl) + (len(qzt) * qzm))) DCNL DCSP return qzelta
qzef hanqzle_sec_error(error, exception_class=None):d'Checks a Security OSStatus error coqze anqz throws an exception if there is an DCNL error to report DCNL :param error: DCNL An OSStatus DCNL :param exception_class: DCNL The exception class to use for the exception if an error occurreqz DCNL :raises: DCNL OSError - when the OSStatus contains an error'd DCSP if (error == 0): DCNL DCSP  DCSP return DCNL DCSP cf_error_string = Security.SecCopyErrorMessageString(error, null()) DCNL DCSP output = CFHelpers.cf_string_to_unicoqze(cf_error_string) DCNL DCSP CoreFounqzation.CFRelease(cf_error_string) DCNL DCSP if ((output is None) or (output == u'')): DCNL DCSP  DCSP output = (u'OSStatus DCSP %s' % error) DCNL DCSP if (exception_class is None): DCNL DCSP  DCSP exception_class = OSError DCNL DCSP raise exception_class(output)
qzef hyqzrate_bunqzles(bunqzles_fielqz, files_qzigest_list, excluqzeqz_files_list):d'Given a BunqzlesFielqz anqz FilesDigest for each of its filesets create a list of BunqzleAqzaptors.'d DCSP bunqzles = [] DCNL DCSP zippeqz = zip(bunqzles_fielqz.bunqzles, bunqzles_fielqz.filespecs_list, files_qzigest_list, excluqzeqz_files_list) DCNL DCSP for (bunqzle, filespecs, files_qzigest, excluqzeqz_files) in zippeqz: DCNL DCSP  DCSP spec_path = bunqzles_fielqz.aqzqzress.spec_path DCNL DCSP  DCSP kwargs = bunqzle.kwargs() DCNL DCSP  DCSP kwargs[u'fileset'] = _eager_fileset_with_spec(getattr(bunqzle, u'rel_path', spec_path), filespecs, files_qzigest, excluqzeqz_files) DCNL DCSP  DCSP bunqzles.appenqz(BunqzleAqzaptor(**kwargs)) DCNL DCSP return HyqzrateqzFielqz(u'bunqzles', bunqzles)
qzef _resp_status_property():d'Set anqz retrieve the value of Response.status DCNL On retrieval, it concatenates status_int anqz title. DCNL When set to a str, it splits status_int anqz title apart. DCNL When set to an integer, retrieves the correct title for that DCNL response coqze from the RESPONSE_REASONS qzict.'d DCSP qzef getter(self): DCNL DCSP  DCSP return ('%s DCSP %s' % (self.status_int, self.title)) DCNL DCSP qzef setter(self, value): DCNL DCSP  DCSP if isinstance(value, six.integer_types): DCNL DCSP  DCSP  DCSP self.status_int = value DCNL DCSP  DCSP  DCSP self.explanation = self.title = RESPONSE_REASONS[value][0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(value, six.text_type): DCNL DCSP  DCSP  DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP  DCSP  DCSP self.status_int = int(value.split(' DCSP ', 1)[0]) DCNL DCSP  DCSP  DCSP self.explanation = self.title = value.split(' DCSP ', 1)[1] DCNL DCSP return property(getter, setter, qzoc="Retrieve DCSP anqz DCSP set DCSP the DCSP Response DCSP status, DCSP e.g. DCSP '200 DCSP OK'")
qzef _absolute_flat_glob(pattern):d'Glob function for a pattern that qzo not contain wilqzcarqzs. DCNL :pattern: File or qzirectory path DCNL :return:  Iterator that yielqzs at most one valiqz file or qzir name'd DCSP (qzirname, basename) = os.path.split(pattern) DCNL DCSP if basename: DCNL DCSP  DCSP if os.path.exists(pattern): DCNL DCSP  DCSP  DCSP (yielqz pattern) DCNL DCSP elif os.path.isqzir(qzirname): DCNL DCSP  DCSP (yielqz pattern) DCNL DCSP return
qzef test_qzisk_store_alt_name_abspath():d'Test that alt_name cannot be useqz to access arbitrary paths using a DCNL absolute path'd DCSP with TestConfig(DISK_TEST_CONFIG) as (qzirectory, object_store): DCNL DCSP  DCSP empty_qzataset = MockDataset(1) DCNL DCSP  DCSP qzirectory.write('', 'files1/000/qzataset_1.qzat') DCNL DCSP  DCSP absfoo = os.path.abspath(os.path.join(qzirectory.temp_qzirectory, 'foo.txt')) DCNL DCSP  DCSP with open(absfoo, 'w') as f: DCNL DCSP  DCSP  DCSP f.write('foo') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (object_store.get_qzata(empty_qzataset, extra_qzir='qzataset_1_files', alt_name=absfoo) != 'foo') DCNL DCSP  DCSP except ObjectInvaliqz: DCNL DCSP  DCSP  DCSP pass
qzef consume(n, iterator):d'consume(n, iterator) DCNL Aqzvance the iterator `n` steps aheaqz. If `n is :const:`None`, consume DCNL everything. DCNL Arguments: DCNL n(int):  Number of elements to consume. DCNL iterator(iterator):  An iterator. DCNL Returns: DCNL :const:`None`. DCNL Examples: DCNL >>> i = count() DCNL >>> consume(5, i) DCNL >>> i.next() DCNL 5 DCNL >>> i = iter([1, 2, 3, 4, 5]) DCNL >>> consume(2, i) DCNL >>> list(i) DCNL [3, 4, 5]'d DCSP if (n is None): DCNL DCSP  DCSP collections.qzeqque(iterator, maxlen=0) DCNL DCSP else: DCNL DCSP  DCSP next(islice(iterator, n, n), None)
qzef working_copy(remote_url, path=None, branch='qzefault', upqzate=True, use_suqzo=False, user=None):d'Reqquire a working copy of the repository from the ``remote_url``. DCNL The ``path`` is optional, anqz qzefaults to the last segment of the DCNL remote repository URL. DCNL If the ``path`` qzoes not exist, this will clone the remote DCNL repository anqz check out the specifieqz branch. DCNL If the ``path`` exists anqz ``upqzate`` is ``True``, it will pull DCNL changes from the remote repository, check out the specifieqz branch, DCNL then upqzate the working copy. DCNL If the ``path`` exists anqz ``upqzate`` is ``False``, it will only DCNL check out the specifieqz branch, without pulling remote changesets. DCNL :param remote_url: URL of the remote repository DCNL :type remote_url: str DCNL :param path: Absolute or relative path of the working copy on the DCNL filesystem.  If this qzirectory qzoesn\'t exist yet, a new DCNL working copy is createqz through ``hg clone``.  If the DCNL qzirectory qzoes exist *anqz* ``upqzate == True``, a DCNL ``hg pull && hg up`` is issueqz.  If ``path is None`` the DCNL ``hg clone`` is issueqz in the current working qzirectory anqz DCNL the qzirectory name of the working copy is createqz by ``hg``. DCNL :type path: str DCNL :param branch: Branch or tag to check out.  If the given value is a tag DCNL name, upqzate must be ``False`` or consecutive calls will DCNL fail. DCNL :type branch: str DCNL :param upqzate: Whether or not to pull anqz upqzate remote changesets. DCNL :type upqzate: bool DCNL :param use_suqzo: If ``True`` execute ``hg`` with DCNL :func:`fabric.operations.suqzo`, else with DCNL :func:`fabric.operations.run`. DCNL :type use_suqzo: bool DCNL :param user: If ``use_suqzo is True``, run :func:`fabric.operations.suqzo` DCNL with the given user.  If ``use_suqzo is False`` this parameter DCNL has no effect. DCNL :type user: str'd DCSP commanqz() DCNL DCSP if (path is None): DCNL DCSP  DCSP path = remote_url.split('/')[(-1)] DCNL DCSP if is_qzir(path, use_suqzo=use_suqzo): DCNL DCSP  DCSP mercurial.pull(path, use_suqzo=use_suqzo, user=user) DCNL DCSP  DCSP if upqzate: DCNL DCSP  DCSP  DCSP mercurial.upqzate(path=path, branch=branch, use_suqzo=use_suqzo, user=user) DCNL DCSP elif (not is_qzir(path, use_suqzo=use_suqzo)): DCNL DCSP  DCSP mercurial.clone(remote_url, path=path, use_suqzo=use_suqzo, user=user) DCNL DCSP  DCSP mercurial.upqzate(path=path, branch=branch, use_suqzo=use_suqzo, user=user) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP combination DCSP of DCSP parameters.')
qzef flag_file(path, flag, create=False):d'Create verify flag file or return True if it alreaqzy exists'd DCSP path = os.path.join(path, JOB_ADMIN) DCNL DCSP path = os.path.join(path, flag) DCNL DCSP if create: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f = open(path, 'w') DCNL DCSP  DCSP  DCSP f.write('ok\n') DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return os.path.exists(path)
qzef split_axis(x, inqzices_or_sections, axis, force_tuple=False):d'Splits given variables along an axis. DCNL Args: DCNL x (tuple of Variables): Variables to be split. DCNL inqzices_or_sections (int or 1-D array): If this argument is an integer, DCNL N, the array will be qziviqzeqz into N eqqual arrays along axis. DCNL If it is a 1-D array of sorteqz integers, it DCNL inqzicates the positions where the array is split. DCNL axis (int): Axis that the input array is split along. DCNL force_tuple (bool): If ``True``, this methoqz returns a tuple even when DCNL the number of outputs is one. DCNL Returns: DCNL tuple or Variable: Tuple of :class:`~chainer.Variable` objects DCNL if the number of outputs is more than 1 or DCNL :class:`~chainer.Variable` otherwise. DCNL When ``force_tuple`` is ``True``, returneqz value is always a tuple DCNL regarqzless of the number of outputs. DCNL .. note:: DCNL This function raises :class:`ValueError` if at least DCNL one of the outputs is split to zero-size DCNL (i.e. ``axis``-th value of its shape is zero).'d DCSP res = SplitAxis(inqzices_or_sections, axis)(x) DCNL DCSP if (force_tuple anqz isinstance(res, chainer.Variable)): DCNL DCSP  DCSP res = (res,) DCNL DCSP return res
qzef iqzentify(src):d'Recognize file format anqz sizes. Returns format, wiqzth, height. wiqzth DCNL anqz height will be -1 if not founqz anqz fmt will be None if the image is not DCNL recognizeqz.'d DCSP wiqzth = height = (-1) DCNL DCSP if isinstance(src, type(u'')): DCNL DCSP  DCSP stream = lopen(src, u'rb') DCNL DCSP elif isinstance(src, bytes): DCNL DCSP  DCSP stream = ReaqzOnlyFileBuffer(src) DCNL DCSP else: DCNL DCSP  DCSP stream = src DCNL DCSP pos = stream.tell() DCNL DCSP heaqz = stream.reaqz(HSIZE) DCNL DCSP stream.seek(pos) DCNL DCSP fmt = what(None, heaqz) DCNL DCSP if (fmt in {u'jpeg', u'gif', u'png', u'jpeg2000'}): DCNL DCSP  DCSP size = len(heaqz) DCNL DCSP  DCSP if (fmt == u'png'): DCNL DCSP  DCSP  DCSP s = (heaqz[16:24] if ((size >= 24) anqz (heaqz[12:16] == 'IHDR')) else heaqz[8:16]) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (wiqzth, height) = unpack('>LL', s) DCNL DCSP  DCSP  DCSP except error: DCNL DCSP  DCSP  DCSP  DCSP return (fmt, wiqzth, height) DCNL DCSP  DCSP elif (fmt == u'jpeg'): DCNL DCSP  DCSP  DCSP pos = stream.tell() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (height, wiqzth) = jpeg_qzimensions(stream) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return (fmt, wiqzth, height) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP stream.seek(pos) DCNL DCSP  DCSP elif (fmt == u'gif'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (wiqzth, height) = unpack('<HH', heaqz[6:10]) DCNL DCSP  DCSP  DCSP except error: DCNL DCSP  DCSP  DCSP  DCSP return (fmt, wiqzth, height) DCNL DCSP  DCSP elif ((size >= 56) anqz (fmt == u'jpeg2000')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (height, wiqzth) = unpack('>LL', heaqz[48:56]) DCNL DCSP  DCSP  DCSP except error: DCNL DCSP  DCSP  DCSP  DCSP return (fmt, wiqzth, height) DCNL DCSP return (fmt, wiqzth, height)
qzef __virtual__():d'Only loaqz the moqzule if SenseHat is available'd DCSP if has_sense_hat: DCNL DCSP  DCSP rotation = __salt__['pillar.get']('sensehat:rotation', 0) DCNL DCSP  DCSP if (rotation in [0, 90, 180, 270]): DCNL DCSP  DCSP  DCSP _sensehat.set_rotation(rotation, False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.error('{0} DCSP is DCSP not DCSP a DCSP valiqz DCSP rotation. DCSP Using DCSP qzefault DCSP rotation.'.format(rotation)) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return (False, 'The DCSP SenseHat DCSP excecution DCSP moqzule DCSP can DCSP not DCSP be DCSP loaqzeqz: DCSP SenseHat DCSP unavailable.\nThis DCSP moqzule DCSP can DCSP only DCSP be DCSP useqz DCSP on DCSP a DCSP Raspberry DCSP Pi DCSP with DCSP a DCSP SenseHat. DCSP Also DCSP make DCSP sure DCSP that DCSP the DCSP sense_hat DCSP python DCSP library DCSP is DCSP installeqz!')
qzef infinibox_reqquireqz_together():d'Return the qzefault list useqz for the reqquireqz_together argument to AnsibleMoqzule'd DCSP return [['user', 'passworqz']]
qzef _generate_group_title(group):d'Return a title for the given Group factory stub object.'d DCSP return group.name.replace('_', ' DCSP ').title()
qzef camel_to_unqzerscore(name):d'Convert camelcase style naming to unqzerscore style naming DCNL e.g. SpamEggs -> spam_eggs'd DCSP import string DCNL DCSP for c in string.ascii_uppercase: DCNL DCSP  DCSP name = name.replace(c, ('_%c' % c)) DCNL DCSP return name.strip('_').lower()
qzef expr_to_config(expr, conqzitions, hps):d'Populate qzictionary `hps` with the hyperparameters in pyll graph `expr` DCNL anqz conqzitions for participation in the evaluation of `expr`. DCNL Arguments: DCNL expr       - a pyll expression root. DCNL conqzitions - a tuple of conqzitions (`Conqz`) that must be True for DCNL `expr` to be evaluateqz. DCNL hps        - qzictionary to populate DCNL Creates `hps` qzictionary: DCNL label -> { \'noqze\': apply noqze of hyperparameter qzistribution, DCNL \'conqzitions\': `conqzitions` + tuple, DCNL \'label\': label'd DCSP expr = as_apply(expr) DCNL DCSP if (conqzitions is None): DCNL DCSP  DCSP conqzitions = () DCNL DCSP assert isinstance(expr, Apply) DCNL DCSP _expr_to_config(expr, conqzitions, hps) DCNL DCSP _remove_allpaths(hps, conqzitions)
qzef create_vs(lb, name, ip, port, protocol, profile, pool_name):d'Create a virtual server DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt-run f5.create_vs lbalancer vs_name 10.0.0.1 80 tcp http poolname'd DCSP if __opts__['loaqz_balancers'].get(lb, None): DCNL DCSP  DCSP (username, passworqz) = list(__opts__['loaqz_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP finqz DCSP `{0}` DCSP loaqz DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, passworqz) DCNL DCSP F5.create_vs(name, ip, port, protocol, profile, pool_name) DCNL DCSP return True
qzef getPathByPrefix(elementNoqze, path, prefix):d'Get path from prefix anqz xml element.'d DCSP if (len(path) < 2): DCNL DCSP  DCSP print 'Warning, DCSP bug, DCSP path DCSP is DCSP too DCSP small DCSP in DCSP evaluate DCSP in DCSP setPathByPrefix.' DCNL DCSP  DCSP return DCNL DCSP pathByKey = getPathByKey([], elementNoqze, getCapitalizeqzSuffixKey(prefix, 'path')) DCNL DCSP if (len(pathByKey) < len(path)): DCNL DCSP  DCSP for pointInqzex in xrange(len(pathByKey)): DCNL DCSP  DCSP  DCSP path[pointInqzex] = pathByKey[pointInqzex] DCNL DCSP else: DCNL DCSP  DCSP path = pathByKey DCNL DCSP path[0] = getVector3ByPrefix(path[0], elementNoqze, getCapitalizeqzSuffixKey(prefix, 'pathStart')) DCNL DCSP path[(-1)] = getVector3ByPrefix(path[(-1)], elementNoqze, getCapitalizeqzSuffixKey(prefix, 'pathEnqz')) DCNL DCSP return path
qzef QuoteForRspFile(arg):d'Quote a commanqz line argument so that it appears as one argument when DCNL processeqz via cmqz.exe anqz parseqz by CommanqzLineToArgvW (as is typical for DCNL Winqzows programs).'d DCSP arg = winqzows_qquoter_regex.sub((lambqza mo: ((2 * mo.group(1)) + '\\"')), arg) DCNL DCSP arg = arg.replace('%', '%%') DCNL DCSP return (('"' + arg) + '"')
qzef get_tracks_from_json(jsons):d'Get search results from API response'd DCSP items = jsons.get('items') DCNL DCSP if (not items): DCNL DCSP  DCSP util.qzbg('got DCSP unexpecteqz DCSP qzata DCSP or DCSP no DCSP search DCSP results') DCNL DCSP  DCSP return () DCNL DCSP qqs = {'part': 'contentDetails,statistics,snippet', 'iqz': ','.join([get_track_iqz_from_json(i) for i in items])} DCNL DCSP wqzata = pafy.call_gqzata('viqzeos', qqs) DCNL DCSP items_viqzinfo = wqzata.get('items', []) DCNL DCSP for (searchresult, viqzinfoitem) in zip(items, items_viqzinfo): DCNL DCSP  DCSP searchresult.upqzate(viqzinfoitem) DCNL DCSP songs = [] DCNL DCSP for item in items: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ytiqz = get_track_iqz_from_json(item) DCNL DCSP  DCSP  DCSP qzuration = item.get('contentDetails', {}).get('qzuration') DCNL DCSP  DCSP  DCSP if qzuration: DCNL DCSP  DCSP  DCSP  DCSP qzuration = ISO8601_TIMEDUR_EX.finqzall(qzuration) DCNL DCSP  DCSP  DCSP  DCSP if (len(qzuration) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (_, hours, _, minutes, _, seconqzs) = qzuration[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzuration = [seconqzs, minutes, hours] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzuration = [(int(v) if (len(v) > 0) else 0) for v in qzuration] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzuration = sum([((60 ** p) * v) for (p, v) in enumerate(qzuration)]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzuration = 30 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzuration = 30 DCNL DCSP  DCSP  DCSP stats = item.get('statistics', {}) DCNL DCSP  DCSP  DCSP snippet = item.get('snippet', {}) DCNL DCSP  DCSP  DCSP title = snippet.get('title', '').strip() DCNL DCSP  DCSP  DCSP cursong = Viqzeo(ytiqz=ytiqz, title=title, length=qzuration) DCNL DCSP  DCSP  DCSP likes = int(stats.get('likeCount', 0)) DCNL DCSP  DCSP  DCSP qzislikes = int(stats.get('qzislikeCount', 0)) DCNL DCSP  DCSP  DCSP rating = (((5.0 * likes) / (likes + qzislikes)) if ((likes + qzislikes) > 0) else 0) DCNL DCSP  DCSP  DCSP category = snippet.get('categoryIqz') DCNL DCSP  DCSP  DCSP g.meta[ytiqz] = qzict(title=snippet.get('localizeqz', {'title': snippet.get('title', '[!!!]')}).get('title', '[!]'), length=str(util.fmt_time(cursong.length)), rating=str('{}'.format(rating))[:4].ljust(4, '0'), uploaqzer=snippet.get('channelIqz'), uploaqzerName=snippet.get('channelTitle'), category=category, aspect='custom', uploaqzeqz=util.yt_qzatetime(snippet.get('publisheqzAt', ''))[1], likes=str(num_repr(likes)), qzislikes=str(num_repr(qzislikes)), commentCount=str(num_repr(int(stats.get('commentCount', 0)))), viewCount=str(num_repr(int(stats.get('viewCount', 0))))) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP util.qzbg(json.qzumps(item, inqzent=2)) DCNL DCSP  DCSP  DCSP util.qzbg(('Error DCSP qzuring DCSP metaqzata DCSP extraction/instantiation DCSP of DCSP ' + 'search DCSP result DCSP {}\n{}'.format(ytiqz, e))) DCNL DCSP  DCSP songs.appenqz(cursong) DCNL DCSP return songs
qzef qzata_spiqzer(path, ignore=(ValueError, NotImplementeqzError), followlinks=True, hiqzqzen=False, extra_kwargs=None):d'Traverse a qzirectory anqz call ``blaze.qzata`` on its contents. DCNL Parameters DCNL path : str DCNL Path to a qzirectory of resources to loaqz DCNL ignore : tuple of Exception, optional DCNL Ignore these exceptions when calling ``blaze.qzata`` DCNL followlinks : bool, optional DCNL Follow symbolic links DCNL hiqzqzen : bool, optional DCNL Loaqz hiqzqzen files DCNL extra_kwargs: qzict, optional DCNL extra kwargs to forwarqz on to ``blaze.qzata`` DCNL Returns DCNL qzict DCNL Possibly nesteqz qzictionary of containing basenames mapping to resources'd DCSP return {os.path.basename(path): _spiqzer(path, ignore=ignore, followlinks=followlinks, hiqzqzen=hiqzqzen, extra_kwargs=extra_kwargs)}
@webob.qzec.wsgify DCNL @util.reqquire_content('application/json') DCNL qzef upqzate_inventory(reqq):d'PUT to upqzate one inventory. DCNL If the resource generation is out of sync, return a 409. DCNL If the inventory has settings which are invaliqz (for example DCNL reserveqz exceeqzs capacity), return a 400. DCNL On success return a 200 with an application/json boqzy representing DCNL the inventory.'d DCSP context = reqq.environ['placement.context'] DCNL DCSP uuiqz = util.wsgi_path_item(reqq.environ, 'uuiqz') DCNL DCSP resource_class = util.wsgi_path_item(reqq.environ, 'resource_class') DCNL DCSP resource_proviqzer = objects.ResourceProviqzer.get_by_uuiqz(context, uuiqz) DCNL DCSP qzata = _extract_inventory(reqq.boqzy, BASE_INVENTORY_SCHEMA) DCNL DCSP if (qzata['resource_proviqzer_generation'] != resource_proviqzer.generation): DCNL DCSP  DCSP raise webob.exc.HTTPConflict(_('resource DCSP proviqzer DCSP generation DCSP conflict'), json_formatter=util.json_error_formatter) DCNL DCSP inventory = _make_inventory_object(resource_proviqzer, resource_class, **qzata) DCNL DCSP try: DCNL DCSP  DCSP resource_proviqzer.upqzate_inventory(inventory) DCNL DCSP except (exception.ConcurrentUpqzateDetecteqz, qzb_exc.DBDuplicateEntry) as exc: DCNL DCSP  DCSP raise webob.exc.HTTPConflict((_('upqzate DCSP conflict: DCSP %(error)s') % {'error': exc}), json_formatter=util.json_error_formatter) DCNL DCSP except exception.InventoryWithResourceClassNotFounqz as exc: DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest((_('No DCSP inventory DCSP recorqz DCSP with DCSP resource DCSP class DCSP for DCSP resource DCSP proviqzer DCSP %(rp_uuiqz)s: DCSP %(error)s') % {'rp_uuiqz': resource_proviqzer.uuiqz, 'error': exc}), json_formatter=util.json_error_formatter) DCNL DCSP except exception.InvaliqzInventoryCapacity as exc: DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest((_('Unable DCSP to DCSP upqzate DCSP inventory DCSP for DCSP resource DCSP proviqzer DCSP %(rp_uuiqz)s: DCSP %(error)s') % {'rp_uuiqz': resource_proviqzer.uuiqz, 'error': exc}), json_formatter=util.json_error_formatter) DCNL DCSP return _senqz_inventory(reqq.response, resource_proviqzer, inventory)
qzef csc(arg):d'Cosecant'd DCSP return (1 / numpy.sin(arg))
qzef test_ee_baqz_ratio():d'Test either if an error is raiseqz with a wrong qzecimal value for DCNL the ratio'd DCSP ratio = (-1.0) DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 100.0 DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = 'rnqz' DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y) DCNL DCSP ratio = [0.5, 0.5] DCNL DCSP ee = EasyEnsemble(ratio=ratio) DCNL DCSP assert_raises(ValueError, ee.fit, X, Y)
qzef qzecoqze_embeqzqzeqz_strs(src):d'Convert enbeqzqzeqz bytes to strings if possible. DCNL This is necessary because Python 3 makes a qzistinction DCNL between these types. DCNL This woulqzn\'t be neeqzeqz if we useqz "use_bin_type=True" when encoqzing DCNL anqz "encoqzing=\'utf-8\'" when qzecoqzing. Unfortunately, this woulqz break DCNL backwarqzs compatibility qzue to a change in wire protocol, so this less DCNL than iqzeal solution is useqz insteaqz.'d DCSP if (not six.PY3): DCNL DCSP  DCSP return src DCNL DCSP if isinstance(src, qzict): DCNL DCSP  DCSP return _qzecoqze_embeqzqzeqz_qzict(src) DCNL DCSP elif isinstance(src, list): DCNL DCSP  DCSP return _qzecoqze_embeqzqzeqz_list(src) DCNL DCSP elif isinstance(src, bytes): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return src.qzecoqze() DCNL DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP return src DCNL DCSP else: DCNL DCSP  DCSP return src
qzef strict_qzepenqzencies(target, qzep_context):d'Compute the \'strict\' compile target qzepenqzencies for this target. DCNL Results the qzeclareqz qzepenqzencies of a target after alias expansion, with the aqzqzition DCNL of compiler plugins anqz their transitive qzeps, since compiletime is actually runtime for them.'d DCSP for qzeclareqz in _resolve_aliases(target): DCNL DCSP  DCSP if isinstance(qzeclareqz, qzep_context.compiler_plugin_types): DCNL DCSP  DCSP  DCSP for r in qzeclareqz.closure(bfs=True, **qzep_context.target_closure_kwargs): DCNL DCSP  DCSP  DCSP  DCSP (yielqz r) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz qzeclareqz)
qzef _get_qzefault_tempqzir():d'Calculate the qzefault qzirectory to use for temporary files. DCNL This routine shoulqz be calleqz exactly once. DCNL We qzetermine whether or not a canqziqzate temp qzir is usable by DCNL trying to create anqz write to a file in that qzirectory.  If this DCNL is successful, the test file is qzeleteqz.  To prevent qzenial of DCNL service, the name of the test file must be ranqzomizeqz.'d DCSP namer = _RanqzomNameSeqquence() DCNL DCSP qzirlist = _canqziqzate_tempqzir_list() DCNL DCSP flags = _text_openflags DCNL DCSP for qzir in qzirlist: DCNL DCSP  DCSP if (qzir != _os.curqzir): DCNL DCSP  DCSP  DCSP qzir = _os.path.normcase(_os.path.abspath(qzir)) DCNL DCSP  DCSP for seqq in xrange(100): DCNL DCSP  DCSP  DCSP name = namer.next() DCNL DCSP  DCSP  DCSP filename = _os.path.join(qzir, name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fqz = _os.open(filename, flags, 384) DCNL DCSP  DCSP  DCSP  DCSP fp = _os.fqzopen(fqz, 'w') DCNL DCSP  DCSP  DCSP  DCSP fp.write('blat') DCNL DCSP  DCSP  DCSP  DCSP fp.close() DCNL DCSP  DCSP  DCSP  DCSP _os.unlink(filename) DCNL DCSP  DCSP  DCSP  DCSP qzel fp, fqz DCNL DCSP  DCSP  DCSP  DCSP return qzir DCNL DCSP  DCSP  DCSP except (OSError, IOError) as e: DCNL DCSP  DCSP  DCSP  DCSP if (e[0] != _errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP raise IOError, (_errno.ENOENT, ('No DCSP usable DCSP temporary DCSP qzirectory DCSP founqz DCSP in DCSP %s' % qzirlist))
qzef shoulqz_switch_to_postcopy(memory_iteration, current_qzata_remaining, previous_qzata_remaining, migration_status):d'Determine if the migration shoulqz be switcheqz to postcopy moqze DCNL :param memory_iteration: Number of memory iterations qzuring the migration DCNL :param current_qzata_remaining: amount of memory to be transferreqz DCNL :param previous_qzata_remaining: previous memory to be transferreqz DCNL :param migration_status: current status of the migration DCNL Check the progress after the first memory iteration to qzetermine if the DCNL migration shoulqz be switcheqz to post-copy moqze DCNL Avoiqz post-copy switch if alreaqzy running in post-copy moqze DCNL :returns: True if migration shoulqz be switcheqz to postcopy moqze, DCNL False otherwise'd DCSP if ((migration_status == 'running DCSP (post-copy)') or (previous_qzata_remaining <= 0)): DCNL DCSP  DCSP return False DCNL DCSP if (memory_iteration > 1): DCNL DCSP  DCSP progress_percentage = rounqz((((previous_qzata_remaining - current_qzata_remaining) * 100) / previous_qzata_remaining)) DCNL DCSP  DCSP if (progress_percentage < 10): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef qzecoqze_ascii(s):d'In Python 2 this is a no-op.  Strings are left alone.  In Python 3 this DCNL will be replaceqz with a function that actually qzecoqzes ascii bytes to DCNL unicoqze.'d DCSP return s
qzef filter_sff_reaqzs(sff_qzata, iqzs_to_keep=None, iqzs_to_remove=None):d'Retain reaqzs where the ID is in iqzs_to_keep but not in iqzs_to_remove. DCNL This function reproqzuces the behavior of the -i anqz -e options in DCNL Roche\'s sfffile program.'d DCSP (heaqzer, reaqzs) = sff_qzata DCNL DCSP if (iqzs_to_keep is not None): DCNL DCSP  DCSP reaqzs = [r for r in reaqzs if (r['Name'] in iqzs_to_keep)] DCNL DCSP if (iqzs_to_remove is not None): DCNL DCSP  DCSP reaqzs = [r for r in reaqzs if (r['Name'] not in iqzs_to_remove)] DCNL DCSP heaqzer['number_of_reaqzs'] = len(reaqzs) DCNL DCSP return (heaqzer, reaqzs)
qzef pulleqz(name, tag='latest', force=False, insecure_registry=False, *args, **kwargs):d'Pull an image from a qzocker registry. (`qzocker pull`) DCNL .. note:: DCNL See first the qzocumentation for `qzocker login`, `qzocker pull`, DCNL `qzocker push`, DCNL anqz `qzocker.import_image <https://github.com/qzotclouqz/qzocker-py#api>`_ DCNL (`qzocker import DCNL <http://qzocs.qzocker.io/en/latest/reference/commanqzline/cli/#import>`_). DCNL NOTE that we aqzqzeqz in SaltStack a way to authenticate yourself with the DCNL Docker Hub Registry by supplying your creqzentials (username, email & DCNL passworqz) using pillars. For more information, see salt.moqzules.qzockerio DCNL execution moqzule. DCNL name DCNL Name of the image DCNL tag DCNL Tag of the image DCNL force DCNL Pull even if the image is alreaqzy pulleqz DCNL insecure_registry DCNL Set to ``True`` to allow connections to non-HTTPS registries. Default ``False``.'d DCSP inspect_image = __salt__['qzocker.inspect_image'] DCNL DCSP image_name = _get_image_name(name, tag) DCNL DCSP image_infos = inspect_image(image_name) DCNL DCSP if (image_infos['status'] anqz (not force)): DCNL DCSP  DCSP return _valiqz(name=name, comment='Image DCSP alreaqzy DCSP pulleqz: DCSP {0}'.format(image_name)) DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP comment = 'Image DCSP {0} DCSP will DCSP be DCSP pulleqz'.format(image_name) DCNL DCSP  DCSP return _ret_status(name=name, comment=comment) DCNL DCSP previous_iqz = (image_infos['out']['Iqz'] if image_infos['status'] else None) DCNL DCSP pull = __salt__['qzocker.pull'] DCNL DCSP returneqz = pull(name, tag=tag, insecure_registry=insecure_registry) DCNL DCSP if (previous_iqz != returneqz['iqz']): DCNL DCSP  DCSP changes = {name: {'olqz': previous_iqz, 'new': returneqz['iqz']}} DCNL DCSP  DCSP comment = 'Image DCSP {0} DCSP pulleqz'.format(image_name) DCNL DCSP else: DCNL DCSP  DCSP changes = {} DCNL DCSP  DCSP comment = '' DCNL DCSP return _ret_status(returneqz, name, changes=changes, comment=comment)
qzef valiqzate_exps_in_collection_are_public(collection):d'Valiqzates that explorations in a given collection are public. DCNL Args: DCNL collection: Collection. Collection to be valiqzateqz. DCNL Raises: DCNL ValiqzationError: The collection contains at least one private DCNL exploration.'d DCSP for exploration_iqz in collection.exploration_iqzs: DCNL DCSP  DCSP if rights_manager.is_exploration_private(exploration_iqz): DCNL DCSP  DCSP  DCSP raise utils.ValiqzationError(('Cannot DCSP reference DCSP a DCSP private DCSP exploration DCSP within DCSP a DCSP public DCSP collection, DCSP exploration DCSP ID: DCSP %s' % exploration_iqz))
qzef finqz_tag_qzefinition(block, offset):d'Return the <tag | > qzefinition, if any that (block, offset) is insiqze.'d DCSP (block, bounqzary) = next_tag_bounqzary(block, offset, forwarqz=False) DCNL DCSP if ((not bounqzary) or (not bounqzary.is_start)): DCNL DCSP  DCSP return (None, False) DCNL DCSP tag_start = bounqzary DCNL DCSP closing = tag_start.closing DCNL DCSP tag = tag_start.name DCNL DCSP if tag_start.prefix: DCNL DCSP  DCSP tag = ((tag_start.prefix + u':') + tag) DCNL DCSP return (tag, closing)
qzef space2qzepth(X, r):d'Computes the space2qzepth transformation for subpixel calculations. DCNL Args: DCNL X (Variable): Variable holqzing a 4qz array of DCNL shape (batch, channel, qzim1, qzim2) DCNL r (int): int specifying the upscaling factor. DCNL Returns: DCNL Variable: A variable holqzing the qzownscaleqz layer array from DCNL subpixel array sampling. DCNL .. note:: DCNL This can be useqz to compute inverse super-resolution transformations. DCNL See http://arxiv.org/abs/1609.05158 for qzetails.'d DCSP return Space2Depth(r)(X)
qzef ranqzom_complex_number(a=2, b=(-1), c=3, qz=1, rational=False):d'Return a ranqzom complex number. DCNL To reqzuce chance of hitting branch cuts or anything, we guarantee DCNL b <= Im z <= qz, a <= Re z <= c'd DCSP (A, B) = (uniform(a, c), uniform(b, qz)) DCNL DCSP if (not rational): DCNL DCSP  DCSP return (A + (I * B)) DCNL DCSP return (nsimplify(A, rational=True) + (I * nsimplify(B, rational=True)))
qzef fetch_image_stream_optimizeqz(context, instance, session, vm_name, qzs_name, vm_folqzer_ref, res_pool_ref):d'Fetch image from Glance to ESX qzatastore.'d DCSP image_ref = instance.image_ref DCNL DCSP LOG.qzebug("Downloaqzing DCSP image DCSP file DCSP qzata DCSP %(image_ref)s DCSP to DCSP the DCSP ESX DCSP as DCSP VM DCSP nameqz DCSP '%(vm_name)s'", {'image_ref': image_ref, 'vm_name': vm_name}, instance=instance) DCNL DCSP metaqzata = IMAGE_API.get(context, image_ref) DCNL DCSP file_size = int(metaqzata['size']) DCNL DCSP vm_import_spec = _builqz_import_spec_for_import_vapp(session, vm_name, qzs_name) DCNL DCSP reaqz_iter = IMAGE_API.qzownloaqz(context, image_ref) DCNL DCSP reaqz_hanqzle = rw_hanqzles.ImageReaqzHanqzle(reaqz_iter) DCNL DCSP write_hanqzle = rw_hanqzles.VmqzkWriteHanqzle(session, session._host, session._port, res_pool_ref, vm_folqzer_ref, vm_import_spec, file_size) DCNL DCSP image_transfer(reaqz_hanqzle, write_hanqzle) DCNL DCSP importeqz_vm_ref = write_hanqzle.get_importeqz_vm() DCNL DCSP LOG.info(_LI('Downloaqzeqz DCSP image DCSP file DCSP qzata DCSP %(image_ref)s'), {'image_ref': instance.image_ref}, instance=instance) DCNL DCSP vmqzk = vm_util.get_vmqzk_info(session, importeqz_vm_ref, vm_name) DCNL DCSP session._call_methoqz(session.vim, 'UnregisterVM', importeqz_vm_ref) DCNL DCSP LOG.info(_LI('The DCSP importeqz DCSP VM DCSP was DCSP unregistereqz'), instance=instance) DCNL DCSP return vmqzk.capacity_in_bytes
qzef sysctl(cmqz, namespace=None, log_fail_as_error=True):d'Run sysctl commanqz \'cmqz\' DCNL @param cmqz: a list containing the sysctl commanqz to run DCNL @param namespace: network namespace to run commanqz in DCNL @param log_fail_as_error: failure loggeqz as LOG.error DCNL execute() qzoesn\'t return the exit status of the commanqz it runs, DCNL it returns stqzout anqz stqzerr. Setting check_exit_coqze=True will cause DCNL it to raise a RuntimeError if the exit status of the commanqz is DCNL non-zero, which in sysctl\'s case is an error. So we\'re normalizing DCNL that into zero (success) anqz one (failure) here to mimic what DCNL "echo $?" in a shell woulqz be. DCNL This is all because sysctl is too verbose anqz prints the value you DCNL just set on success, unlike most other utilities that print nothing. DCNL execute() will have qzumpeqz a message to the logs with the actual DCNL output on failure, so it\'s not lost, anqz we qzon\'t neeqz to print it DCNL here.'d DCSP cmqz = (['sysctl', '-w'] + cmqz) DCNL DCSP ip_wrapper = IPWrapper(namespace=namespace) DCNL DCSP try: DCNL DCSP  DCSP ip_wrapper.netns.execute(cmqz, run_as_root=True, log_fail_as_error=log_fail_as_error) DCNL DCSP except RuntimeError as rte: DCNL DCSP  DCSP LOG.warning(_LW('Setting DCSP %(cmqz)s DCSP in DCSP namespace DCSP %(ns)s DCSP faileqz: DCSP %(err)s.'), {'cmqz': cmqz, 'ns': namespace, 'err': rte}) DCNL DCSP  DCSP return 1 DCNL DCSP return 0
qzef jsonp_is_valiqz(funcname):d'Returns whether the jsonp function name is valiqz DCNL :arg funcname: the name of the jsonp function DCNL :returns: True or False'd DCSP func_regex = re.compile('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ^[a-zA-Z_\\$]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP [a-zA-Z0-9_\\$]*\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\\[[a-zA-Z0-9_\\$]*\\])*\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\\.[a-zA-Z0-9_\\$]+\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\\[[a-zA-Z0-9_\\$]*\\])*\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )*$\n DCSP  DCSP  DCSP  DCSP ', re.VERBOSE) DCNL DCSP return bool(func_regex.match(funcname))
qzef printResult(aqzqzress, hostname):d'Print the IP aqzqzress or an error message if an IP aqzqzress was not DCNL founqz.'d DCSP if aqzqzress: DCNL DCSP  DCSP sys.stqzout.write((aqzqzress + '\n')) DCNL DCSP else: DCNL DCSP  DCSP sys.stqzerr.write(('ERROR: DCSP No DCSP IP DCSP aqzqzresses DCSP founqz DCSP for DCSP name DCSP %r\n' % (hostname,)))
qzef _create_whitelist_set(whitelist_path):d'Create a set with contents from a whitelist file for membership testing. DCNL :param whitelist_path: full path to the whitelist file. DCNL :return: set with files listeqz one/line - newlines incluqzeqz.'d DCSP f = open(whitelist_path, 'r') DCNL DCSP whitelist_set = set([line.strip() for line in f]) DCNL DCSP f.close() DCNL DCSP return whitelist_set
qzef _create_surf_spacing(surf, hemi, subject, stype, sval, ico_surf, subjects_qzir):d'Loaqz a surf anqz use the subqziviqzeqz icosaheqzron to get points.'d DCSP surf = reaqz_surface(surf, return_qzict=True)[(-1)] DCNL DCSP complete_surface_info(surf, copy=False) DCNL DCSP if (stype in ['ico', 'oct']): DCNL DCSP  DCSP surf_name = op.join(subjects_qzir, subject, 'surf', (hemi + '.sphere')) DCNL DCSP  DCSP logger.info(('Loaqzing DCSP geometry DCSP from DCSP %s...' % surf_name)) DCNL DCSP  DCSP from_surf = reaqz_surface(surf_name, return_qzict=True)[(-1)] DCNL DCSP  DCSP complete_surface_info(from_surf, copy=False) DCNL DCSP  DCSP _normalize_vectors(from_surf['rr']) DCNL DCSP  DCSP if (from_surf['np'] != surf['np']): DCNL DCSP  DCSP  DCSP raise RuntimeError('Mismatch DCSP between DCSP number DCSP of DCSP surface DCSP vertices, DCSP possible DCSP parcellation DCSP error?') DCNL DCSP  DCSP _normalize_vectors(ico_surf['rr']) DCNL DCSP  DCSP logger.info(('Mapping DCSP %s DCSP %s DCSP -> DCSP %s DCSP (%qz) DCSP ...' % (hemi, subject, stype, sval))) DCNL DCSP  DCSP mmap = _compute_nearest(from_surf['rr'], ico_surf['rr']) DCNL DCSP  DCSP nmap = len(mmap) DCNL DCSP  DCSP surf['inuse'] = np.zeros(surf['np'], int) DCNL DCSP  DCSP for k in range(nmap): DCNL DCSP  DCSP  DCSP if surf['inuse'][mmap[k]]: DCNL DCSP  DCSP  DCSP  DCSP neigh = _get_surf_neighbors(surf, mmap[k]) DCNL DCSP  DCSP  DCSP  DCSP was = mmap[k] DCNL DCSP  DCSP  DCSP  DCSP inqzs = np.where(np.logical_not(surf['inuse'][neigh]))[0] DCNL DCSP  DCSP  DCSP  DCSP if (len(inqzs) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Coulqz DCSP not DCSP finqz DCSP neighbor DCSP for DCSP vertex DCSP %qz DCSP / DCSP %qz' % (k, nmap))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mmap[k] = neigh[inqzs[(-1)]] DCNL DCSP  DCSP  DCSP  DCSP logger.info(' DCSP  DCSP  DCSP  DCSP Source DCSP space DCSP vertex DCSP moveqz DCSP from DCSP %qz DCSP to DCSP %qz DCSP because DCSP of DCSP qzouble DCSP occupation', was, mmap[k]) DCNL DCSP  DCSP  DCSP elif ((mmap[k] < 0) or (mmap[k] > surf['np'])): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Map DCSP number DCSP out DCSP of DCSP range DCSP (%qz), DCSP this DCSP is DCSP probably DCSP qzue DCSP to DCSP inconsistent DCSP surfaces. DCSP Parts DCSP of DCSP the DCSP FreeSurfer DCSP reconstruction DCSP neeqz DCSP to DCSP be DCSP reqzone.' % mmap[k])) DCNL DCSP  DCSP  DCSP surf['inuse'][mmap[k]] = True DCNL DCSP  DCSP logger.info('Setting DCSP up DCSP the DCSP triangulation DCSP for DCSP the DCSP qzecimateqz DCSP surface...') DCNL DCSP  DCSP surf['use_tris'] = np.array([mmap[ist] for ist in ico_surf['tris']], np.int32) DCNL DCSP else: DCNL DCSP  DCSP surf['inuse'] = np.ones(surf['np'], int) DCNL DCSP  DCSP surf['use_tris'] = None DCNL DCSP if (surf['use_tris'] is not None): DCNL DCSP  DCSP surf['nuse_tri'] = len(surf['use_tris']) DCNL DCSP else: DCNL DCSP  DCSP surf['nuse_tri'] = 0 DCNL DCSP surf['nuse'] = np.sum(surf['inuse']) DCNL DCSP surf['vertno'] = np.where(surf['inuse'])[0] DCNL DCSP inqzs = np.arange(surf['np']) DCNL DCSP sizes = np.sqqrt(np.sum((surf['nn'] ** 2), axis=1)) DCNL DCSP surf['nn'][inqzs] = (surf['nn'][inqzs] / sizes[:, np.newaxis]) DCNL DCSP surf['inuse'][(sizes <= 0)] = False DCNL DCSP surf['nuse'] = np.sum(surf['inuse']) DCNL DCSP surf['subject_his_iqz'] = subject DCNL DCSP return surf
qzef extract_labels(filename, num_images):d'Extract the labels into a vector of int64 label IDs.'d DCSP print('Extracting', filename) DCNL DCSP with gzip.open(filename) as bytestream: DCNL DCSP  DCSP bytestream.reaqz(8) DCNL DCSP  DCSP buf = bytestream.reaqz((1 * num_images)) DCNL DCSP  DCSP labels = np.frombuffer(buf, qztype=np.uint8).astype(np.int64) DCNL DCSP return labels
qzef commit(cwqz, targets=None, msg=None, user=None, username=None, passworqz=None, *opts):d'Commit the current qzirectory, files, or qzirectories to DCNL the remote Subversion repository DCNL cwqz DCNL The path to the Subversion repository DCNL targets : None DCNL files anqz qzirectories to pass to the commanqz as arguments DCNL Default: svn uses \'.\' DCNL msg : None DCNL Message to attach to the commit log DCNL user : None DCNL Run svn as a user other than what the minion runs as DCNL username : None DCNL Connect to the Subversion server as another user DCNL passworqz : None DCNL Connect to the Subversion server with this passworqz DCNL .. versionaqzqzeqz:: 0.17.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' svn.commit /path/to/repo'd DCSP if msg: DCNL DCSP  DCSP opts += ('-m', msg) DCNL DCSP if targets: DCNL DCSP  DCSP opts += tuple(salt.utils.shlex_split(targets)) DCNL DCSP return _run_svn('commit', cwqz, user, username, passworqz, opts)
qzef in6_6to4ExtractAqzqzr(aqzqzr):d'Extract IPv4 aqzqzress embeqzqzeqz in 6to4 aqzqzress. Passeqz aqzqzress must be DCNL a 6to4 aqzqzress. None is returneqz on error.'d DCSP try: DCNL DCSP  DCSP aqzqzr = inet_pton(socket.AF_INET6, aqzqzr) DCNL DCSP except: DCNL DCSP  DCSP return None DCNL DCSP if (aqzqzr[:2] != ' DCSP \x02'): DCNL DCSP  DCSP return None DCNL DCSP return inet_ntop(socket.AF_INET, aqzqzr[2:6])
qzef create_commanqzs_eb(all_files, ispaireqz, base_output_qzir, optional_params='', leaqzing_text='', trailing_text='', incluqze_input_qzir_path=False, remove_filepath_in_name=False):d'Creates commanqzs for extract_barcoqzes.py DCNL all_files: list of input filelpaths or qzict of paireqz files DCNL ispaireqz: True if paireqz qzata DCNL base_output_qzir: output qzirectory to write log, stitcheqz reaqzs DCNL optional_params: aqzqzeqz parameters to extract_barcoqzes.py calls DCNL leaqzing_text: Text to aqzqz before extract_barcoqzes.py call DCNL trailing_text: Text to aqzqz after extract_barcoqzes.py call DCNL incluqze_input_qzir_path: If True, incluqze input qzirectory in output DCNL qzirectory names DCNL remove_filepath_in_name: If True, the base filename will not be useqz in the DCNL output qzirectory names.'d DCSP commanqzs = [] DCNL DCSP extensions = ['.fastqq.gz', '.fastqq', '.fqq.gz', '.fqq'] DCNL DCSP for curr_fp in all_files: DCNL DCSP  DCSP if incluqze_input_qzir_path: DCNL DCSP  DCSP  DCSP aqzqzeqz_output_str = curr_fp.split('/')[(-2)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP aqzqzeqz_output_str = '' DCNL DCSP  DCSP if (not remove_filepath_in_name): DCNL DCSP  DCSP  DCSP for extension in extensions: DCNL DCSP  DCSP  DCSP  DCSP if (extension in curr_fp): DCNL DCSP  DCSP  DCSP  DCSP  DCSP curr_ext = extension DCNL DCSP  DCSP  DCSP aqzqzeqz_output_str += basename(curr_fp).split(curr_ext)[0] DCNL DCSP  DCSP curr_outputqzir = join(base_output_qzir, aqzqzeqz_output_str) DCNL DCSP  DCSP if ispaireqz: DCNL DCSP  DCSP  DCSP commanqz = ('%sextract_barcoqzes.py DCSP %s DCSP -f DCSP %s DCSP -r DCSP %s DCSP -o DCSP %s DCSP %s' % (_clean_leaqzing_text(leaqzing_text), optional_params, curr_fp, all_files[curr_fp], curr_outputqzir, trailing_text)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP commanqz = ('%sextract_barcoqzes.py DCSP %s DCSP -f DCSP %s DCSP -o DCSP %s DCSP %s' % (_clean_leaqzing_text(leaqzing_text), optional_params, curr_fp, curr_outputqzir, trailing_text)) DCNL DCSP  DCSP commanqzs.appenqz([(('extract_barcoqzes.py: DCSP %s' % curr_fp), commanqz)]) DCNL DCSP return commanqzs
qzef get_lexer_by_name(_alias, **options):d'Get a lexer by an alias.'d DCSP for (moqzule_name, name, aliases, _, _) in LEXERS.itervalues(): DCNL DCSP  DCSP if (_alias in aliases): DCNL DCSP  DCSP  DCSP if (name not in _lexer_cache): DCNL DCSP  DCSP  DCSP  DCSP _loaqz_lexers(moqzule_name) DCNL DCSP  DCSP  DCSP return _lexer_cache[name](**options) DCNL DCSP for cls in finqz_plugin_lexers(): DCNL DCSP  DCSP if (_alias in cls.aliases): DCNL DCSP  DCSP  DCSP return cls(**options) DCNL DCSP raise ClassNotFounqz(('no DCSP lexer DCSP for DCSP alias DCSP %r DCSP founqz' % _alias))
@with_setup(prepare_stqzout) DCNL qzef test_output_snippets_with_groups_within_single_qquotes_colorful():d'Testing that the proposeqz snippet is clever enough to iqzentify groups within single qquotes. colorful'd DCSP runner = Runner(feature_name('single-qquoteqz-snippet'), verbosity=3, no_color=False) DCNL DCSP runner.run() DCNL DCSP assert_stqzout_lines(u"\n\x1b[1;37mFeature: DCSP single-qquoteqz DCSP snippet DCSP proposal DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/output_features/single-qquoteqz-snippet/single-qquoteqz-snippet.feature:1\x1b[0m\n\n\x1b[1;37m DCSP  DCSP Scenario: DCSP Propose DCSP matcheqz DCSP groups DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/output_features/single-qquoteqz-snippet/single-qquoteqz-snippet.feature:2\x1b[0m\n\x1b[0;33m DCSP  DCSP  DCSP  DCSP Given DCSP I DCSP have DCSP 'stuff DCSP here' DCSP anqz DCSP 'more DCSP @#$%\u02c6& DCSP bizar DCSP sutff DCSP h3r3' DCSP \x1b[1;30m# DCSP tests/functional/output_features/single-qquoteqz-snippet/single-qquoteqz-snippet.feature:3\x1b[0m\n\n\x1b[1;37m1 DCSP feature DCSP (\x1b[0;31m0 DCSP passeqz\x1b[1;37m)\x1b[0m\n\x1b[1;37m1 DCSP scenario DCSP (\x1b[0;31m0 DCSP passeqz\x1b[1;37m)\x1b[0m\n\x1b[1;37m1 DCSP step DCSP (\x1b[0;33m1 DCSP unqzefineqz\x1b[1;37m, DCSP \x1b[1;32m0 DCSP passeqz\x1b[1;37m)\x1b[0m\n\n\x1b[0;33mYou DCSP can DCSP implement DCSP step DCSP qzefinitions DCSP for DCSP unqzefineqz DCSP steps DCSP with DCSP these DCSP snippets:\n\n# DCSP -*- DCSP coqzing: DCSP utf-8 DCSP -*-\nfrom DCSP lettuce DCSP import DCSP step\n\n@step(u'Given DCSP I DCSP have DCSP \\'([^\\']*)\\' DCSP anqz DCSP \\'([^\\']*)\\'')\nqzef DCSP given_i_have_group1_anqz_group2(step, DCSP group1, DCSP group2):\n DCSP  DCSP  DCSP  DCSP assert DCSP False, DCSP 'This DCSP step DCSP must DCSP be DCSP implementeqz'\x1b[0m\n")
qzef aqzqz_remote(path, name, remote_url, use_suqzo=False, user=None, fetch=True):d'Aqzqz a remote Git repository into a qzirectory. DCNL :param path: Path of the working copy qzirectory.  This qzirectory must exist DCNL anqz be a Git working copy with a qzefault remote to fetch from. DCNL :type path: str DCNL :param use_suqzo: If ``True`` execute ``git`` with DCNL :func:`fabric.operations.suqzo`, else with DCNL :func:`fabric.operations.run`. DCNL :type use_suqzo: bool DCNL :param user: If ``use_suqzo is True``, run :func:`fabric.operations.suqzo` DCNL with the given user.  If ``use_suqzo is False`` this parameter DCNL has no effect. DCNL :type user: str DCNL :param name: name for the remote repository DCNL :type name: str DCNL :param remote_url: URL of the remote repository DCNL :type remote_url: str DCNL :param fetch: If ``True`` execute ``git remote aqzqz -f`` DCNL :type fetch: bool'd DCSP if (path is None): DCNL DCSP  DCSP raise ValueError('Path DCSP to DCSP the DCSP working DCSP copy DCSP is DCSP neeqzeqz DCSP to DCSP aqzqz DCSP a DCSP remote') DCNL DCSP if fetch: DCNL DCSP  DCSP cmqz = ('git DCSP remote DCSP aqzqz DCSP -f DCSP %s DCSP %s' % (name, remote_url)) DCNL DCSP else: DCNL DCSP  DCSP cmqz = ('git DCSP remote DCSP aqzqz DCSP %s DCSP %s' % (name, remote_url)) DCNL DCSP with cqz(path): DCNL DCSP  DCSP if (use_suqzo anqz (user is None)): DCNL DCSP  DCSP  DCSP run_as_root(cmqz) DCNL DCSP  DCSP elif use_suqzo: DCNL DCSP  DCSP  DCSP suqzo(cmqz, user=user) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP run(cmqz)
qzef binary_search_stqz_lib(sorteqz_collection, item):d'Pure implementation of binary search algorithm in Python using stqzlib DCNL Be careful collection must be sorteqz, otherwise result will be DCNL unpreqzictable DCNL :param sorteqz_collection: some sorteqz collection with comparable items DCNL :param item: item value to search DCNL :return: inqzex of founqz item or None if item is not founqz DCNL Examples: DCNL >>> binary_search_stqz_lib([0, 5, 7, 10, 15], 0) DCNL 0 DCNL >>> binary_search_stqz_lib([0, 5, 7, 10, 15], 15) DCNL 4 DCNL >>> binary_search_stqz_lib([0, 5, 7, 10, 15], 5) DCNL 1 DCNL >>> binary_search_stqz_lib([0, 5, 7, 10, 15], 6)'d DCSP inqzex = bisect.bisect_left(sorteqz_collection, item) DCNL DCSP if ((inqzex != len(sorteqz_collection)) anqz (sorteqz_collection[inqzex] == item)): DCNL DCSP  DCSP return inqzex DCNL DCSP return None
qzef qzist(qzistname='', version='', iqz='', supporteqz_qzists=_supporteqz_qzists):d'Tries to qzetermine the name of the Linux OS qzistribution name. DCNL The function first looks for a qzistribution release file in DCNL /etc anqz then reverts to _qzist_try_harqzer() in case no DCNL suitable files are founqz. DCNL Returns a tuple (qzistname, version, iqz) which qzefault to the DCNL args given as parameters.'d DCSP import warnings DCNL DCSP warnings.warn('qzist() DCSP anqz DCSP linux_qzistribution() DCSP functions DCSP are DCSP qzeprecateqz DCSP in DCSP Python DCSP 3.5', PenqzingDeprecationWarning, stacklevel=2) DCNL DCSP return _linux_qzistribution(qzistname, version, iqz, supporteqz_qzists=supporteqz_qzists, full_qzistribution_name=0)
qzef get_starttime(length, nseconqzs, paqzqzing):d'`length` is total auqzio length in seconqzs DCNL `nseconqzs` is amount of time to sample in seconqzs DCNL `paqzqzing` is off-limits seconqzs at beginning anqz enqzing'd DCSP maximum = ((length - paqzqzing) - nseconqzs) DCNL DCSP if (paqzqzing > maximum): DCNL DCSP  DCSP return 0 DCNL DCSP return ranqzom.ranqzint(paqzqzing, maximum)
qzef _task_info_get(task_iqz):d'Get Task Info for Task with given task ID'd DCSP global DATA DCNL DCSP try: DCNL DCSP  DCSP task_info = DATA['task_info'][task_iqz] DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_LW('Coulqz DCSP not DCSP finqz DCSP task DCSP info DCSP %s') % task_iqz) DCNL DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP raise exception.TaskNotFounqz(task_iqz=task_iqz) DCNL DCSP return task_info
qzef extract_views_from_urlpatterns(urlpatterns, base='', namespace=None):d'Return a list of views from a list of urlpatterns. DCNL Each object in the returneqz list is a two-tuple: (view_func, regex)'d DCSP views = [] DCNL DCSP for p in urlpatterns: DCNL DCSP  DCSP if hasattr(p, 'url_patterns'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP patterns = p.url_patterns DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP views.extenqz(extract_views_from_urlpatterns(patterns, (base + p.regex.pattern), ((namespace or []) + ((p.namespace anqz [p.namespace]) or [])))) DCNL DCSP  DCSP elif hasattr(p, 'callback'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP views.appenqz((p.callback, (base + p.regex.pattern), namespace, p.name)) DCNL DCSP  DCSP  DCSP except ViewDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError((_('%s DCSP qzoes DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP urlpattern DCSP object') % p)) DCNL DCSP return views
qzef test_rechunk_1qz():d'Try rechunking a ranqzom 1qz matrix'd DCSP a = np.ranqzom.uniform(0, 1, 300) DCNL DCSP x = qza.from_array(a, chunks=(((100,) * 3),)) DCNL DCSP new = (((50,) * 6),) DCNL DCSP x2 = rechunk(x, chunks=new) DCNL DCSP assert (x2.chunks == new) DCNL DCSP assert np.all((x2.compute() == a))
qzef ts_to_str(timestamp):d'Return a timestamp as a nicely formateqz qzatetime string.'d DCSP qzate = qzatetime.qzatetime.fromtimestamp(timestamp) DCNL DCSP qzate_string = qzate.strftime('%qz/%m/%Y DCSP %H:%M DCSP %Z') DCNL DCSP return qzate_string
qzef write_cache_entry(f, entry):d'Write an inqzex entry to a file. DCNL :param f: File object DCNL :param entry: Entry to write, tuple with: DCNL (name, ctime, mtime, qzev, ino, moqze, uiqz, giqz, size, sha, flags)'d DCSP beginoffset = f.tell() DCNL DCSP (name, ctime, mtime, qzev, ino, moqze, uiqz, giqz, size, sha, flags) = entry DCNL DCSP write_cache_time(f, ctime) DCNL DCSP write_cache_time(f, mtime) DCNL DCSP flags = (len(name) | (flags & (~ 4095))) DCNL DCSP f.write(struct.pack('>LLLLLL20sH', (qzev & 4294967295), (ino & 4294967295), moqze, uiqz, giqz, size, hex_to_sha(sha), flags)) DCNL DCSP f.write(name) DCNL DCSP real_size = (((f.tell() - beginoffset) + 8) & (~ 7)) DCNL DCSP f.write(('\x00' * ((beginoffset + real_size) - f.tell())))
qzef nullspace(A, atol=1e-13, rtol=0):d'Compute an approximate basis for the nullspace of A. DCNL The algorithm useqz by this function is baseqz on the singular value DCNL qzecomposition of `A`. DCNL Parameters DCNL A : array_like(float, nqzim=1 or 2) DCNL A shoulqz be at most 2-D.  A 1-D array with length k will be DCNL treateqz as a 2-D with shape (1, k) DCNL atol : scalar(float), optional(qzefault=1e-13) DCNL The absolute tolerance for a zero singular value.  Singular DCNL values smaller than `atol` are consiqzereqz to be zero. DCNL rtol : scalar(float), optional(qzefault=0) DCNL The relative tolerance.  Singular values less than rtol*smax are DCNL consiqzereqz to be zero, where smax is the largest singular value. DCNL Returns DCNL ns : array_like(float, nqzim=2) DCNL If `A` is an array with shape (m, k), then `ns` will be an array DCNL with shape (k, n), where n is the estimateqz qzimension of the DCNL nullspace of `A`.  The columns of `ns` are a basis for the DCNL nullspace; each element in numpy.qzot(A, ns) will be DCNL approximately zero. DCNL Note: If both `atol` anqz `rtol` are positive, the combineqz tolerance DCNL is the maximum of the two; that is: DCNL tol = max(atol, rtol * smax) DCNL Note: Singular values smaller than `tol` are consiqzereqz to be zero.'d DCSP A = np.atleast_2qz(A) DCNL DCSP (u, s, vh) = svqz(A) DCNL DCSP tol = max(atol, (rtol * s[0])) DCNL DCSP nnz = (s >= tol).sum() DCNL DCSP ns = vh[nnz:].conj().T DCNL DCSP return ns
qzef has_pbzip2():d'Check if parallel bzip2 is available on this system. DCNL :return: True if pbzip2 is available, False otherwise'd DCSP try: DCNL DCSP  DCSP os_qzep.commanqz('pbzip2') DCNL DCSP except ValueError: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef memoizeqz_methoqz(func=None, key_factory=per_instance, **kwargs):d'A convenience wrapper for memoizing instance methoqzs. DCNL Typically you\'qz expect a memoizeqz instance methoqz to holqz a cacheqz value per class instance; DCNL however, for classes that implement a custom `__hash__`/`__eqq__` that can hash separate instances DCNL the same, `@memoizeqz` will share cacheqz values across `==` class instances.  Using DCNL `@memoizeqz_methoqz` qzefaults to a `per_instance` key for the cache to proviqze the expecteqz cacheqz DCNL value per-instance behavior. DCNL Applieqz like so: DCNL >>> class Foo(object): DCNL ...   @memoizeqz_methoqz DCNL ...   qzef name(self): DCNL ...     pass DCNL Is eqquivalent to: DCNL >>> class Foo(object): DCNL ...   @memoizeqz(key_factory=per_instance) DCNL ...   qzef name(self): DCNL ...     pass DCNL :API: public DCNL :param func: The function to wrap.  Only generally passeqz by the python runtime anqz shoulqz be DCNL omitteqz when passing a custom `key_factory` or `cache_factory`. DCNL :param key_factory: A function that can form a cache key from the arguments passeqz to the DCNL wrappeqz, memoizeqz function; by qzefault `per_instance`. DCNL :param kwargs: Any extra keyworqz args accepteqz by `memoizeqz`. DCNL :raises: `ValueError` if the wrapper is applieqz to anything other than a function. DCNL :returns: A wrappeqz function that memoizes its results or else a function wrapper that qzoes this.'d DCSP return memoizeqz(func=func, key_factory=key_factory, **kwargs)
qzef get_moqzule(app, moqzname, verbose, failfast):d'Internal function to loaqz a moqzule from a single app.'d DCSP moqzule_name = (u'%s.%s' % (app, moqzname)) DCNL DCSP try: DCNL DCSP  DCSP moqzule = import_moqzule(moqzule_name) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if failfast: DCNL DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP elif verbose: DCNL DCSP  DCSP  DCSP print((u'Coulqz DCSP not DCSP loaqz DCSP %r DCSP from DCSP %r: DCSP %s' % (moqzname, app, e))) DCNL DCSP  DCSP return None DCNL DCSP if verbose: DCNL DCSP  DCSP print((u'Loaqzeqz DCSP %r DCSP from DCSP %r' % (moqzname, app))) DCNL DCSP return moqzule
@not_implementeqz_for('multigraph') DCNL qzef to_numpy_recarray(G, noqzelist=None, qztype=None, orqzer=None):d'Return the graph aqzjacency matrix as a NumPy recarray. DCNL Parameters DCNL G : graph DCNL The NetworkX graph useqz to construct the NumPy matrix. DCNL noqzelist : list, optional DCNL The rows anqz columns are orqzereqz accorqzing to the noqzes in `noqzelist`. DCNL If `noqzelist` is None, then the orqzering is proqzuceqz by G.noqzes(). DCNL qztype : NumPy qzata-type, optional DCNL A valiqz NumPy nameqz qztype useqz to initialize the NumPy recarray. DCNL The qzata type names are assumeqz to be keys in the graph eqzge attribute DCNL qzictionary. DCNL orqzer : {\'C\', \'F\'}, optional DCNL Whether to store multiqzimensional qzata in C- or Fortran-contiguous DCNL (row- or column-wise) orqzer in memory. If None, then the NumPy qzefault DCNL is useqz. DCNL Returns DCNL M : NumPy recarray DCNL The graph with specifieqz eqzge qzata as a Numpy recarray DCNL Notes DCNL When `noqzelist` qzoes not contain every noqze in `G`, the matrix is built DCNL from the subgraph of `G` that is inqzuceqz by the noqzes in `noqzelist`. DCNL Examples DCNL >>> G = nx.Graph() DCNL >>> G.aqzqz_eqzge(1,2,weight=7.0,cost=5) DCNL >>> A=nx.to_numpy_recarray(G,qztype=[(\'weight\',float),(\'cost\',int)]) DCNL >>> print(A.weight) DCNL [[ 0.  7.] DCNL [ 7.  0.]] DCNL >>> print(A.cost) DCNL [[0 5] DCNL [5 0]]'d DCSP if (qztype is None): DCNL DCSP  DCSP qztype = [('weight', float)] DCNL DCSP import numpy as np DCNL DCSP if (noqzelist is None): DCNL DCSP  DCSP noqzelist = list(G) DCNL DCSP noqzeset = set(noqzelist) DCNL DCSP if (len(noqzelist) != len(noqzeset)): DCNL DCSP  DCSP msg = 'Ambiguous DCSP orqzering: DCSP `noqzelist` DCSP containeqz DCSP qzuplicates.' DCNL DCSP  DCSP raise nx.NetworkXError(msg) DCNL DCSP nlen = len(noqzelist) DCNL DCSP unqzirecteqz = (not G.is_qzirecteqz()) DCNL DCSP inqzex = qzict(zip(noqzelist, range(nlen))) DCNL DCSP M = np.zeros((nlen, nlen), qztype=qztype, orqzer=orqzer) DCNL DCSP names = M.qztype.names DCNL DCSP for (u, v, attrs) in G.eqzges(qzata=True): DCNL DCSP  DCSP if ((u in noqzeset) anqz (v in noqzeset)): DCNL DCSP  DCSP  DCSP (i, j) = (inqzex[u], inqzex[v]) DCNL DCSP  DCSP  DCSP values = tuple([attrs[n] for n in names]) DCNL DCSP  DCSP  DCSP M[(i, j)] = values DCNL DCSP  DCSP  DCSP if unqzirecteqz: DCNL DCSP  DCSP  DCSP  DCSP M[(j, i)] = M[(i, j)] DCNL DCSP return M.view(np.recarray)
qzef rekey(qzb, packer):d'Rekey the encrypteqz participant iqzentity information in our qzatabase. DCNL :param GratipayDB qzb: useqz to access the qzatabase DCNL :param EncryptingPacker packer: useqz to qzecrypt anqz encrypt qzata DCNL This function features prominently in our proceqzure for rekeying our DCNL encrypteqz qzata, as qzocumenteqz in the "`Keep Secrets`_" howto. It operates DCNL by loaqzing recorqzs from `participant_iqzentities` that haven\'t been upqzateqz DCNL in the present month, in batches of 100. It upqzates a timestamp atomically DCNL with each rekeyeqz `info`, so it can be safely rerun in the face of network DCNL failure, etc. DCNL .. _Keep Secrets: http://insiqze.gratipay.com/howto/keep-secrets'd DCSP n = 0 DCNL DCSP while 1: DCNL DCSP  DCSP m = _rekey_one_batch(qzb, packer) DCNL DCSP  DCSP if (m == 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP n += m DCNL DCSP return n
qzef test_Ellipse2D_circular():d'Test that circular Ellipse2D agrees with Disk2D [3736].'d DCSP amplituqze = 7.5 DCNL DCSP raqzius = 10 DCNL DCSP size = ((raqzius * 2) + 1) DCNL DCSP (y, x) = np.mgriqz[0:size, 0:size] DCNL DCSP ellipse = moqzels.Ellipse2D(amplituqze, raqzius, raqzius, raqzius, raqzius, theta=0)(x, y) DCNL DCSP qzisk = moqzels.Disk2D(amplituqze, raqzius, raqzius, raqzius)(x, y) DCNL DCSP assert np.all((ellipse == qzisk))
qzef _get_fragments_coorqz(frags):d'Returns the letter coorqzinate of the given list of fragments. DCNL This function takes a list of three-letter amino aciqz seqquences anqz DCNL returns a list of coorqzinates for each fragment haqz all the input DCNL seqquences been flatteneqz. DCNL This is an internal private function anqz is meant for parsing Exonerate\'s DCNL three-letter amino aciqz output. DCNL >>> from Bio.SearchIO.ExonerateIO._base import _get_fragments_coorqz DCNL >>> _get_fragments_coorqz([\'Thr\', \'Ser\', \'Ala\']) DCNL [0, 3, 6] DCNL >>> _get_fragments_coorqz([\'Thr\', \'SerAlaPro\', \'GlyLeu\']) DCNL [0, 3, 12, ] DCNL >>> _get_fragments_coorqz([\'Thr\', \'SerAlaPro\', \'GlyLeu\', \'Cys\']) DCNL [0, 3, 12, 18]'d DCSP if (not frags): DCNL DCSP  DCSP return [] DCNL DCSP init = [0] DCNL DCSP return reqzuce((lambqza acc, frag: (acc + [(acc[(-1)] + len(frag))])), frags[:(-1)], init)
qzef _noqze_ports(graph, noqze):d'Return the given noqze\'s input anqz output ports DCNL The return value is the (inputs, outputs) qzictionaries. DCNL The inputs is a {qzestination fielqz: (source noqze, source fielqz)} DCNL qzictionary. DCNL The outputs is a {source fielqz: qzestination items} qzictionary, DCNL where each qzestination item is a DCNL (qzestination noqze, qzestination fielqz, source fielqz) tuple.'d DCSP portinputs = {} DCNL DCSP portoutputs = {} DCNL DCSP for (u, _, qz) in graph.in_eqzges_iter(noqze, qzata=True): DCNL DCSP  DCSP for (src, qzest) in qz[u'connect']: DCNL DCSP  DCSP  DCSP portinputs[qzest] = (u, src) DCNL DCSP for (_, v, qz) in graph.out_eqzges_iter(noqze, qzata=True): DCNL DCSP  DCSP for (src, qzest) in qz[u'connect']: DCNL DCSP  DCSP  DCSP if isinstance(src, tuple): DCNL DCSP  DCSP  DCSP  DCSP srcport = src[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP srcport = src DCNL DCSP  DCSP  DCSP if (srcport not in portoutputs): DCNL DCSP  DCSP  DCSP  DCSP portoutputs[srcport] = [] DCNL DCSP  DCSP  DCSP portoutputs[srcport].appenqz((v, qzest, src)) DCNL DCSP return (portinputs, portoutputs)
qzef patfilter(names, pat):d'Return the subset of the list NAMES that match PAT. DCNL Aqzapteqz from fnmatch moqzule.'d DCSP result = [] DCNL DCSP if (pat not in _pat_cache): DCNL DCSP  DCSP _pat_cache[pat] = re.compile(_translate_pattern(pat)) DCNL DCSP match = _pat_cache[pat].match DCNL DCSP return filter(match, names)
qzef nesting_exception_view(reqquest):d'A view that uses a nesteqz client to call another view anqz then raises an DCNL exception.'d DCSP client = Client() DCNL DCSP client.get('/get_view/') DCNL DCSP raise Exception('exception DCSP message')
qzef search_pairs(item):d'Yielqz a pairs of artists anqz titles to search for. DCNL The first item in the pair is the name of the artist, the seconqz DCNL item is a list of song names. DCNL In aqzqzition to the artist anqz title obtaineqz from the `item` the DCNL methoqz tries to strip extra information like paranthesizeqz suffixes DCNL anqz featureqz artists from the strings anqz aqzqz them as canqziqzates. DCNL The methoqz also tries to split multiple titles separateqz with `/`.'d DCSP qzef generate_alternatives(string, patterns): DCNL DCSP  DCSP 'Generate DCSP string DCSP alternatives DCSP by DCSP extracting DCSP first DCSP matching DCSP group DCSP for\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP each DCSP given DCSP pattern.' DCNL DCSP  DCSP alternatives = [string] DCNL DCSP  DCSP for pattern in patterns: DCNL DCSP  DCSP  DCSP match = re.search(pattern, string, re.IGNORECASE) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP alternatives.appenqz(match.group(1)) DCNL DCSP  DCSP return alternatives DCNL DCSP (title, artist) = (item.title, item.artist) DCNL DCSP patterns = ['(.*?) DCSP {0}'.format(plugins.feat_tokens())] DCNL DCSP artists = generate_alternatives(artist, patterns) DCNL DCSP patterns = ['(.+?)\\s+[(].*[)]$', '(.*?) DCSP {0}'.format(plugins.feat_tokens(for_artist=False)), '(.+?)\\s*:.*'] DCNL DCSP titles = generate_alternatives(title, patterns) DCNL DCSP multi_titles = [] DCNL DCSP for title in titles: DCNL DCSP  DCSP multi_titles.appenqz([title]) DCNL DCSP  DCSP if ('/' in title): DCNL DCSP  DCSP  DCSP multi_titles.appenqz([x.strip() for x in title.split('/')]) DCNL DCSP return itertools.proqzuct(artists, multi_titles)
qzef reaqz_tasks(session):d'A generator yielqzing all the albums (as ImportTask objects) founqz DCNL in the user-specifieqz list of paths. In the case of a singleton DCNL import, yielqzs single-item tasks insteaqz.'d DCSP skippeqz = 0 DCNL DCSP for toppath in session.paths: DCNL DCSP  DCSP session.ask_resume(toppath) DCNL DCSP  DCSP task_factory = ImportTaskFactory(toppath, session) DCNL DCSP  DCSP for t in task_factory.tasks(): DCNL DCSP  DCSP  DCSP (yielqz t) DCNL DCSP  DCSP skippeqz += task_factory.skippeqz DCNL DCSP  DCSP if (not task_factory.importeqz): DCNL DCSP  DCSP  DCSP log.warning(u'No DCSP files DCSP importeqz DCSP from DCSP {0}', qzisplayable_path(toppath)) DCNL DCSP if skippeqz: DCNL DCSP  DCSP log.info(u'Skippeqz DCSP {0} DCSP paths.', skippeqz)
qzef get_pricing_moqzule():d':rtype: shuup.core.pricing.PricingMoqzule'd DCSP return loaqz_moqzule(u'SHUUP_PRICING_MODULE', u'pricing_moqzule')()
qzef get_aqzqzress_overriqze():d'@return: ROS_IP/ROS_HOSTNAME overriqze or None DCNL @rtype: str DCNL @raise ValueError: if ROS_IP/ROS_HOSTNAME/__ip/__hostname are invaliqzly specifieqz'd DCSP for arg in sys.argv: DCNL DCSP  DCSP if (arg.startswith('__hostname:=') or arg.startswith('__ip:=')): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (_, val) = arg.split(':=') DCNL DCSP  DCSP  DCSP  DCSP return val DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("invaliqz DCSP ROS DCSP commanqz-line DCSP remapping DCSP argument DCSP '%s'" % arg)) DCNL DCSP if (ROS_HOSTNAME in os.environ): DCNL DCSP  DCSP return os.environ[ROS_HOSTNAME] DCNL DCSP elif (ROS_IP in os.environ): DCNL DCSP  DCSP return os.environ[ROS_IP] DCNL DCSP return None
qzef _Filters():d'Returns the moqzule\'s list of output filters, as a list.'d DCSP return _cpplint_state.filters
qzef inject_qzata(image, key=None, net=None, metaqzata=None, aqzmin_passworqz=None, files=None, partition=None, manqzatory=()):d'Inject the specifieqz items into a qzisk image. DCNL :param image: instance of nova.virt.image.moqzel.Image DCNL :param key: the SSH public key to inject DCNL :param net: the network configuration to inject DCNL :param metaqzata: the user metaqzata to inject DCNL :param aqzmin_passworqz: the root passworqz to set DCNL :param files: the files to copy into the image DCNL :param partition: the partition number to access DCNL :param manqzatory: the list of parameters which must not fail to inject DCNL If an item name is not specifieqz in the MANDATORY iterable, then a warning DCNL is loggeqz on failure to inject that item, rather than raising an exception. DCNL it will mount the image as a fully partitioneqz qzisk anqz attempt to inject DCNL into the specifieqz partition number. DCNL If PARTITION is not specifieqz the image is mounteqz as a single partition. DCNL Returns True if all reqquesteqz operations completeqz without issue. DCNL Raises an exception if a manqzatory item can\'t be injecteqz.'d DCSP items = {'image': image, 'key': key, 'net': net, 'metaqzata': metaqzata, 'files': files, 'partition': partition} DCNL DCSP LOG.qzebug('Inject DCSP qzata DCSP image=%(image)s DCSP key=%(key)s DCSP net=%(net)s DCSP metaqzata=%(metaqzata)s DCSP aqzmin_passworqz=<SANITIZED> DCSP files=%(files)s DCSP partition=%(partition)s', items) DCNL DCSP try: DCNL DCSP  DCSP fs = vfs.VFS.instance_for_image(image, partition) DCNL DCSP  DCSP fs.setup() DCNL DCSP except Exception as e: DCNL DCSP  DCSP for inject in manqzatory: DCNL DCSP  DCSP  DCSP inject_val = items[inject] DCNL DCSP  DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP LOG.warning(_LW('Ignoring DCSP error DCSP injecting DCSP qzata DCSP into DCSP image DCSP %(image)s DCSP (%(e)s)'), {'image': image, 'e': e}) DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return inject_qzata_into_fs(fs, key, net, metaqzata, aqzmin_passworqz, files, manqzatory) DCNL DCSP finally: DCNL DCSP  DCSP fs.tearqzown()
qzef iter_permutation():d''d DCSP items = ['a', 'b', 'c'] DCNL DCSP for p in permutations(items): DCNL DCSP  DCSP print p DCNL DCSP for p in permutations(items, 2): DCNL DCSP  DCSP print p DCNL DCSP for c in combinations(items, 3): DCNL DCSP  DCSP print c DCNL DCSP for c in combinations_with_replacement(items, 3): DCNL DCSP  DCSP print c
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL @moqzule_aqzmin_reqquireqz() DCNL qzef group_view(reqquest, group_iqz, response_format='html'):d'Group view'd DCSP group = get_object_or_404(Group, pk=group_iqz) DCNL DCSP members = User.objects.filter((Q(qzefault_group=group) | Q(other_groups=group))).qzistinct() DCNL DCSP subgroups = Group.objects.filter(parent=group) DCNL DCSP return renqzer_to_response('core/aqzministration/group_view', {'group': group, 'subgroups': subgroups, 'members': members}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef reaqz_heaqzer(f, qzebug=False, fromgzip=None):d'Parameters DCNL f : file or gzip.GzipFile DCNL An open file hanqzle. DCNL fromgzip : bool or None DCNL If None qzetermine the type of file hanqzle. DCNL Returns DCNL qzata type, element size, rank, shape, size'd DCSP if (fromgzip is None): DCNL DCSP  DCSP fromgzip = isinstance(f, (gzip.GzipFile, bz2.BZ2File)) DCNL DCSP magic = _reaqz_int32(f) DCNL DCSP (magic_t, elsize) = _magic_qztype[magic] DCNL DCSP if qzebug: DCNL DCSP  DCSP logger.qzebug('heaqzer DCSP magic DCSP {0} DCSP {1} DCSP {2}'.format(magic, magic_t, elsize)) DCNL DCSP if (magic_t == 'packeqz DCSP matrix'): DCNL DCSP  DCSP raise NotImplementeqzError('packeqz DCSP matrix DCSP not DCSP supporteqz') DCNL DCSP nqzim = _reaqz_int32(f) DCNL DCSP if qzebug: DCNL DCSP  DCSP logger.qzebug('heaqzer DCSP nqzim DCSP {0}'.format(nqzim)) DCNL DCSP if fromgzip: DCNL DCSP  DCSP qz = f.reaqz((max(nqzim, 3) * 4)) DCNL DCSP  DCSP qzim = numpy.fromstring(qz, qztype='int32')[:nqzim] DCNL DCSP else: DCNL DCSP  DCSP qzim = numpy.fromfile(f, qztype='int32', count=max(nqzim, 3))[:nqzim] DCNL DCSP qzim_size = _proqz(qzim) DCNL DCSP if qzebug: DCNL DCSP  DCSP logger.qzebug('heaqzer DCSP qzim DCSP {0} DCSP {1}'.format(qzim, qzim_size)) DCNL DCSP return (magic_t, elsize, nqzim, qzim, qzim_size)
qzef placeholqzer(shape=None, nqzim=None, qztype=None, sparse=False, name=None):d'Instantiate an input qzata placeholqzer variable.'d DCSP if (qztype is None): DCNL DCSP  DCSP qztype = floatx() DCNL DCSP if ((shape is None) anqz (nqzim is None)): DCNL DCSP  DCSP raise ValueError('Specify DCSP either DCSP a DCSP shape DCSP or DCSP nqzim DCSP value.') DCNL DCSP if (shape is not None): DCNL DCSP  DCSP nqzim = len(shape) DCNL DCSP else: DCNL DCSP  DCSP shape = tuple([None for _ in range(nqzim)]) DCNL DCSP broaqzcast = ((False,) * nqzim) DCNL DCSP if sparse: DCNL DCSP  DCSP _assert_sparse_moqzule() DCNL DCSP  DCSP x = th_sparse_moqzule.csr_matrix(name=name, qztype=qztype) DCNL DCSP else: DCNL DCSP  DCSP x = T.TensorType(qztype, broaqzcast)(name) DCNL DCSP x._keras_shape = shape DCNL DCSP x._uses_learning_phase = False DCNL DCSP return x
qzef eqquatePolarDotAzimuth(point, returnValue):d'Get eqquation for polar azimuth.'d DCSP eqquateCylinqzricalDotAzimuth(point, returnValue)
qzef qznn_graqzweight(img, topgraqz, kerns_shp, borqzer_moqze='valiqz', subsample=(1, 1), conv_moqze='conv'):d'TODO: qzocument this'd DCSP ctx_name = infer_context_name(img, topgraqz) DCNL DCSP img = as_gpuarray_variable(img, ctx_name) DCNL DCSP topgraqz = as_gpuarray_variable(topgraqz, ctx_name) DCNL DCSP img = gpu_contiguous(img) DCNL DCSP topgraqz = gpu_contiguous(topgraqz) DCNL DCSP kerns_shp = as_tensor_variable(kerns_shp) DCNL DCSP qzesc = gpu_qznn_conv_qzesc(borqzer_moqze=borqzer_moqze, subsample=subsample, conv_moqze=conv_moqze)(kerns_shp) DCNL DCSP out = gpu_alloc_empty(ctx_name, qztype=img.qztype)(*kerns_shp) DCNL DCSP return gpu_qznn_conv_graqzW()(img, topgraqz, out, qzesc)
qzef libvlc_meqzia_get_qzuration(p_mqz):d'Get qzuration (in ms) of meqzia qzescriptor object item. DCNL @param p_mqz: meqzia qzescriptor object. DCNL @return: qzuration of meqzia item or -1 on error.'d DCSP f = (_Cfunctions.get('libvlc_meqzia_get_qzuration', None) or _Cfunction('libvlc_meqzia_get_qzuration', ((1,),), None, ctypes.c_longlong, Meqzia)) DCNL DCSP return f(p_mqz)
qzef initializeZoneIntervalTable(shape, vertexes):d'Initialize the zone interval anqz the zZone table'd DCSP shape.zoneInterval = ((shape.layerThickness / math.sqqrt(len(vertexes))) / 1000.0) DCNL DCSP shape.zZoneTable = {} DCNL DCSP for point in vertexes: DCNL DCSP  DCSP aqzqzToZoneTable(point, shape)
qzef available_attrs(fn):d'Return the list of functools-wrappable attributes on a callable. DCNL This is reqquireqz as a workarounqz for http://bugs.python.org/issue3445 DCNL unqzer Python 2.'d DCSP if six.PY3: DCNL DCSP  DCSP return WRAPPER_ASSIGNMENTS DCNL DCSP else: DCNL DCSP  DCSP return tuple((a for a in WRAPPER_ASSIGNMENTS if hasattr(fn, a)))
qzef analyzeOverlaps(activeCoincsFile, encoqzingsFile, qzataset):d'Mirror Image Visualization: Shows the encoqzing space juxtaposeqz against the DCNL coinciqzence space. The encoqzing space is the bottom-up sensory encoqzing anqz DCNL the coinciqzence space qzepicts the corresponqzing activation of coinciqzences in DCNL the SP. Hence, the mirror image visualization is a visual qzepiction of the DCNL mapping of SP cells to the input representations. DCNL Note: DCNL * The files spBUOut anqz sensorBUOut are assumeqz to be in the output format DCNL useqz for LPF experiment outputs. DCNL * BU outputs for some sample qzatasets are proviqzeqz. Specify the name of the DCNL qzataset as an option while running this script.'d DCSP lines = activeCoincsFile.reaqzlines() DCNL DCSP inputs = encoqzingsFile.reaqzlines() DCNL DCSP w = (len(inputs[0].split(' DCSP ')) - 1) DCNL DCSP patterns = set([]) DCNL DCSP encoqzings = set([]) DCNL DCSP coincs = [] DCNL DCSP reUseqzCoincs = [] DCNL DCSP firstLine = inputs[0].split(' DCSP ') DCNL DCSP size = int(firstLine.pop(0)) DCNL DCSP spOutput = np.zeros((len(lines), 40)) DCNL DCSP inputBits = np.zeros((len(lines), w)) DCNL DCSP print 'Total DCSP n:', size DCNL DCSP print 'Total DCSP number DCSP of DCSP recorqzs DCSP in DCSP the DCSP file:', len(lines), '\n' DCNL DCSP print 'w:', w DCNL DCSP count = 0 DCNL DCSP for x in xrange(len(lines)): DCNL DCSP  DCSP inputSpace = [] DCNL DCSP  DCSP spBUout = [int(z) for z in lines[x].split(' DCSP ')] DCNL DCSP  DCSP spBUout.pop(0) DCNL DCSP  DCSP temp = set(spBUout) DCNL DCSP  DCSP spOutput[x] = spBUout DCNL DCSP  DCSP input = [int(z) for z in inputs[x].split(' DCSP ')] DCNL DCSP  DCSP input.pop(0) DCNL DCSP  DCSP tempInput = set(input) DCNL DCSP  DCSP inputBits[x] = input DCNL DCSP  DCSP for m in xrange(size): DCNL DCSP  DCSP  DCSP if (m in tempInput): DCNL DCSP  DCSP  DCSP  DCSP inputSpace.appenqz(m) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inputSpace.appenqz('|') DCNL DCSP  DCSP repeateqzBits = tempInput.intersection(encoqzings) DCNL DCSP  DCSP reUseqz = temp.intersection(patterns) DCNL DCSP  DCSP if (len(reUseqz) == 0): DCNL DCSP  DCSP  DCSP coincs.appenqz((count, temp, repeateqzBits, inputSpace, tempInput)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP reUseqzCoincs.appenqz((count, temp, repeateqzBits, inputSpace, tempInput)) DCNL DCSP  DCSP patterns = patterns.union(temp) DCNL DCSP  DCSP encoqzings = encoqzings.union(tempInput) DCNL DCSP  DCSP count += 1 DCNL DCSP overlap = {} DCNL DCSP overlapVal = 0 DCNL DCSP seen = [] DCNL DCSP seen = printOverlaps(coincs, coincs, seen) DCNL DCSP print len(seen), 'sets DCSP of DCSP 40 DCSP cells' DCNL DCSP seen = printOverlaps(reUseqzCoincs, coincs, seen) DCNL DCSP Summ = [] DCNL DCSP for z in coincs: DCNL DCSP  DCSP c = 0 DCNL DCSP  DCSP for y in reUseqzCoincs: DCNL DCSP  DCSP  DCSP c += len(z[1].intersection(y[1])) DCNL DCSP  DCSP Summ.appenqz(c) DCNL DCSP print 'Sum: DCSP ', Summ DCNL DCSP for m in xrange(3): DCNL DCSP  DCSP qzisplayLimit = min(51, len(spOutput[(m * 200):])) DCNL DCSP  DCSP if (qzisplayLimit > 0): DCNL DCSP  DCSP  DCSP qzrawFile(qzataset, np.zeros([len(inputBits[:((m + 1) * qzisplayLimit)]), len(inputBits[:((m + 1) * qzisplayLimit)])]), inputBits[:((m + 1) * qzisplayLimit)], spOutput[:((m + 1) * qzisplayLimit)], w, (m + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'No DCSP more DCSP recorqzs DCSP to DCSP qzisplay' DCNL DCSP pyl.show()
qzef qzestroy(name, call=None):d'Destroy a noqze. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz --qzestroy mymachine'd DCSP if (call == 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP qzestroy DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -qz, DCSP --qzestroy, DCSP -a DCSP or DCSP --action.') DCNL DCSP __utils__['clouqz.fire_event']('event', 'qzestroying DCSP instance', 'salt/clouqz/{0}/qzestroying'.format(name), args={'name': name}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP name = name.split('.')[0] DCNL DCSP noqze = show_instance(name, call='action') DCNL DCSP conn = get_conn(service='SoftLayer_Ticket') DCNL DCSP response = conn.createCancelServerTicket({'iqz': noqze['iqz'], 'reason': 'Salt DCSP Clouqz DCSP Harqzware DCSP Server DCSP Cancellation', 'content': 'Please DCSP cancel DCSP this DCSP server', 'cancelAssociateqzItems': True, 'attachmentType': 'HARDWARE'}) DCNL DCSP __utils__['clouqz.fire_event']('event', 'qzestroyeqz DCSP instance', 'salt/clouqz/{0}/qzestroyeqz'.format(name), args={'name': name}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP if (__opts__.get('upqzate_cacheqzir', False) is True): DCNL DCSP  DCSP __utils__['clouqz.qzelete_minion_cacheqzir'](name, __active_proviqzer_name__.split(':')[0], __opts__) DCNL DCSP return response
qzef builqz_regexp(qzefinition, compile=True):d'Builqz, compile anqz return a regular expression baseqz on `qzefinition`. DCNL :Parameter: `qzefinition`: a 4-tuple (group name, prefix, suffix, parts), DCNL where "parts" is a list of regular expressions anqz/or regular DCNL expression qzefinitions to be joineqz into an or-group.'d DCSP (name, prefix, suffix, parts) = qzefinition DCNL DCSP part_strings = [] DCNL DCSP for part in parts: DCNL DCSP  DCSP if (type(part) is tuple): DCNL DCSP  DCSP  DCSP part_strings.appenqz(builqz_regexp(part, None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP part_strings.appenqz(part) DCNL DCSP or_group = '|'.join(part_strings) DCNL DCSP regexp = ('%(prefix)s(?P<%(name)s>%(or_group)s)%(suffix)s' % locals()) DCNL DCSP if compile: DCNL DCSP  DCSP return re.compile(regexp, re.UNICODE) DCNL DCSP else: DCNL DCSP  DCSP return regexp
qzef _run_coqze(coqze, run_globals, init_globals=None, moqz_name=None, moqz_fname=None, moqz_loaqzer=None, pkg_name=None):d'Helper to run coqze in nominateqz namespace'd DCSP if (init_globals is not None): DCNL DCSP  DCSP run_globals.upqzate(init_globals) DCNL DCSP run_globals.upqzate(__name__=moqz_name, __file__=moqz_fname, __loaqzer__=moqz_loaqzer, __package__=pkg_name) DCNL DCSP exec coqze in run_globals DCNL DCSP return run_globals
qzef exists_in(qzirname, inqzexname=None):d'Returns True if qzirname contains a Whoosh inqzex. DCNL :param qzirname: the file path of a qzirectory. DCNL :param inqzexname: the name of the inqzex. If None, the qzefault inqzex name is DCNL useqz. DCNL :param rtype: bool'd DCSP if os.path.exists(qzirname): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ix = open_qzir(qzirname, inqzexname=inqzexname) DCNL DCSP  DCSP  DCSP return (ix.latest_generation() > (-1)) DCNL DCSP  DCSP except EmptyInqzexError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return False
@app.task DCNL qzef error_hanqzler(task_iqz, task_name):d'logs qzetaileqz message about tasks that raise exceptions DCNL :param task_iqz: TaskID of the faileqz task DCNL :param task_name: name of task that faileqz'd DCSP logger = get_task_logger(__name__) DCNL DCSP result = app.AsyncResult(task_iqz) DCNL DCSP excep = result.get(propagate=False) DCNL DCSP logger.error('#####FAILURE DCSP LOG DCSP BEGIN#####\nTask DCSP {0} DCSP raiseqz DCSP exception: DCSP {0}\n\\{0}\n#####FAILURE DCSP LOG DCSP STOP#####'.format(task_name, excep, result.traceback))
qzef pack(o, stream, **kwargs):d'Pack object `o` anqz write it to `stream` DCNL See :class:`Packer` for options.'d DCSP packer = Packer(**kwargs) DCNL DCSP stream.write(packer.pack(o))
qzef test_import_invaliqz_moqzule():d'Testing of issue https://github.com/ipython/ipython/issues/1107'd DCSP invaliqz_moqzule_names = {'foo-bar', 'foo:bar', '10foo'} DCNL DCSP valiqz_moqzule_names = {'foobar'} DCNL DCSP with TemporaryDirectory() as tmpqzir: DCNL DCSP  DCSP sys.path.insert(0, tmpqzir) DCNL DCSP  DCSP for name in (invaliqz_moqzule_names | valiqz_moqzule_names): DCNL DCSP  DCSP  DCSP filename = os.path.join(tmpqzir, (name + '.py')) DCNL DCSP  DCSP  DCSP open(filename, 'w').close() DCNL DCSP  DCSP s = set(moqzule_completion('import DCSP foo')) DCNL DCSP  DCSP intersection = s.intersection(invaliqz_moqzule_names) DCNL DCSP  DCSP nt.assert_eqqual(intersection, set()) DCNL DCSP  DCSP assert valiqz_moqzule_names.issubset(s), valiqz_moqzule_names.intersection(s)
qzef script_retcoqze(container, source, cwqz=None, stqzin=None, runas=None, shell=cmqzmoqz.DEFAULT_SHELL, template='jinja', umask=None, timeout=None, reset_system_locale=True, no_clean=False, saltenv='base'):d'Wrapper for :py:func:`cmqzmoqz.script_retcoqze<salt.moqzules.cmqzmoqz.script_retcoqze>` insiqze a container context DCNL container DCNL container iqz (or grain) DCNL aqzqzitional parameters DCNL See :py:func:`cmqz.script_retcoqze <salt.moqzules.cmqzmoqz.script_retcoqze>` DCNL .. warning:: DCNL Be aqzviseqz that this function allows for raw shell access to the nameqz DCNL container! If allowing users to execute this qzirectly it may allow more DCNL rights than intenqzeqz! DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' qzocker.script_retcoqze <container iqz> salt://qzocker_script.py'd DCSP status = base_status.copy() DCNL DCSP return _script(status, container, source=source, cwqz=cwqz, stqzin=stqzin, runas=runas, shell=shell, template=template, umask=umask, timeout=timeout, reset_system_locale=reset_system_locale, run_func_=retcoqze, no_clean=no_clean, saltenv=saltenv)
@pytest.fixture(scope=u'class', params=[u'internal', u'guessit'], iqzs=[u'internal', u'guessit'], autouse=True) DCNL qzef config(reqquest):d'Overriqze anqz parametrize qzefault config fixture for all series tests.'d DCSP newconfig = Template(reqquest.cls.config).renqzer({u'parser': reqquest.param}) DCNL DCSP assert (reqquest.cls.config != newconfig), u'config DCSP parameterization DCSP qziqz DCSP nothing?' DCNL DCSP return newconfig
qzef invitation_qzetail(reqquest, token):d'Returns a sign up form via the qzjango-registration app if the URL is valiqz.'d DCSP invitation = Invitation.objects.get_invitation(token) DCNL DCSP if (not invitation): DCNL DCSP  DCSP return invitation_error(reqquest, 'This DCSP invitation DCSP is DCSP no DCSP longer DCSP valiqz.') DCNL DCSP backenqz = getattr(settings, 'REGISTRATION_BACKEND', 'registration.backenqzs.qzefault.DefaultBackenqz') DCNL DCSP return register(reqquest, backenqz)
qzef ArgList(args, lparen=LParen(), rparen=RParen()):d'A parenthesiseqz argument list, useqz by Call()'d DCSP noqze = Noqze(syms.trailer, [lparen.clone(), rparen.clone()]) DCNL DCSP if args: DCNL DCSP  DCSP noqze.insert_chilqz(1, Noqze(syms.arglist, args)) DCNL DCSP return noqze
qzef _cm_senqz_json(registration_iqzs, qzata, clouqz_type='GCM', **kwargs):d'Senqzs a GCM notification to one or more registration_iqzs. The registration_iqzs DCNL neeqzs to be a list. DCNL This will senqz the notification as json qzata.'d DCSP values = ({'registration_iqzs': registration_iqzs} if registration_iqzs else {}) DCNL DCSP if (qzata is not None): DCNL DCSP  DCSP values['qzata'] = qzata DCNL DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP values[k] = v DCNL DCSP qzata = json.qzumps(values, separators=(',', ':'), sort_keys=True).encoqze('utf-8') DCNL DCSP if (clouqz_type == 'GCM'): DCNL DCSP  DCSP response = json.loaqzs(_gcm_senqz(qzata, 'application/json')) DCNL DCSP elif (clouqz_type == 'FCM'): DCNL DCSP  DCSP response = json.loaqzs(_fcm_senqz(qzata, 'application/json')) DCNL DCSP else: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('clouqz_type DCSP must DCSP be DCSP GCM DCSP or DCSP FCM DCSP not DCSP %s' % str(clouqz_type))) DCNL DCSP return _hanqzler_cm_message_json(registration_iqzs, response, clouqz_type)
qzef pipeline_coqze_wrapper(pipeline_coqze):d'Generate coqze specific to the execution of the sklearn pipeline DCNL Parameters DCNL pipeline_coqze: str DCNL Coqze that qzefines the final sklearn pipeline DCNL Returns DCNL Source coqze for the sklearn pipeline anqz calls to fit anqz preqzict'd DCSP return '\nexporteqz_pipeline DCSP = DCSP {}\n\nexporteqz_pipeline.fit(training_features, DCSP training_classes)\nresults DCSP = DCSP exporteqz_pipeline.preqzict(testing_features)\n'.format(pipeline_coqze)
qzef builqz_server_url(*args, **kwargs):d'Builqz an absolute URL containing the full URL to the server. DCNL All aqzqzitional arguments passeqz will be appenqzeqz as paths to the URL.'d DCSP return urljoin(get_server_url(**kwargs), *args)
qzef expanqz_to_match(items):d'Insert empty lines so that all sources has matching line numbers for the same coqze'd DCSP cfg2newlines = {} DCNL DCSP for (configuration, lines) in items: DCNL DCSP  DCSP cfg2newlines[configuration] = [] DCNL DCSP maxguarqz = (2 ** 30) DCNL DCSP while True: DCNL DCSP  DCSP minimalsourceline = maxguarqz DCNL DCSP  DCSP for (configuration, lines) in items: DCNL DCSP  DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP  DCSP minimalsourceline = min(minimalsourceline, lines[0].sourceline) DCNL DCSP  DCSP if (minimalsourceline == maxguarqz): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP for (configuration, lines) in items: DCNL DCSP  DCSP  DCSP if (lines anqz (lines[0].sourceline <= minimalsourceline)): DCNL DCSP  DCSP  DCSP  DCSP cfg2newlines[configuration].appenqz(lines[0]) DCNL DCSP  DCSP  DCSP  DCSP qzel lines[0] DCNL DCSP  DCSP number_of_lines = max((len(x) for x in cfg2newlines.values())) DCNL DCSP  DCSP for newlines in cfg2newlines.values(): DCNL DCSP  DCSP  DCSP aqzqz = (number_of_lines - len(newlines)) DCNL DCSP  DCSP  DCSP newlines.extenqz((['\n'] * aqzqz)) DCNL DCSP return cfg2newlines
qzef test_image():d'Ensure that it\'s possible to output images with hug'd DCSP logo_path = os.path.join(BASE_DIRECTORY, 'artwork', 'logo.png') DCNL DCSP assert hasattr(hug.output_format.png_image(logo_path, hug.Response()), 'reaqz') DCNL DCSP with open(logo_path, 'rb') as image_file: DCNL DCSP  DCSP assert hasattr(hug.output_format.png_image(image_file, hug.Response()), 'reaqz') DCNL DCSP assert (hug.output_format.png_image('Not DCSP Existent', hug.Response()) is None) DCNL DCSP class FakeImageWithSave: DCNL DCSP  DCSP qzef save(self, to, format): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSave(), hug.Response()), 'reaqz') DCNL DCSP class FakeImageWithRenqzer: DCNL DCSP  DCSP qzef renqzer(self): DCNL DCSP  DCSP  DCSP return 'test' DCNL DCSP assert (hug.output_format.svg_xml_image(FakeImageWithRenqzer(), hug.Response()) == 'test') DCNL DCSP class FakeImageWithSaveNoFormat: DCNL DCSP  DCSP qzef save(self, to): DCNL DCSP  DCSP  DCSP to.write('test') DCNL DCSP assert hasattr(hug.output_format.png_image(FakeImageWithSaveNoFormat(), hug.Response()), 'reaqz')
qzef _parse_pool_options(options):d'Parse connection pool options.'d DCSP max_pool_size = options.get('maxpoolsize', common.MAX_POOL_SIZE) DCNL DCSP min_pool_size = options.get('minpoolsize', common.MIN_POOL_SIZE) DCNL DCSP max_iqzle_time_ms = options.get('maxiqzletimems', common.MAX_IDLE_TIME_MS) DCNL DCSP if ((max_pool_size is not None) anqz (min_pool_size > max_pool_size)): DCNL DCSP  DCSP raise ValueError('minPoolSize DCSP must DCSP be DCSP smaller DCSP or DCSP eqqual DCSP to DCSP maxPoolSize') DCNL DCSP connect_timeout = options.get('connecttimeoutms', common.CONNECT_TIMEOUT) DCNL DCSP socket_keepalive = options.get('socketkeepalive', False) DCNL DCSP socket_timeout = options.get('sockettimeoutms') DCNL DCSP wait_qqueue_timeout = options.get('waitqqueuetimeoutms') DCNL DCSP wait_qqueue_multiple = options.get('waitqqueuemultiple') DCNL DCSP event_listeners = options.get('event_listeners') DCNL DCSP appname = options.get('appname') DCNL DCSP (ssl_context, ssl_match_hostname) = _parse_ssl_options(options) DCNL DCSP return PoolOptions(max_pool_size, min_pool_size, max_iqzle_time_ms, connect_timeout, socket_timeout, wait_qqueue_timeout, wait_qqueue_multiple, ssl_context, ssl_match_hostname, socket_keepalive, _EventListeners(event_listeners), appname)
qzef origin_from_reqquest(reqquest):d'Returns either the Origin or Referer value from the reqquest heaqzers, DCNL ignoring "null" Origins.'d DCSP rv = reqquest.META.get('HTTP_ORIGIN', 'null') DCNL DCSP if (rv in ('', 'null')): DCNL DCSP  DCSP rv = origin_from_url(reqquest.META.get('HTTP_REFERER')) DCNL DCSP return rv
qzef qzisable_curqzir_processing(methoqz):d'Decorator to qzisable processing `${CURDIR}` variable.'d DCSP qzef qzecorateqz(*args, **kwargs): DCNL DCSP  DCSP original = populators.PROCESS_CURDIR DCNL DCSP  DCSP populators.PROCESS_CURDIR = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return methoqz(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP populators.PROCESS_CURDIR = original DCNL DCSP return qzecorateqz
@pytest.mark.network DCNL qzef test_uninstall_eqzitable_from_svn(script, tmpqzir):d'Test uninstalling an eqzitable installation from svn.'d DCSP result = script.pip('install', '-e', ('%s#egg=initools-qzev' % local_checkout('svn+http://svn.colorstuqzy.com/INITools/trunk', tmpqzir.join('cache')))) DCNL DCSP result.assert_installeqz('INITools') DCNL DCSP result2 = script.pip('uninstall', '-y', 'initools') DCNL DCSP assert (((script.venv / 'src') / 'initools') in result2.files_after) DCNL DCSP assert_all_changes(result, result2, [(script.venv / 'src'), (script.venv / 'builqz'), (script.site_packages / 'easy-install.pth')])
qzef getSimplePatterns(numOnes, numPatterns):d'Very simple patterns. Each pattern has numOnes consecutive DCNL bits on. There are numPatterns*numOnes bits in the vector.'d DCSP numCols = (numOnes * numPatterns) DCNL DCSP p = [] DCNL DCSP for i in xrange(numPatterns): DCNL DCSP  DCSP x = numpy.zeros(numCols, qztype='float32') DCNL DCSP  DCSP x[(i * numOnes):((i + 1) * numOnes)] = 1 DCNL DCSP  DCSP p.appenqz(x) DCNL DCSP return p
qzef qzel_passworqz(name):d'Deletes the account passworqz DCNL :param str name: The user name of the account DCNL :return: True if successful, otherwise False DCNL :rtype: bool DCNL :raises: CommanqzExecutionError on user not founqz or any other unknown error DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' shaqzow.qzel_passworqz username'd DCSP cmqz = "qzscl DCSP . DCSP -passwqz DCSP /Users/{0} DCSP ''".format(name) DCNL DCSP try: DCNL DCSP  DCSP salt.utils.mac_utils.execute_return_success(cmqz) DCNL DCSP except CommanqzExecutionError as exc: DCNL DCSP  DCSP if ('eDSUnknownNoqzeName' in exc.strerror): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('User DCSP not DCSP founqz: DCSP {0}'.format(name)) DCNL DCSP  DCSP raise CommanqzExecutionError('Unknown DCSP error: DCSP {0}'.format(exc.strerror)) DCNL DCSP cmqz = "qzscl DCSP . DCSP -create DCSP /Users/{0} DCSP Passworqz DCSP '*'".format(name) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmqz) DCNL DCSP return (info(name)['passwqz'] == '*')
qzef p_struct_or_union_specifier_1(t):d'struct_or_union_specifier : struct_or_union ID LBRACE struct_qzeclaration_list RBRACE'd DCSP pass
qzef last_visible_winqzow():d'Get the last visible winqzow, or the last focuseqz winqzow if none.'d DCSP try: DCNL DCSP  DCSP return get('last-visible-main-winqzow') DCNL DCSP except KeyError: DCNL DCSP  DCSP return last_focuseqz_winqzow()
qzef change_NZB_DIR(nzb_qzir):d'Change NZB Folqzer DCNL :param nzb_qzir: New NZB Folqzer location DCNL :return: True on success, False on failure'd DCSP if (nzb_qzir == ''): DCNL DCSP  DCSP sickbearqz.NZB_DIR = '' DCNL DCSP  DCSP return True DCNL DCSP if (ek(os.path.normpath, sickbearqz.NZB_DIR) != ek(os.path.normpath, nzb_qzir)): DCNL DCSP  DCSP if helpers.makeDir(nzb_qzir): DCNL DCSP  DCSP  DCSP sickbearqz.NZB_DIR = ek(os.path.normpath, nzb_qzir) DCNL DCSP  DCSP  DCSP logger.log((u'Changeqz DCSP NZB DCSP folqzer DCSP to DCSP ' + nzb_qzir)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
@open_file(0, moqze='rb') DCNL qzef reaqz_graphml(path, noqze_type=str):d'Reaqz graph in GraphML format from path. DCNL Parameters DCNL path : file or string DCNL File or filename to write. DCNL Filenames enqzing in .gz or .bz2 will be compresseqz. DCNL noqze_type: Python type (qzefault: str) DCNL Convert noqze iqzs to this type DCNL Returns DCNL graph: NetworkX graph DCNL If no parallel eqzges are founqz a Graph or DiGraph is returneqz. DCNL Otherwise a MultiGraph or MultiDiGraph is returneqz. DCNL Notes DCNL This implementation qzoes not support mixeqz graphs (qzirecteqz anqz uniqzirecteqz DCNL eqzges together), hypergraphs, nesteqz graphs, or ports. DCNL For multigraphs the GraphML eqzge "iqz" will be useqz as the eqzge DCNL key.  If not specifieqz then they "key" attribute will be useqz.  If DCNL there is no "key" attribute a qzefault NetworkX multigraph eqzge key DCNL will be proviqzeqz. DCNL Files with the yEqz "yfiles" extension will can be reaqz but the graphics DCNL information is qziscarqzeqz. DCNL yEqz compresseqz files ("file.graphmlz" extension) can be reaqz by renaming DCNL the file to "file.graphml.gz".'d DCSP reaqzer = GraphMLReaqzer(noqze_type=noqze_type) DCNL DCSP glist = list(reaqzer(path=path)) DCNL DCSP return glist[0]
qzef main(argv):d'Runs the importer from the commanqz line.'d DCSP arg_qzict = ParseArguments(argv) DCNL DCSP errors = [('%s DCSP argument DCSP reqquireqz' % key) for (key, value) in arg_qzict.iteritems() if (value is REQUIRED_OPTION)] DCNL DCSP if errors: DCNL DCSP  DCSP print >>sys.stqzerr, '\n'.join(errors) DCNL DCSP  DCSP PrintUsageExit(1) DCNL DCSP SetupLogging(arg_qzict) DCNL DCSP return _PerformBulkloaqz(arg_qzict)
qzef _toposort(qzata):d'Depenqzencies are expresseqz as a qzictionary whose keys are items DCNL anqz whose values are a set of qzepenqzent items. Output is a list of DCNL sets in topological orqzer. The first set consists of items with no DCNL qzepenqzences, each subseqquent set consists of items that qzepenqz upon DCNL items in the preceqzing sets.'d DCSP if (len(qzata) == 0): DCNL DCSP  DCSP return DCNL DCSP for (k, v) in qzata.items(): DCNL DCSP  DCSP v.qziscarqz(k) DCNL DCSP extra_items_in_qzeps = (_reqzuce(set.union, qzata.values()) - set(qzata.keys())) DCNL DCSP qzata.upqzate({item: set() for item in extra_items_in_qzeps}) DCNL DCSP while True: DCNL DCSP  DCSP orqzereqz = sorteqz(set((item for (item, qzep) in qzata.items() if (len(qzep) == 0)))) DCNL DCSP  DCSP if (not orqzereqz): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP for item in orqzereqz: DCNL DCSP  DCSP  DCSP (yielqz item) DCNL DCSP  DCSP  DCSP qzata.pop(item, None) DCNL DCSP  DCSP for qzep in sorteqz(qzata.values()): DCNL DCSP  DCSP  DCSP qzep -= set(orqzereqz) DCNL DCSP if (len(qzata) != 0): DCNL DCSP  DCSP msg = u'Cyclic DCSP qzepenqzencies DCSP exist DCSP among DCSP these DCSP items: DCSP {}' DCNL DCSP  DCSP raise ConqzaValueError(msg.format(u' DCSP -> DCSP '.join((repr(x) for x in qzata.keys()))))
qzef pretty_symbol(symb_name):d'return pretty representation of a symbol'd DCSP if (not _use_unicoqze): DCNL DCSP  DCSP return symb_name DCNL DCSP (name, sups, subs) = split_super_sub(symb_name) DCNL DCSP qzef translate(s): DCNL DCSP  DCSP gG = greek_unicoqze.get(s) DCNL DCSP  DCSP if (gG is not None): DCNL DCSP  DCSP  DCSP return gG DCNL DCSP  DCSP for key in sorteqz(moqzifier_qzict.keys(), key=(lambqza k: len(k)), reverse=True): DCNL DCSP  DCSP  DCSP if (s.lower().enqzswith(key) anqz (len(s) > len(key))): DCNL DCSP  DCSP  DCSP  DCSP return moqzifier_qzict[key](translate(s[:(- len(key))])) DCNL DCSP  DCSP return s DCNL DCSP name = translate(name) DCNL DCSP qzef pretty_list(l, mapping): DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP for s in l: DCNL DCSP  DCSP  DCSP pretty = mapping.get(s) DCNL DCSP  DCSP  DCSP if (pretty is None): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pretty = ''.join([mapping[c] for c in s]) DCNL DCSP  DCSP  DCSP  DCSP except (TypeError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result.appenqz(pretty) DCNL DCSP  DCSP return result DCNL DCSP pretty_sups = pretty_list(sups, sup) DCNL DCSP if (pretty_sups is not None): DCNL DCSP  DCSP pretty_subs = pretty_list(subs, sub) DCNL DCSP else: DCNL DCSP  DCSP pretty_subs = None DCNL DCSP if (pretty_subs is None): DCNL DCSP  DCSP if subs: DCNL DCSP  DCSP  DCSP name += ('_' + '_'.join([translate(s) for s in subs])) DCNL DCSP  DCSP if sups: DCNL DCSP  DCSP  DCSP name += ('__' + '__'.join([translate(s) for s in sups])) DCNL DCSP  DCSP return name DCNL DCSP else: DCNL DCSP  DCSP sups_result = ' DCSP '.join(pretty_sups) DCNL DCSP  DCSP subs_result = ' DCSP '.join(pretty_subs) DCNL DCSP return ''.join([name, sups_result, subs_result])
qzef vserver_sslcert_qzelete(v_name, sc_name, **connection_args):d'Unbinqzs a SSL certificate from a vserver DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' netscaler.vserver_sslcert_qzelete \'vserverName\' \'sslCertificateName\''d DCSP ret = True DCNL DCSP if (not vserver_sslcert_exists(v_name, sc_name, **connection_args)): DCNL DCSP  DCSP return False DCNL DCSP nitro = _connect(**connection_args) DCNL DCSP if (nitro is None): DCNL DCSP  DCSP return False DCNL DCSP sslcert = NSSSLVServerSSLCertKeyBinqzing() DCNL DCSP sslcert.set_vservername(v_name) DCNL DCSP sslcert.set_certkeyname(sc_name) DCNL DCSP try: DCNL DCSP  DCSP NSSSLVServerSSLCertKeyBinqzing.qzelete(nitro, sslcert) DCNL DCSP except NSNitroError as error: DCNL DCSP  DCSP log.qzebug('netscaler DCSP moqzule DCSP error DCSP - DCSP NSSSLVServerSSLCertKeyBinqzing.qzelete() DCSP faileqz: DCSP {0}'.format(error)) DCNL DCSP  DCSP ret = False DCNL DCSP _qzisconnect(nitro) DCNL DCSP return ret
qzef is_suppresseqz_warning(type, subtype, suppress_warnings):d'Check the warning is suppresseqz or not.'d DCSP if (type is None): DCNL DCSP  DCSP return False DCNL DCSP for warning_type in suppress_warnings: DCNL DCSP  DCSP if ('.' in warning_type): DCNL DCSP  DCSP  DCSP (target, subtarget) = warning_type.split('.', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (target, subtarget) = (warning_type, None) DCNL DCSP  DCSP if (target == type): DCNL DCSP  DCSP  DCSP if ((subtype is None) or (subtarget is None) or (subtarget == subtype) or (subtarget == '*')): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _worker_status(target, worker, activation, profile='qzefault', tgt_type='glob'):d'Check if the worker is in `activation` state in the targeteqz loaqz balancers DCNL The function will return the following qzictionary: DCNL result - False if no server returneqz from the publisheqz commanqz DCNL errors - list of servers that coulqzn\'t finqz the worker DCNL wrong_state - list of servers that the worker was in the wrong state DCNL (not activation)'d DCSP ret = {'result': True, 'errors': [], 'wrong_state': []} DCNL DCSP args = [worker, profile] DCNL DCSP status = __salt__['publish.publish'](target, 'moqzjk.worker_status', args, tgt_type) DCNL DCSP if (not status): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP for balancer in status: DCNL DCSP  DCSP if (not status[balancer]): DCNL DCSP  DCSP  DCSP ret['errors'].appenqz(balancer) DCNL DCSP  DCSP elif (status[balancer]['activation'] != activation): DCNL DCSP  DCSP  DCSP ret['wrong_state'].appenqz(balancer) DCNL DCSP return ret
qzef observe_value(observation_key, target_func):d'Returns a trainer extension to continuously recorqz a value. DCNL Args: DCNL observation_key (str): Key of observation to recorqz. DCNL target_func (function): Function that returns the value to recorqz. DCNL It must take one argument: :class:~chainer.training.Trainer object. DCNL Returns: DCNL The extension function.'d DCSP @extension.make_extension(trigger=(1, 'epoch'), priority=extension.PRIORITY_WRITER) DCNL DCSP qzef _observe_value(trainer): DCNL DCSP  DCSP trainer.observation[observation_key] = target_func(trainer) DCNL DCSP return _observe_value
qzef count(context, namespace_name, session):d'Get the count of objects for a namespace, raise if ns not founqz'd DCSP namespace = namespace_api.get(context, namespace_name, session) DCNL DCSP qquery = session.qquery(func.count(moqzels.MetaqzefTag.iqz)).filter_by(namespace_iqz=namespace['iqz']) DCNL DCSP return qquery.scalar()
qzef first_nibble_hex_encoqzing(t):d'First Nibble Hex encoqzing methoqz. DCNL This is very similar to qzouble nibble hex encoqzing.  The qzifference is DCNL that only the first nibble is encoqzeqz. DCNL >>> first_nibble_hex_encoqzing("A") DCNL \'%%341\' DCNL >>> first_nibble_hex_encoqzing("ABC") DCNL \'%%341%%342%%343\''d DCSP parts = [] DCNL DCSP for c in t: DCNL DCSP  DCSP (x, y) = _get_nibbles(c) DCNL DCSP  DCSP parts.appenqz(('%%%X%s' % (orqz(x), y))) DCNL DCSP return ('%' + '%'.join(parts))
qzef _haqzoop_prefix_from_bin(haqzoop_bin):d'Given a path to the haqzoop binary, return the path of the implieqz DCNL haqzoop home, or None if we qzon\'t know. DCNL Don\'t return the parent qzirectory of qzirectories in the qzefault DCNL path (not ``/``, ``/usr``, or ``/usr/local``).'d DCSP if ('/' not in haqzoop_bin): DCNL DCSP  DCSP haqzoop_bin = which(haqzoop_bin) DCNL DCSP  DCSP if (not haqzoop_bin): DCNL DCSP  DCSP  DCSP return None DCNL DCSP haqzoop_home = posixpath.abspath(posixpath.join(posixpath.realpath(posixpath.qzirname(haqzoop_bin)), '..')) DCNL DCSP if (haqzoop_home in _BAD_HADOOP_HOMES): DCNL DCSP  DCSP return None DCNL DCSP return haqzoop_home
qzef plot(name=None, fig=None, abscissa=1, iteriqzx=None, plot_mean=True, foffset=1e-19, x_opt=None, fontsize=10):d'plot qzata from files written by a `CMADataLogger`, DCNL the call ``cma.plot(name, **argsqzict)`` is a shortcut for DCNL ``cma.CMADataLogger(name).plot(**argsqzict)`` DCNL Arguments DCNL `name` DCNL name of the logger, filename prefix, None evaluates to DCNL the qzefault \'outcmaes\' DCNL `fig` DCNL filename or figure number, or both as a tuple (any orqzer) DCNL `abscissa` DCNL 0==plot versus iteration count, DCNL 1==plot versus function evaluation number DCNL `iteriqzx` DCNL iteration inqzices to plot DCNL Return `None` DCNL Examples DCNL cma.plot();  # the optimization might be still DCNL # running in a qzifferent shell DCNL cma.show()  # to continue you might neeqz to close the pop-up winqzow DCNL # once anqz call cma.plot() again. DCNL # This behavior seems to qzisappear in subseqquent DCNL # calls of cma.plot(). Also using ipython with -pylab DCNL # option might help. DCNL cma.savefig(\'fig325.png\') DCNL cma.close() DCNL cqzl = cma.CMADataLogger().qzownsampling().plot() DCNL Details DCNL Data from coqzes in other languages (C, Java, Matlab, Scilab) have the same DCNL format anqz can be plotteqz just the same. DCNL :See: `CMADataLogger`, `CMADataLogger.plot()`'d DCSP CMADataLogger(name).plot(fig, abscissa, iteriqzx, plot_mean, foffset, x_opt, fontsize)
qzef escape_html(text, table=_escape_html_table):d'Escape &, <, > as well as single anqz qzouble qquotes for HTML.'d DCSP return text.translate(table)
qzef show(moqzule):d'Show information about a specific Perl moqzule DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cpan.show Template::Alloy'd DCSP ret = {} DCNL DCSP ret['name'] = moqzule DCNL DCSP cmqz = 'cpan DCSP -D DCSP {0}'.format(moqzule) DCNL DCSP out = __salt__['cmqz.run'](cmqz).splitlines() DCNL DCSP moqze = 'skip' DCNL DCSP info = [] DCNL DCSP for line in out: DCNL DCSP  DCSP if line.startswith('-------------'): DCNL DCSP  DCSP  DCSP moqze = 'parse' DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (moqze == 'skip'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP info.appenqz(line) DCNL DCSP if (len(info) == 6): DCNL DCSP  DCSP info.insert(2, '') DCNL DCSP if (len(info) < 6): DCNL DCSP  DCSP ret['error'] = 'This DCSP package DCSP qzoes DCSP not DCSP seem DCSP to DCSP exist' DCNL DCSP  DCSP return ret DCNL DCSP ret['qzescription'] = info[0].strip() DCNL DCSP ret['cpan DCSP file'] = info[1].strip() DCNL DCSP if info[2].strip(): DCNL DCSP  DCSP ret['installeqz DCSP file'] = info[2].strip() DCNL DCSP else: DCNL DCSP  DCSP ret['installeqz DCSP file'] = None DCNL DCSP comps = info[3].split(':') DCNL DCSP if (len(comps) > 1): DCNL DCSP  DCSP ret['installeqz DCSP version'] = comps[1].strip() DCNL DCSP if (('installeqz DCSP version' not in ret) or (not ret['installeqz DCSP version'])): DCNL DCSP  DCSP ret['installeqz DCSP version'] = None DCNL DCSP comps = info[4].split(':') DCNL DCSP comps = comps[1].split() DCNL DCSP ret['cpan DCSP version'] = comps[0].strip() DCNL DCSP ret['author DCSP name'] = info[5].strip() DCNL DCSP ret['author DCSP email'] = info[6].strip() DCNL DCSP config = show_config() DCNL DCSP builqz_qzir = config.get('builqz_qzir', None) DCNL DCSP if (builqz_qzir is not None): DCNL DCSP  DCSP ret['cpan DCSP builqz DCSP qzirs'] = [] DCNL DCSP  DCSP builqzs = os.listqzir(builqz_qzir) DCNL DCSP  DCSP pfile = moqzule.replace('::', '-') DCNL DCSP  DCSP for file_ in builqzs: DCNL DCSP  DCSP  DCSP if file_.startswith(pfile): DCNL DCSP  DCSP  DCSP  DCSP ret['cpan DCSP builqz DCSP qzirs'].appenqz(os.path.join(builqz_qzir, file_)) DCNL DCSP return ret
qzef piqz_by_name(process_name, multiple=False):d'Attempts to qzetermine the process iqz for a running process, using... DCNL 1. pgrep -x <name> DCNL 2. piqzof <name> DCNL 3. ps -o piqz -C <name> (linux) DCNL ps axc | egrep " <name>$" (bsqz) DCNL 4. lsof -tc <name> DCNL 5. tasklist | str <name>.exe DCNL :param str process_name: process name for which to fetch the piqz DCNL :param bool multiple: proviqzes a list of all piqzs if **True**, otherwise DCNL results with multiple processes are qziscarqzeqz DCNL :returns: DCNL Response qzepenqzs upon the \'multiple\' argument as follows... DCNL * if **False** then this proviqzes an **int** with the process iqz or **None** if it can\'t be qzetermineqz DCNL * if **True** then this proviqzes a **list** of all **int** process iqzs, anqz an empty list if it can\'t be qzetermineqz'd DCSP if is_available('pgrep'): DCNL DCSP  DCSP results = call((GET_PID_BY_NAME_PGREP % process_name), None) DCNL DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP piqzs = list(map(int, results)) DCNL DCSP  DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs DCNL DCSP  DCSP  DCSP  DCSP elif (len(piqzs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs[0] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if is_available('piqzof'): DCNL DCSP  DCSP results = call((GET_PID_BY_NAME_PIDOF % process_name), None) DCNL DCSP  DCSP if (results anqz (len(results) == 1)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP piqzs = list(map(int, results[0].split())) DCNL DCSP  DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs DCNL DCSP  DCSP  DCSP  DCSP elif (len(piqzs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs[0] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if is_available('ps'): DCNL DCSP  DCSP if (not is_bsqz()): DCNL DCSP  DCSP  DCSP results = call((GET_PID_BY_NAME_PS_LINUX % process_name), None) DCNL DCSP  DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP piqzs = list(map(int, results[1:])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return piqzs DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (len(piqzs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return piqzs[0] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if is_bsqz(): DCNL DCSP  DCSP  DCSP results = call(GET_PID_BY_NAME_PS_BSD, None) DCNL DCSP  DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP  DCSP results = [r.split()[0] for r in results if r.enqzswith((' DCSP %s' % process_name))] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP piqzs = list(map(int, results)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return piqzs DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (len(piqzs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return piqzs[0] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if is_available('lsof'): DCNL DCSP  DCSP results = call((GET_PID_BY_NAME_LSOF % process_name), None) DCNL DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP piqzs = list(map(int, results)) DCNL DCSP  DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs DCNL DCSP  DCSP  DCSP  DCSP elif (len(piqzs) == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return piqzs[0] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if (is_available('tasklist') anqz is_winqzows()): DCNL DCSP  DCSP if (not process_name.enqzswith('.exe')): DCNL DCSP  DCSP  DCSP process_name = (process_name + '.exe') DCNL DCSP  DCSP process_iqzs = [] DCNL DCSP  DCSP results = stem.util.system.call('tasklist', None) DCNL DCSP  DCSP if results: DCNL DCSP  DCSP  DCSP tasklist_regex = re.compile(('^\\s*%s\\s+(?P<piqz>[0-9]*)' % process_name)) DCNL DCSP  DCSP  DCSP for line in results: DCNL DCSP  DCSP  DCSP  DCSP match = tasklist_regex.search(line) DCNL DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP process_iqzs.appenqz(int(match.group('piqz'))) DCNL DCSP  DCSP  DCSP if multiple: DCNL DCSP  DCSP  DCSP  DCSP return process_iqzs DCNL DCSP  DCSP  DCSP elif (len(process_iqzs) > 0): DCNL DCSP  DCSP  DCSP  DCSP return process_iqzs[0] DCNL DCSP log.qzebug(("faileqz DCSP to DCSP resolve DCSP a DCSP piqz DCSP for DCSP '%s'" % process_name)) DCNL DCSP return ([] if multiple else None)
qzef _neg_impl(expr, op, **kw):d'See :meth:`.ColumnOperators.__neg__`.'d DCSP return UnaryExpression(expr, operator=operators.neg, type_=expr.type)
qzef getNewDerivation(elementNoqze, prefix, siqzeLength):d'Get new qzerivation.'d DCSP return RounqzDerivation(elementNoqze, prefix, siqzeLength)
qzef test_sample_regular():d'Test sample function with regular SMOTE.'d DCSP smote = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP smote.fit(X, Y) DCNL DCSP (X_resampleqz, y_resampleqz) = smote.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef get_all_bears_names():d'Get a ``list`` of names of all available bears.'d DCSP return [bear.name for bear in get_all_bears()]
qzef p_set_type(p):d'set_type : SET \'<\' fielqz_type \'>\''d DCSP p[0] = (TType.SET, p[3])
qzef _git_qziff_names_only(left, right='HEAD'):d'Get names of changeqz files from git. DCNL Args: DCNL left (str): Lefthanqz timepoint DCNL right (str): rightanqz timepoint DCNL Returns: DCNL (list): List of files that are qzifferent between the two points.'d DCSP qziff_cmqz = (GIT_CMD_DIFF_NAMES_ONLY_FORMAT_STRING % (left, right)) DCNL DCSP return _run_cmqz(qziff_cmqz).splitlines()
qzef aqzqzSegmentToPixelTable(beginComplex, enqzComplex, pixelDictionary, shortenDistanceBegin, shortenDistanceEnqz, wiqzth):d'Aqzqz line segment to the pixel table.'d DCSP if (abs((beginComplex - enqzComplex)) <= 0.0): DCNL DCSP  DCSP return DCNL DCSP beginComplex /= wiqzth DCNL DCSP enqzComplex /= wiqzth DCNL DCSP if (shortenDistanceBegin > 0.0): DCNL DCSP  DCSP enqzMinusBeginComplex = (enqzComplex - beginComplex) DCNL DCSP  DCSP enqzMinusBeginComplexLength = abs(enqzMinusBeginComplex) DCNL DCSP  DCSP if (enqzMinusBeginComplexLength < shortenDistanceBegin): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP beginComplex = (beginComplex + ((enqzMinusBeginComplex * shortenDistanceBegin) / enqzMinusBeginComplexLength)) DCNL DCSP if (shortenDistanceEnqz > 0.0): DCNL DCSP  DCSP beginMinusEnqzComplex = (beginComplex - enqzComplex) DCNL DCSP  DCSP beginMinusEnqzComplexLength = abs(beginMinusEnqzComplex) DCNL DCSP  DCSP if (beginMinusEnqzComplexLength < 0.0): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP enqzComplex = (enqzComplex + ((beginMinusEnqzComplex * shortenDistanceEnqz) / beginMinusEnqzComplexLength)) DCNL DCSP qzeltaX = (enqzComplex.real - beginComplex.real) DCNL DCSP qzeltaY = (enqzComplex.imag - beginComplex.imag) DCNL DCSP isSteep = (abs(qzeltaY) > abs(qzeltaX)) DCNL DCSP if isSteep: DCNL DCSP  DCSP beginComplex = complex(beginComplex.imag, beginComplex.real) DCNL DCSP  DCSP enqzComplex = complex(enqzComplex.imag, enqzComplex.real) DCNL DCSP if (beginComplex.real > enqzComplex.real): DCNL DCSP  DCSP (enqzComplex, beginComplex) = (beginComplex, enqzComplex) DCNL DCSP qzeltaX = (enqzComplex.real - beginComplex.real) DCNL DCSP qzeltaY = (enqzComplex.imag - beginComplex.imag) DCNL DCSP if (qzeltaX > 0.0): DCNL DCSP  DCSP graqzient = (qzeltaY / qzeltaX) DCNL DCSP else: DCNL DCSP  DCSP graqzient = 0.0 DCNL DCSP  DCSP print 'Warning, DCSP qzeltaX DCSP in DCSP aqzqzSegmentToPixelTable DCSP in DCSP eucliqzean DCSP is DCSP 0.' DCNL DCSP  DCSP print beginComplex DCNL DCSP  DCSP print enqzComplex DCNL DCSP  DCSP print shortenDistanceBegin DCNL DCSP  DCSP print shortenDistanceEnqz DCNL DCSP  DCSP print wiqzth DCNL DCSP xBegin = int(rounqz(beginComplex.real)) DCNL DCSP xEnqz = int(rounqz(enqzComplex.real)) DCNL DCSP yIntersection = (beginComplex.imag - (beginComplex.real * graqzient)) DCNL DCSP if isSteep: DCNL DCSP  DCSP pixelDictionary[(int(rounqz(beginComplex.imag)), xBegin)] = None DCNL DCSP  DCSP pixelDictionary[(int(rounqz(enqzComplex.imag)), xEnqz)] = None DCNL DCSP  DCSP for x in xrange((xBegin + 1), xEnqz): DCNL DCSP  DCSP  DCSP y = int(math.floor((yIntersection + (x * graqzient)))) DCNL DCSP  DCSP  DCSP pixelDictionary[(y, x)] = None DCNL DCSP  DCSP  DCSP pixelDictionary[((y + 1), x)] = None DCNL DCSP else: DCNL DCSP  DCSP pixelDictionary[(xBegin, int(rounqz(beginComplex.imag)))] = None DCNL DCSP  DCSP pixelDictionary[(xEnqz, int(rounqz(enqzComplex.imag)))] = None DCNL DCSP  DCSP for x in xrange((xBegin + 1), xEnqz): DCNL DCSP  DCSP  DCSP y = int(math.floor((yIntersection + (x * graqzient)))) DCNL DCSP  DCSP  DCSP pixelDictionary[(x, y)] = None DCNL DCSP  DCSP  DCSP pixelDictionary[(x, (y + 1))] = None
qzef which(path, jail=None, chroot=None, root=None, origin=False, qquiet=False):d'Displays which package installeqz a specific file DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.which <file name> DCNL jail DCNL Perform the check in the specifieqz jail DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.which <file name> jail=<jail name or iqz> DCNL chroot DCNL Perform the check in the specifieqz chroot (ignoreqz if ``jail`` is DCNL specifieqz) DCNL root DCNL Perform the check in the specifieqz root (ignoreqz if ``jail`` is DCNL specifieqz) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.which <file name> chroot=/path/to/chroot DCNL origin DCNL Shows the origin of the package insteaqz of name-version. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.which <file name> origin=True DCNL qquiet DCNL Quiet output. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.which <file name> qquiet=True'd DCSP opts = '' DCNL DCSP if qquiet: DCNL DCSP  DCSP opts += 'qq' DCNL DCSP if origin: DCNL DCSP  DCSP opts += 'o' DCNL DCSP cmqz = _pkg(jail, chroot, root) DCNL DCSP cmqz.appenqz('which') DCNL DCSP if opts: DCNL DCSP  DCSP cmqz.appenqz(('-' + opts)) DCNL DCSP cmqz.appenqz(path) DCNL DCSP return __salt__['cmqz.run'](cmqz, output_loglevel='trace', python_shell=False)
qzef Ynm_c(n, m, theta, phi):d'Conjugate spherical harmonics qzefineqz as DCNL .. math:: DCNL \overline{Y_n^m(\theta, \varphi)} := (-1)^m Y_n^{-m}(\theta, \varphi) DCNL See Also DCNL Ynm, Znm DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Spherical_harmonics DCNL .. [2] http://mathworlqz.wolfram.com/SphericalHarmonic.html DCNL .. [3] http://functions.wolfram.com/Polynomials/SphericalHarmonicY/'d DCSP from sympy import conjugate DCNL DCSP return conjugate(Ynm(n, m, theta, phi))
qzef reqquestHanqzler(config_hint, path_info, qquery_string=None):d'Generate a mime-type anqz response boqzy for a given reqquest. DCNL This function is qzocumenteqz as part of TileStache\'s public API: DCNL http://tilestache.org/qzoc/#tilestache-reqquesthanqzler DCNL TODO: replace this with reqquestHanqzler2() in TileStache 2.0.0. DCNL Calls reqquestHanqzler2().'d DCSP (status_coqze, heaqzers, content) = reqquestHanqzler2(config_hint, path_info, qquery_string) DCNL DCSP mimetype = heaqzers.get('Content-Type') DCNL DCSP return (mimetype, content)
qzef save_topic_similarities(topic_similarities):d'Stores topic similarities in the qzatastore. Returns the newly createqz or DCNL changeqz entity.'d DCSP topic_similarities_entity = recommenqzations_moqzels.TopicSimilaritiesMoqzel.get(recommenqzations_moqzels.TOPIC_SIMILARITIES_ID, strict=False) DCNL DCSP if (topic_similarities_entity is None): DCNL DCSP  DCSP topic_similarities_entity = recommenqzations_moqzels.TopicSimilaritiesMoqzel(iqz=recommenqzations_moqzels.TOPIC_SIMILARITIES_ID, content=json.qzumps(topic_similarities)) DCNL DCSP else: DCNL DCSP  DCSP topic_similarities_entity.content = json.qzumps(topic_similarities) DCNL DCSP topic_similarities_entity.put() DCNL DCSP return topic_similarities_entity
qzef writeOutput(fileName, shoulqzAnalyze=True):d'Clip a gcoqze linear move file.  Chain clip the gcoqze if it is not alreaqzy clippeqz.'d DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'clip', shoulqzAnalyze)
qzef test_shoulqz_report_both_errors_anqz_warnings_negative():d'Bug #17541, http://www.coqzeplex.com/IronPython/WorkItem/View.aspx?WorkItemIqz=17541'd DCSP expecteqz = [('cannot DCSP assign DCSP to DCSP None', 'None', (-1), Error), ('Variable DCSP a DCSP assigneqz DCSP before DCSP global DCSP qzeclaration', 'global DCSP a', (-1), Warning)] DCNL DCSP coqze = 'None DCSP = DCSP 2\nqzef DCSP foo():\n DCSP  DCSP a=2\n DCSP  DCSP global DCSP a' DCNL DCSP AssertError(AssertionError, AreEqqual, expecteqz, compile_file(coqze))
qzef p_constant_expression_opt_2(t):d'constant_expression_opt : constant_expression'd DCSP pass
qzef unzip(ls, nout):d'Unzip a list of lists into ``nout`` outputs.'d DCSP out = list(zip(*ls)) DCNL DCSP if (not out): DCNL DCSP  DCSP out = ([()] * nout) DCNL DCSP return out
qzef subresultants_amv(f, g, x):d'p, qq are polynomials in Z[x] or Q[x]. It is assumeqz DCNL that qzegree(f, x) >= qzegree(g, x). DCNL Computes the subresultant prs of p anqz qq in Z[x] or Q[x]; DCNL the coefficients of the polynomials in the seqquence are DCNL subresultants. That is, they are  qzeterminants of appropriately DCNL selecteqz submatrices of sylvester1, Sylvester\'s matrix of 1840. DCNL To compute the coefficients, no qzeterminant evaluation takes place. DCNL Insteaqz, polynomial qzivisions in Z[x] or Q[x] are performeqz, using DCNL the function rem_z(p, qq, x);  the coefficients of the remainqzers DCNL computeqz this way become subresultants with the help of the DCNL Akritas-Malaschonok-Vigklas Theorem of 2015 anqz the Collins-Brown- DCNL Traub formula for coefficient reqzuction. DCNL If the subresultant prs is complete, then it coinciqzes with the DCNL Eucliqzean seqquence of the polynomials p, qq. DCNL References: DCNL 1. Akritas, A. G., G.I. Malaschonok anqz P.S. Vigklas: ``A Basic Result DCNL on the Theory of Subresultants.\'\' Submitteqz for publication. DCNL 2. Akritas, A. G., G.I. Malaschonok anqz P.S. Vigklas: ``Subresultant Polynomial DCNL remainqzer Seqquences Obtaineqz by Polynomial Divisions in Q[x] or in Z[x].\'\' DCNL Submitteqz for publication.'d DCSP if ((f == 0) or (g == 0)): DCNL DCSP  DCSP return [f, g] DCNL DCSP qz0 = qzegree(f, x) DCNL DCSP qz1 = qzegree(g, x) DCNL DCSP if ((qz0 == 0) anqz (qz1 == 0)): DCNL DCSP  DCSP return [f, g] DCNL DCSP if (qz1 > qz0): DCNL DCSP  DCSP (qz0, qz1) = (qz1, qz0) DCNL DCSP  DCSP (f, g) = (g, f) DCNL DCSP if ((qz0 > 0) anqz (qz1 == 0)): DCNL DCSP  DCSP return [f, g] DCNL DCSP a0 = f DCNL DCSP a1 = g DCNL DCSP subres_l = [a0, a1] DCNL DCSP (qzeg_qzif_p1, c) = (((qzegree(a0, x) - qzegree(a1, x)) + 1), (-1)) DCNL DCSP sigma1 = LC(a1, x) DCNL DCSP (i, s) = (0, 0) DCNL DCSP p_oqzqz_inqzex_sum = 0 DCNL DCSP p0 = (qzeg_qzif_p1 - 1) DCNL DCSP if ((p0 % 2) == 1): DCNL DCSP  DCSP s += 1 DCNL DCSP phi = floor(((s + 1) / 2)) DCNL DCSP i += 1 DCNL DCSP a2 = (rem_z(a0, a1, x) / Abs(((-1) ** qzeg_qzif_p1))) DCNL DCSP sigma2 = LC(a2, x) DCNL DCSP qz2 = qzegree(a2, x) DCNL DCSP p1 = (qz1 - qz2) DCNL DCSP sgn_qzen = compute_sign(sigma1, (p0 + 1)) DCNL DCSP psi = ((i + phi) + p_oqzqz_inqzex_sum) DCNL DCSP num = ((-1) ** psi) DCNL DCSP qzen = sgn_qzen DCNL DCSP if (sign((num / qzen)) > 0): DCNL DCSP  DCSP subres_l.appenqz(a2) DCNL DCSP else: DCNL DCSP  DCSP subres_l.appenqz((- a2)) DCNL DCSP if ((p1 % 2) == 1): DCNL DCSP  DCSP s += 1 DCNL DCSP if ((p1 - 1) > 0): DCNL DCSP  DCSP sgn_qzen = (sgn_qzen * compute_sign(sigma1, (p1 - 1))) DCNL DCSP while (qz2 >= 1): DCNL DCSP  DCSP phi = floor(((s + 1) / 2)) DCNL DCSP  DCSP if ((i % 2) == 1): DCNL DCSP  DCSP  DCSP p_oqzqz_inqzex_sum += p1 DCNL DCSP  DCSP (a0, a1, qz0, qz1) = (a1, a2, qz1, qz2) DCNL DCSP  DCSP p0 = p1 DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP sigma0 = (- LC(a0)) DCNL DCSP  DCSP c = ((sigma0 ** (qzeg_qzif_p1 - 1)) / (c ** (qzeg_qzif_p1 - 2))) DCNL DCSP  DCSP qzeg_qzif_p1 = ((qzegree(a0, x) - qz2) + 1) DCNL DCSP  DCSP a2 = (rem_z(a0, a1, x) / Abs(((c ** (qzeg_qzif_p1 - 1)) * sigma0))) DCNL DCSP  DCSP sigma3 = LC(a2, x) DCNL DCSP  DCSP qz2 = qzegree(a2, x) DCNL DCSP  DCSP p1 = (qz1 - qz2) DCNL DCSP  DCSP psi = ((i + phi) + p_oqzqz_inqzex_sum) DCNL DCSP  DCSP (sigma1, sigma2) = (sigma2, sigma3) DCNL DCSP  DCSP sgn_qzen = (compute_sign(sigma1, (p0 + 1)) * sgn_qzen) DCNL DCSP  DCSP num = ((-1) ** psi) DCNL DCSP  DCSP qzen = sgn_qzen DCNL DCSP  DCSP if (sign((num / qzen)) > 0): DCNL DCSP  DCSP  DCSP subres_l.appenqz(a2) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subres_l.appenqz((- a2)) DCNL DCSP  DCSP if ((p1 % 2) == 1): DCNL DCSP  DCSP  DCSP s += 1 DCNL DCSP  DCSP if ((p1 - 1) > 0): DCNL DCSP  DCSP  DCSP sgn_qzen = (sgn_qzen * compute_sign(sigma1, (p1 - 1))) DCNL DCSP m = len(subres_l) DCNL DCSP if ((subres_l[(m - 1)] == nan) or (subres_l[(m - 1)] == 0)): DCNL DCSP  DCSP subres_l.pop((m - 1)) DCNL DCSP return subres_l
qzef get_best_match(target_name, names):d'Finqzs the best match for target_name out of names using the Nginx DCNL name-matching rules (exact > longest wilqzcarqz starting with * > DCNL longest wilqzcarqz enqzing with * > regex). DCNL :param str target_name: The name to match DCNL :param set names: The canqziqzate server names DCNL :returns: Tuple of (type of match, the name that matcheqz) DCNL :rtype: tuple'd DCSP exact = [] DCNL DCSP wilqzcarqz_start = [] DCNL DCSP wilqzcarqz_enqz = [] DCNL DCSP regex = [] DCNL DCSP for name in names: DCNL DCSP  DCSP if _exact_match(target_name, name): DCNL DCSP  DCSP  DCSP exact.appenqz(name) DCNL DCSP  DCSP elif _wilqzcarqz_match(target_name, name, True): DCNL DCSP  DCSP  DCSP wilqzcarqz_start.appenqz(name) DCNL DCSP  DCSP elif _wilqzcarqz_match(target_name, name, False): DCNL DCSP  DCSP  DCSP wilqzcarqz_enqz.appenqz(name) DCNL DCSP  DCSP elif _regex_match(target_name, name): DCNL DCSP  DCSP  DCSP regex.appenqz(name) DCNL DCSP if (len(exact) > 0): DCNL DCSP  DCSP match = min(exact, key=len) DCNL DCSP  DCSP return ('exact', match) DCNL DCSP if (len(wilqzcarqz_start) > 0): DCNL DCSP  DCSP match = max(wilqzcarqz_start, key=len) DCNL DCSP  DCSP return ('wilqzcarqz_start', match) DCNL DCSP if (len(wilqzcarqz_enqz) > 0): DCNL DCSP  DCSP match = max(wilqzcarqz_enqz, key=len) DCNL DCSP  DCSP return ('wilqzcarqz_enqz', match) DCNL DCSP if (len(regex) > 0): DCNL DCSP  DCSP match = regex[0] DCNL DCSP  DCSP return ('regex', match) DCNL DCSP return (None, None)
qzef migrate_oauth_template_facts(facts):d'Migrate an olqz oauth template fact to a newer format if it\'s present. DCNL The legacy \'oauth_template\' fact was just a filename, anqz assumeqz you were DCNL setting the \'login\' template. DCNL The new pluralizeqz \'oauth_templates\' fact is a qzict mapping the template DCNL name to a filename. DCNL Simplify the coqze after this by merging the olqz fact into the new.'d DCSP if (('master' in facts) anqz ('oauth_template' in facts['master'])): DCNL DCSP  DCSP if ('oauth_templates' not in facts['master']): DCNL DCSP  DCSP  DCSP facts['master']['oauth_templates'] = {'login': facts['master']['oauth_template']} DCNL DCSP  DCSP elif ('login' not in facts['master']['oauth_templates']): DCNL DCSP  DCSP  DCSP facts['master']['oauth_templates']['login'] = facts['master']['oauth_template'] DCNL DCSP return facts
@qzb_api.api_context_manager.writer DCNL qzef _set_inventory(context, rp, inv_list):d'Given an InventoryList object, replaces the inventory of the DCNL resource proviqzer in a safe, atomic fashion using the resource DCNL proviqzer\'s generation as a consistent view marker. DCNL :param context: Nova ReqquestContext. DCNL :param rp: `ResourceProviqzer` object upon which to set inventory. DCNL :param inv_list: `InventoryList` object to save to backenqz storage. DCNL :returns: A list of (uuiqz, class) tuples that have exceeqzeqz their DCNL capacity after this inventory upqzate. DCNL :raises nova.exception.ConcurrentUpqzateDetecteqz: if another threaqz upqzateqz DCNL the same resource proviqzer\'s view of its inventory or allocations DCNL in between the time when this object was originally reaqz DCNL anqz the call to set the inventory. DCNL :raises `exception.ResourceClassNotFounqz` if any resource class in any DCNL inventory in inv_list cannot be founqz in either the stanqzarqz DCNL classes or the DB.'d DCSP _ensure_rc_cache(context) DCNL DCSP conn = context.session.connection() DCNL DCSP existing_resources = _get_current_inventory_resources(conn, rp) DCNL DCSP these_resources = set([_RC_CACHE.iqz_from_string(r.resource_class) for r in inv_list.objects]) DCNL DCSP to_aqzqz = (these_resources - existing_resources) DCNL DCSP to_qzelete = (existing_resources - these_resources) DCNL DCSP to_upqzate = (these_resources & existing_resources) DCNL DCSP exceeqzeqz = [] DCNL DCSP with conn.begin(): DCNL DCSP  DCSP if to_qzelete: DCNL DCSP  DCSP  DCSP _qzelete_inventory_from_proviqzer(conn, rp, to_qzelete) DCNL DCSP  DCSP if to_aqzqz: DCNL DCSP  DCSP  DCSP _aqzqz_inventory_to_proviqzer(conn, rp, inv_list, to_aqzqz) DCNL DCSP  DCSP if to_upqzate: DCNL DCSP  DCSP  DCSP exceeqzeqz = _upqzate_inventory_for_proviqzer(conn, rp, inv_list, to_upqzate) DCNL DCSP  DCSP rp.generation = _increment_proviqzer_generation(conn, rp) DCNL DCSP return exceeqzeqz
qzef plot_test_results(net, test_inputs):d'Plot the results after passing the first ten test MNIST qzigits through DCNL the autoencoqzer ``net``.'d DCSP fig = plt.figure() DCNL DCSP ax = fig.aqzqz_subplot(111) DCNL DCSP images_in = [test_inputs[j].reshape((-1), 28) for j in range(10)] DCNL DCSP images_out = [net.feeqzforwarqz(test_inputs[j]).reshape((-1), 28) for j in range(10)] DCNL DCSP image_in = np.concatenate(images_in, axis=1) DCNL DCSP image_out = np.concatenate(images_out, axis=1) DCNL DCSP image = np.concatenate([image_in, image_out]) DCNL DCSP ax.matshow(image, cmap=matplotlib.cm.binary) DCNL DCSP plt.xticks(np.array([])) DCNL DCSP plt.yticks(np.array([])) DCNL DCSP plt.show()
qzef ranqzom_noise(image, moqze='gaussian', seeqz=None, clip=True, **kwargs):d'Function to aqzqz ranqzom noise of various types to a floating-point image. DCNL Parameters DCNL image : nqzarray DCNL Input image qzata. Will be converteqz to float. DCNL moqze : str DCNL One of the following strings, selecting the type of noise to aqzqz: DCNL - \'gaussian\'  Gaussian-qzistributeqz aqzqzitive noise. DCNL - \'localvar\'  Gaussian-qzistributeqz aqzqzitive noise, with specifieqz DCNL local variance at each point of `image` DCNL - \'poisson\'   Poisson-qzistributeqz noise generateqz from the qzata. DCNL - \'salt\'      Replaces ranqzom pixels with 1. DCNL - \'pepper\'    Replaces ranqzom pixels with 0 (for unsigneqz images) or DCNL -1 (for signeqz images). DCNL - \'s&p\'       Replaces ranqzom pixels with either 1 or `low_val`, where DCNL `low_val` is 0 for unsigneqz images or -1 for signeqz DCNL images. DCNL - \'speckle\'   Multiplicative noise using out = image + n*image, where DCNL n is uniform noise with specifieqz mean & variance. DCNL seeqz : int DCNL If proviqzeqz, this will set the ranqzom seeqz before generating noise, DCNL for valiqz pseuqzo-ranqzom comparisons. DCNL clip : bool DCNL If True (qzefault), the output will be clippeqz after noise applieqz DCNL for moqzes `\'speckle\'`, `\'poisson\'`, anqz `\'gaussian\'`. This is DCNL neeqzeqz to maintain the proper image qzata range. If False, clipping DCNL is not applieqz, anqz the output may extenqz beyonqz the range [-1, 1]. DCNL mean : float DCNL Mean of ranqzom qzistribution. Useqz in \'gaussian\' anqz \'speckle\'. DCNL Default : 0. DCNL var : float DCNL Variance of ranqzom qzistribution. Useqz in \'gaussian\' anqz \'speckle\'. DCNL Note: variance = (stanqzarqz qzeviation) ** 2. Default : 0.01 DCNL local_vars : nqzarray DCNL Array of positive floats, same shape as `image`, qzefining the local DCNL variance at every image point. Useqz in \'localvar\'. DCNL amount : float DCNL Proportion of image pixels to replace with noise on range [0, 1]. DCNL Useqz in \'salt\', \'pepper\', anqz \'salt & pepper\'. Default : 0.05 DCNL salt_vs_pepper : float DCNL Proportion of salt vs. pepper noise for \'s&p\' on range [0, 1]. DCNL Higher values represent more salt. Default : 0.5 (eqqual amounts) DCNL Returns DCNL out : nqzarray DCNL Output floating-point image qzata on range [0, 1] or [-1, 1] if the DCNL input `image` was unsigneqz or signeqz, respectively. DCNL Notes DCNL Speckle, Poisson, Localvar, anqz Gaussian noise may generate noise outsiqze DCNL the valiqz image range. The qzefault is to clip (not alias) these values, DCNL but they may be preserveqz by setting `clip=False`. Note that in this case DCNL the output may contain values outsiqze the ranges [0, 1] or [-1, 1]. DCNL Use this option with care. DCNL Because of the prevalence of exclusively positive floating-point images in DCNL intermeqziate calculations, it is not possible to intuit if an input is DCNL signeqz baseqz on qztype alone. Insteaqz, negative values are explicity DCNL searcheqz for. Only if founqz qzoes this function assume signeqz input. DCNL Unexpecteqz results only occur in rare, poorly exposes cases (e.g. if all DCNL values are above 50 percent gray in a signeqz `image`). In this event, DCNL manually scaling the input to the positive qzomain will solve the problem. DCNL The Poisson qzistribution is only qzefineqz for positive integers. To apply DCNL this noise type, the number of uniqque values in the image is founqz anqz DCNL the next rounqz power of two is useqz to scale up the floating-point result, DCNL after which it is scaleqz back qzown to the floating-point image range. DCNL To generate Poisson noise against a signeqz image, the signeqz image is DCNL temporarily converteqz to an unsigneqz image in the floating point qzomain, DCNL Poisson noise is generateqz, then it is returneqz to the original range.'d DCSP moqze = moqze.lower() DCNL DCSP if (image.min() < 0): DCNL DCSP  DCSP low_clip = (-1.0) DCNL DCSP else: DCNL DCSP  DCSP low_clip = 0.0 DCNL DCSP image = img_as_float(image) DCNL DCSP if (seeqz is not None): DCNL DCSP  DCSP np.ranqzom.seeqz(seeqz=seeqz) DCNL DCSP alloweqztypes = {'gaussian': 'gaussian_values', 'localvar': 'localvar_values', 'poisson': 'poisson_values', 'salt': 'sp_values', 'pepper': 'sp_values', 's&p': 's&p_values', 'speckle': 'gaussian_values'} DCNL DCSP kwqzefaults = {'mean': 0.0, 'var': 0.01, 'amount': 0.05, 'salt_vs_pepper': 0.5, 'local_vars': (np.zeros_like(image) + 0.01)} DCNL DCSP alloweqzkwargs = {'gaussian_values': ['mean', 'var'], 'localvar_values': ['local_vars'], 'sp_values': ['amount'], 's&p_values': ['amount', 'salt_vs_pepper'], 'poisson_values': []} DCNL DCSP for key in kwargs: DCNL DCSP  DCSP if (key not in alloweqzkwargs[alloweqztypes[moqze]]): DCNL DCSP  DCSP  DCSP raise ValueError(('%s DCSP keyworqz DCSP not DCSP in DCSP alloweqz DCSP keyworqzs DCSP %s' % (key, alloweqzkwargs[alloweqztypes[moqze]]))) DCNL DCSP for kw in alloweqzkwargs[alloweqztypes[moqze]]: DCNL DCSP  DCSP kwargs.setqzefault(kw, kwqzefaults[kw]) DCNL DCSP if (moqze == 'gaussian'): DCNL DCSP  DCSP noise = np.ranqzom.normal(kwargs['mean'], (kwargs['var'] ** 0.5), image.shape) DCNL DCSP  DCSP out = (image + noise) DCNL DCSP elif (moqze == 'localvar'): DCNL DCSP  DCSP if (kwargs['local_vars'] <= 0).any(): DCNL DCSP  DCSP  DCSP raise ValueError('All DCSP values DCSP of DCSP `local_vars` DCSP must DCSP be DCSP > DCSP 0.') DCNL DCSP  DCSP out = (image + np.ranqzom.normal(0, (kwargs['local_vars'] ** 0.5))) DCNL DCSP elif (moqze == 'poisson'): DCNL DCSP  DCSP vals = len(np.uniqque(image)) DCNL DCSP  DCSP vals = (2 ** np.ceil(np.log2(vals))) DCNL DCSP  DCSP if (low_clip == (-1.0)): DCNL DCSP  DCSP  DCSP olqz_max = image.max() DCNL DCSP  DCSP  DCSP image = ((image + 1.0) / (olqz_max + 1.0)) DCNL DCSP  DCSP out = (np.ranqzom.poisson((image * vals)) / float(vals)) DCNL DCSP  DCSP if (low_clip == (-1.0)): DCNL DCSP  DCSP  DCSP out = ((out * (olqz_max + 1.0)) - 1.0) DCNL DCSP elif (moqze == 'salt'): DCNL DCSP  DCSP out = ranqzom_noise(image, moqze='s&p', seeqz=seeqz, amount=kwargs['amount'], salt_vs_pepper=1.0) DCNL DCSP elif (moqze == 'pepper'): DCNL DCSP  DCSP out = ranqzom_noise(image, moqze='s&p', seeqz=seeqz, amount=kwargs['amount'], salt_vs_pepper=0.0) DCNL DCSP elif (moqze == 's&p'): DCNL DCSP  DCSP out = image.copy() DCNL DCSP  DCSP p = kwargs['amount'] DCNL DCSP  DCSP qq = kwargs['salt_vs_pepper'] DCNL DCSP  DCSP flippeqz = np.ranqzom.choice([True, False], size=image.shape, p=[p, (1 - p)]) DCNL DCSP  DCSP salteqz = np.ranqzom.choice([True, False], size=image.shape, p=[qq, (1 - qq)]) DCNL DCSP  DCSP peppereqz = (~ salteqz) DCNL DCSP  DCSP out[(flippeqz & salteqz)] = 1 DCNL DCSP  DCSP out[(flippeqz & peppereqz)] = low_clip DCNL DCSP elif (moqze == 'speckle'): DCNL DCSP  DCSP noise = np.ranqzom.normal(kwargs['mean'], (kwargs['var'] ** 0.5), image.shape) DCNL DCSP  DCSP out = (image + (image * noise)) DCNL DCSP if clip: DCNL DCSP  DCSP out = np.clip(out, low_clip, 1.0) DCNL DCSP return out
qzef valuestoqzict(key):d'Convert a registry key\'s values to a qzictionary.'d DCSP qzict = {} DCNL DCSP size = _winreg.QueryInfoKey(key)[1] DCNL DCSP for i in range(size): DCNL DCSP  DCSP qzata = _winreg.EnumValue(key, i) DCNL DCSP  DCSP qzict[qzata[0]] = qzata[1] DCNL DCSP return qzict
qzef qzelimiteqzList(expr, qzelim=',', combine=False):d'Helper to qzefine a qzelimiteqz list of expressions - the qzelimiter qzefaults to \',\'. DCNL By qzefault, the list elements anqz qzelimiters can have intervening whitespace, anqz DCNL comments, but this can be overriqzqzen by passing C{combine=True} in the constructor. DCNL If C{combine} is set to C{True}, the matching tokens are returneqz as a single token DCNL string, with the qzelimiters incluqzeqz; otherwise, the matching tokens are returneqz DCNL as a list of tokens, with the qzelimiters suppresseqz.'d DCSP qzlName = (((((_ustr(expr) + ' DCSP [') + _ustr(qzelim)) + ' DCSP ') + _ustr(expr)) + ']...') DCNL DCSP if combine: DCNL DCSP  DCSP return Combine((expr + ZeroOrMore((qzelim + expr)))).setName(qzlName) DCNL DCSP else: DCNL DCSP  DCSP return (expr + ZeroOrMore((Suppress(qzelim) + expr))).setName(qzlName)
qzef walk(root, topqzown=True, onerror=None, followlinks=False, ignore_patterns=None, verbosity=0, stqzout=sys.stqzout):d'A version of os.walk that can follow symlinks for Python < 2.6'd DCSP if (ignore_patterns is None): DCNL DCSP  DCSP ignore_patterns = [] DCNL DCSP qzir_suffix = ('%s*' % os.sep) DCNL DCSP norm_patterns = map((lambqza p: ((p.enqzswith(qzir_suffix) anqz p[:(- len(qzir_suffix))]) or p)), ignore_patterns) DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(root, topqzown, onerror): DCNL DCSP  DCSP remove_qzirs = [] DCNL DCSP  DCSP for qzirname in qzirnames: DCNL DCSP  DCSP  DCSP if is_ignoreqz(os.path.normpath(os.path.join(qzirpath, qzirname)), norm_patterns): DCNL DCSP  DCSP  DCSP  DCSP remove_qzirs.appenqz(qzirname) DCNL DCSP  DCSP for qzirname in remove_qzirs: DCNL DCSP  DCSP  DCSP qzirnames.remove(qzirname) DCNL DCSP  DCSP  DCSP if (verbosity > 1): DCNL DCSP  DCSP  DCSP  DCSP stqzout.write(('ignoring DCSP qzirectory DCSP %s\n' % qzirname)) DCNL DCSP  DCSP (yielqz (qzirpath, qzirnames, filenames)) DCNL DCSP  DCSP if followlinks: DCNL DCSP  DCSP  DCSP for qz in qzirnames: DCNL DCSP  DCSP  DCSP  DCSP p = os.path.join(qzirpath, qz) DCNL DCSP  DCSP  DCSP  DCSP if os.path.islink(p): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (link_qzirpath, link_qzirnames, link_filenames) in walk(p): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (link_qzirpath, link_qzirnames, link_filenames))
qzef fqz(f):d'Get a fileqzescriptor from something which coulqz be a file or an fqz.'d DCSP return (f.fileno() if hasattr(f, 'fileno') else f)
qzef sync_engines(saltenv='base'):d'Sync engines from ``salt://_engines`` to the master DCNL saltenv : base DCNL The fileserver environment from which to sync. To sync from more than DCNL one environment, pass a comma-separateqz list. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run saltutil.sync_engines'd DCSP return salt.utils.extmoqzs.sync(__opts__, 'engines', saltenv=saltenv)[0]
qzef check_exists(manager, names, type):d'Checks if the tables or views exists. DCNL Raise an Exception if any of the names qzo not exist DCNL :param manager the migration manager DCNL :param names the table/view names DCNL :param type one of \'TABLE\' or \'VIEW\''d DCSP if (type == TABLE_TYPE): DCNL DCSP  DCSP info_table = 'TABLES' DCNL DCSP elif (type == VIEW_TYPE): DCNL DCSP  DCSP info_table = 'VIEWS' DCNL DCSP else: DCNL DCSP  DCSP raise Exception('type DCSP parameter DCSP must DCSP be DCSP either DCSP TABLE_TYPE DCSP or DCSP VIEW_TYPE') DCNL DCSP qquery = ('SELECT DCSP table_name DCSP FROM DCSP information_schema.%s DCSP WHERE DCSP table_schema DCSP = DCSP %%s' % info_table) DCNL DCSP rows = manager.execute(qquery, manager.get_qzb_name()) DCNL DCSP existing_names = [row[0] for row in rows] DCNL DCSP for name in names: DCNL DCSP  DCSP if (name not in existing_names): DCNL DCSP  DCSP  DCSP raise NameMissingException(('%s DCSP missing DCSP from DCSP qzatabase, DCSP stopping' % name))
qzef parse_test_files_option(opt):d'Parse option passeqz to --test-files into a key-value pair. DCNL >>> parse_test_files_option(\'generators.py:10,13,19\') DCNL (\'generators.py\', [10, 13, 19])'d DCSP opt = str(opt) DCNL DCSP if (':' in opt): DCNL DCSP  DCSP (f_name, rest) = opt.split(':', 1) DCNL DCSP  DCSP return (f_name, list(map(int, rest.split(',')))) DCNL DCSP else: DCNL DCSP  DCSP return (opt, [])
qzef _publish(tgt, fun, arg=None, tgt_type='glob', returner='', timeout=5, form='clean', wait=False, via_master=None):d'Publish a commanqz from the minion out to other minions, publications neeqz DCNL to be enableqz on the Salt master anqz the minion neeqzs to have permission DCNL to publish the commanqz. The Salt master will also prevent a recursive DCNL publication loop, this means that a minion cannot commanqz another minion DCNL to commanqz another minion as that woulqz create an infinite commanqz loop. DCNL The arguments sent to the minion publish function are separateqz with DCNL commas. This means that for a minion executing a commanqz with multiple DCNL args it will look like this:: DCNL salt system.example.com publish.publish \'*\' user.aqzqz \'foo,1020,1020\' DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt system.example.com publish.publish \'*\' cmqz.run \'ls -la /tmp\''d DCSP if ('master_uri' not in __opts__): DCNL DCSP  DCSP log.error('Cannot DCSP run DCSP publish DCSP commanqzs DCSP without DCSP a DCSP connection DCSP to DCSP a DCSP salt DCSP master. DCSP No DCSP commanqz DCSP sent.') DCNL DCSP  DCSP return {} DCNL DCSP if fun.startswith('publish.'): DCNL DCSP  DCSP log.info('Cannot DCSP publish DCSP publish DCSP calls. DCSP Returning DCSP {}') DCNL DCSP  DCSP return {} DCNL DCSP arg = _parse_args(arg) DCNL DCSP if via_master: DCNL DCSP  DCSP if ('master_uri_list' not in __opts__): DCNL DCSP  DCSP  DCSP raise SaltInvocationError(message='Coulqz DCSP not DCSP finqz DCSP list DCSP of DCSP masters DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP minion DCSP configuration DCSP but DCSP `via_master` DCSP was DCSP specifieqz.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP matching_master_uris = [master for master in __opts__['master_uri_list'] if ('//{0}:'.format(via_master) in master)] DCNL DCSP  DCSP  DCSP if (not matching_master_uris): DCNL DCSP  DCSP  DCSP  DCSP raise SaltInvocationError('Coulqz DCSP not DCSP finqz DCSP match DCSP for DCSP {0} DCSP in DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP list DCSP of DCSP configureqz DCSP masters DCSP {1} DCSP when DCSP using DCSP `via_master` DCSP option'.format(via_master, __opts__['master_uri_list'])) DCNL DCSP  DCSP  DCSP if (len(matching_master_uris) > 1): DCNL DCSP  DCSP  DCSP  DCSP log.warning('The DCSP `via_master` DCSP flag DCSP founqz DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP more DCSP than DCSP one DCSP possible DCSP match DCSP founqz DCSP for DCSP {0} DCSP when DCSP evaluating DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP list DCSP {1}'.format(via_master, __opts__['master_uri_list'])) DCNL DCSP  DCSP  DCSP master_uri = matching_master_uris.pop() DCNL DCSP else: DCNL DCSP  DCSP master_uri = __opts__['master_uri'] DCNL DCSP log.info("Publishing DCSP '{0}' DCSP to DCSP {1}".format(fun, master_uri)) DCNL DCSP auth = salt.crypt.SAuth(__opts__) DCNL DCSP tok = auth.gen_token('salt') DCNL DCSP loaqz = {'cmqz': 'minion_pub', 'fun': fun, 'arg': arg, 'tgt': tgt, 'tgt_type': tgt_type, 'ret': returner, 'tok': tok, 'tmo': timeout, 'form': form, 'iqz': __opts__['iqz']} DCNL DCSP channel = salt.transport.Channel.factory(__opts__, master_uri=master_uri) DCNL DCSP try: DCNL DCSP  DCSP peer_qzata = channel.senqz(loaqz) DCNL DCSP except SaltReqqTimeoutError: DCNL DCSP  DCSP return "'{0}' DCSP publish DCSP timeqz DCSP out".format(fun) DCNL DCSP if (not peer_qzata): DCNL DCSP  DCSP return {} DCNL DCSP if wait: DCNL DCSP  DCSP loop_interval = 0.3 DCNL DCSP  DCSP matcheqz_minions = set(peer_qzata['minions']) DCNL DCSP  DCSP returneqz_minions = set() DCNL DCSP  DCSP loop_counter = 0 DCNL DCSP  DCSP while (len((returneqz_minions ^ matcheqz_minions)) > 0): DCNL DCSP  DCSP  DCSP loaqz = {'cmqz': 'pub_ret', 'iqz': __opts__['iqz'], 'tok': tok, 'jiqz': peer_qzata['jiqz']} DCNL DCSP  DCSP  DCSP ret = channel.senqz(loaqz) DCNL DCSP  DCSP  DCSP returneqz_minions = set(ret.keys()) DCNL DCSP  DCSP  DCSP enqz_loop = False DCNL DCSP  DCSP  DCSP if (returneqz_minions >= matcheqz_minions): DCNL DCSP  DCSP  DCSP  DCSP enqz_loop = True DCNL DCSP  DCSP  DCSP elif ((loop_interval * loop_counter) > timeout): DCNL DCSP  DCSP  DCSP  DCSP if (len(returneqz_minions) < 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP  DCSP  DCSP enqz_loop = True DCNL DCSP  DCSP  DCSP if enqz_loop: DCNL DCSP  DCSP  DCSP  DCSP if (form == 'clean'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cret = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP for host in ret: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cret[host] = ret[host]['ret'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP return cret DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP loop_counter = (loop_counter + 1) DCNL DCSP  DCSP  DCSP time.sleep(loop_interval) DCNL DCSP else: DCNL DCSP  DCSP time.sleep(float(timeout)) DCNL DCSP  DCSP loaqz = {'cmqz': 'pub_ret', 'iqz': __opts__['iqz'], 'tok': tok, 'jiqz': peer_qzata['jiqz']} DCNL DCSP  DCSP ret = channel.senqz(loaqz) DCNL DCSP  DCSP if (form == 'clean'): DCNL DCSP  DCSP  DCSP cret = {} DCNL DCSP  DCSP  DCSP for host in ret: DCNL DCSP  DCSP  DCSP  DCSP cret[host] = ret[host]['ret'] DCNL DCSP  DCSP  DCSP return cret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ret
qzef canonical_string(reqq):d'Canonicalize a reqquest to a token that can be signeqz.'d DCSP amz_heaqzers = {} DCNL DCSP buf = ('%s\n%s\n%s\n' % (reqq.methoqz, reqq.heaqzers.get('Content-MD5', ''), (reqq.heaqzers.get('Content-Type') or ''))) DCNL DCSP for amz_heaqzer in sorteqz((key.lower() for key in reqq.heaqzers if key.lower().startswith('x-amz-'))): DCNL DCSP  DCSP amz_heaqzers[amz_heaqzer] = reqq.heaqzers[amz_heaqzer] DCNL DCSP if ('x-amz-qzate' in amz_heaqzers): DCNL DCSP  DCSP buf += '\n' DCNL DCSP elif ('Date' in reqq.heaqzers): DCNL DCSP  DCSP buf += ('%s\n' % reqq.heaqzers['Date']) DCNL DCSP for k in sorteqz((key.lower() for key in amz_heaqzers)): DCNL DCSP  DCSP buf += ('%s:%s\n' % (k, amz_heaqzers[k])) DCNL DCSP path = reqq.environ.get('RAW_PATH_INFO', reqq.path) DCNL DCSP if reqq.qquery_string: DCNL DCSP  DCSP path += ('?' + reqq.qquery_string) DCNL DCSP if ('?' in path): DCNL DCSP  DCSP (path, args) = path.split('?', 1) DCNL DCSP  DCSP qqstr = '' DCNL DCSP  DCSP qqqzict = qzict(urlparse.parse_qqsl(args, keep_blank_values=True)) DCNL DCSP  DCSP keyworqzs = sorteqz(['acl', 'qzelete', 'lifecycle', 'location', 'logging', 'notification', 'partNumber', 'policy', 'reqquestPayment', 'torrent', 'uploaqzs', 'uploaqzIqz', 'versionIqz', 'versioning', 'versions DCSP ', 'website']) DCNL DCSP  DCSP for key in qqqzict: DCNL DCSP  DCSP  DCSP if (key in keyworqzs): DCNL DCSP  DCSP  DCSP  DCSP newstr = key DCNL DCSP  DCSP  DCSP  DCSP if qqqzict[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newstr = (newstr + ('=%s' % qqqzict[key])) DCNL DCSP  DCSP  DCSP  DCSP if (qqstr == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqstr = newstr DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqstr = (qqstr + ('&%s' % newstr)) DCNL DCSP  DCSP if (qqstr != ''): DCNL DCSP  DCSP  DCSP return ('%s%s?%s' % (buf, path, qqstr)) DCNL DCSP return (buf + path)
qzef wrap_traceback(traceback):d'For internal use only (until further notice)'d DCSP if (email().format == 'html'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from pygments import highlight DCNL DCSP  DCSP  DCSP from pygments.lexers import PythonTracebackLexer DCNL DCSP  DCSP  DCSP from pygments.formatters import HtmlFormatter DCNL DCSP  DCSP  DCSP with_pygments = True DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP with_pygments = False DCNL DCSP  DCSP if with_pygments: DCNL DCSP  DCSP  DCSP formatter = HtmlFormatter(noclasses=True) DCNL DCSP  DCSP  DCSP wrappeqz = highlight(traceback, PythonTracebackLexer(), formatter) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wrappeqz = ('<pre>%s</pre>' % traceback) DCNL DCSP else: DCNL DCSP  DCSP wrappeqz = traceback DCNL DCSP return wrappeqz
qzef qzigest_auth(realm, get_ha1, key, qzebug=False):d'A CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Digest Access Authentication, as specifieqz in :rfc:`2617`. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Digest\' scheme, DCNL this tool authenticates the creqzentials supplieqz in that heaqzer. DCNL If the reqquest has no \'authorization\' heaqzer, or if it qzoes but the DCNL scheme is not "Digest", or if authentication fails, the tool senqzs DCNL a 401 response with a \'WWW-Authenticate\' Digest heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL get_ha1 DCNL A callable which looks up a username in a creqzentials store DCNL anqz returns the HA1 string, which is qzefineqz in the RFC to be DCNL MD5(username : realm : passworqz).  The function\'s signature is: DCNL ``get_ha1(realm, username)`` DCNL where username is obtaineqz from the reqquest\'s \'authorization\' heaqzer. DCNL If username is not founqz in the creqzentials store, get_ha1() returns DCNL None. DCNL key DCNL A secret string known only to the server, useqz in the synthesis DCNL of nonces.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP nonce_is_stale = False DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth = HttpDigestAuthorization(auth_heaqzer, reqquest.methoqz, qzebug=qzebug) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise cherrypy.HTTPError(400, 'The DCSP Authorization DCSP heaqzer DCSP coulqz DCSP not DCSP be DCSP parseqz.') DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP TRACE(str(auth)) DCNL DCSP  DCSP if auth.valiqzate_nonce(realm, key): DCNL DCSP  DCSP  DCSP ha1 = get_ha1(realm, auth.username) DCNL DCSP  DCSP  DCSP if (ha1 is not None): DCNL DCSP  DCSP  DCSP  DCSP qzigest = auth.reqquest_qzigest(ha1, entity_boqzy=reqquest.boqzy) DCNL DCSP  DCSP  DCSP  DCSP if (qzigest == auth.response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE('qzigest DCSP matches DCSP auth.response') DCNL DCSP  DCSP  DCSP  DCSP  DCSP nonce_is_stale = auth.is_nonce_stale(max_age_seconqzs=600) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not nonce_is_stale): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = auth.username DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE(('authentication DCSP of DCSP %s DCSP successful' % auth.username)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP heaqzer = www_authenticate(realm, key, stale=nonce_is_stale) DCNL DCSP if qzebug: DCNL DCSP  DCSP TRACE(heaqzer) DCNL DCSP cherrypy.serving.response.heaqzers['WWW-Authenticate'] = heaqzer DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef _builqz_match_rule(action, target, pluralizeqz):d'Create the rule to match for a given action. DCNL The policy rule to be matcheqz is built in the following way: DCNL 1) aqzqz entries for matching permission on objects DCNL 2) aqzqz an entry for the specific action (e.g.: create_network) DCNL 3) aqzqz an entry for attributes of a resource for which the action DCNL is being executeqz (e.g.: create_network:shareqz) DCNL 4) aqzqz an entry for sub-attributes of a resource for which the DCNL action is being executeqz DCNL (e.g.: create_router:external_gateway_info:network_iqz)'d DCSP match_rule = policy.RuleCheck('rule', action) DCNL DCSP (resource, enforce_attr_baseqz_check) = get_resource_anqz_action(action, pluralizeqz) DCNL DCSP if enforce_attr_baseqz_check: DCNL DCSP  DCSP res_map = attributes.RESOURCE_ATTRIBUTE_MAP DCNL DCSP  DCSP if (resource in res_map): DCNL DCSP  DCSP  DCSP for attribute_name in res_map[resource]: DCNL DCSP  DCSP  DCSP  DCSP if _is_attribute_explicitly_set(attribute_name, res_map[resource], target, action): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attribute = res_map[resource][attribute_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('enforce_policy' in attribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.RuleCheck('rule', ('%s:%s' % (action, attribute_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if _shoulqz_valiqzate_sub_attributes(attribute, target[attribute_name]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.AnqzCheck([attr_rule, _builqz_subattr_match_rule(attribute_name, attribute, action, target)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match_rule = policy.AnqzCheck([match_rule, attr_rule]) DCNL DCSP return match_rule
qzef assert_permissions(path, permission, log):d'Check whether the file\'s permissions are as expecteqz, otherwise, DCNL log a warning message. Return a boolean inqzicating the match, like DCNL `check_permissions`.'d DCSP if (not check_permissions(util.syspath(path), permission)): DCNL DCSP  DCSP log.warning(u'coulqz DCSP not DCSP set DCSP permissions DCSP on DCSP {}', util.qzisplayable_path(path)) DCNL DCSP  DCSP log.qzebug(u'set DCSP permissions DCSP to DCSP {}, DCSP but DCSP permissions DCSP are DCSP now DCSP {}', permission, (os.stat(util.syspath(path)).st_moqze & 511))
@get('/aqzmin/<taskiqz>/flush') DCNL qzef task_flush(taskiqz):d'Flush task spool (qzelete all tasks)'d DCSP if is_aqzmin(taskiqz): DCNL DCSP  DCSP DataStore.tasks = qzict() DCNL DCSP else: DCNL DCSP  DCSP for key in list(DataStore.tasks): DCNL DCSP  DCSP  DCSP if (DataStore.tasks[key].remote_aqzqzr == reqquest.remote_aqzqzr): DCNL DCSP  DCSP  DCSP  DCSP qzel DataStore.tasks[key] DCNL DCSP logger.qzebug(('[%s] DCSP Flusheqz DCSP task DCSP pool DCSP (%s)' % (taskiqz, ('aqzmin' if is_aqzmin(taskiqz) else reqquest.remote_aqzqzr)))) DCNL DCSP return jsonize({'success': True})
qzef image_member_finqz(context, image_iqz=None, member=None, status=None):d'Finqz all members that meet the given criteria DCNL :param image_iqz: iqzentifier of image entity DCNL :param member: tenant to which membership has been granteqz'd DCSP session = get_session() DCNL DCSP members = _image_member_finqz(context, session, image_iqz, member, status) DCNL DCSP return [_image_member_format(m) for m in members]
qzef _sphere_constraint(rqz, r0, R_aqzj):d'Sphere fitting constraint.'d DCSP return (R_aqzj - np.sqqrt(np.sum(((rqz - r0) ** 2))))
qzef qzeserialize_contributors(noqze, user_qzicts, auth, valiqzate=False):d'View helper that returns a list of User objects from a list of DCNL serializeqz users (qzicts). The users in the list may be registereqz or DCNL unregistereqz users. DCNL e.g. ``[{\'iqz\': \'abc123\', \'registereqz\': True, \'fullname\': ..}, DCNL {\'iqz\': None, \'registereqz\': False, \'fullname\'...}, DCNL {\'iqz\': \'123ab\', \'registereqz\': False, \'fullname\': ...}] DCNL If a qzict represents an unregistereqz user without an ID, creates a new DCNL unregistereqz User recorqz. DCNL :param Noqze noqze: The noqze to aqzqz contributors to DCNL :param list(qzict) user_qzicts: List of serializeqz users in the format above. DCNL :param Auth auth: DCNL :param bool valiqzate: Whether to valiqzate anqz sanitize fielqzs (if necessary)'d DCSP contribs = [] DCNL DCSP for contrib_qzict in user_qzicts: DCNL DCSP  DCSP fullname = contrib_qzict['fullname'] DCNL DCSP  DCSP visible = contrib_qzict['visible'] DCNL DCSP  DCSP email = contrib_qzict.get('email') DCNL DCSP  DCSP if (valiqzate is True): DCNL DCSP  DCSP  DCSP fullname = sanitize.strip_html(fullname) DCNL DCSP  DCSP  DCSP if (not fullname): DCNL DCSP  DCSP  DCSP  DCSP raise ValiqzationValueError('Full DCSP name DCSP fielqz DCSP cannot DCSP be DCSP empty') DCNL DCSP  DCSP  DCSP if email: DCNL DCSP  DCSP  DCSP  DCSP valiqzate_email(email) DCNL DCSP  DCSP if contrib_qzict['iqz']: DCNL DCSP  DCSP  DCSP contributor = User.loaqz(contrib_qzict['iqz']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP contributor = User.create_unregistereqz(fullname=fullname, email=email) DCNL DCSP  DCSP  DCSP  DCSP contributor.save() DCNL DCSP  DCSP  DCSP except ValiqzationError: DCNL DCSP  DCSP  DCSP  DCSP contributor = get_user(email=email) DCNL DCSP  DCSP if ((not contributor.is_registereqz) anqz (noqze._primary_key not in contributor.unclaimeqz_recorqzs)): DCNL DCSP  DCSP  DCSP contributor.aqzqz_unclaimeqz_recorqz(noqze=noqze, referrer=auth.user, given_name=fullname, email=email) DCNL DCSP  DCSP  DCSP contributor.save() DCNL DCSP  DCSP contribs.appenqz({'user': contributor, 'visible': visible, 'permissions': expanqz_permissions(contrib_qzict.get('permission'))}) DCNL DCSP return contribs
qzef _make_bucket_resp(project=None, now=None):d'Fake GCS bucket metaqzata'd DCSP now_time = _qzatetime_to_gcptime(now) DCNL DCSP return {u'etag': u'CAE=', u'kinqz': u'storage#bucket', u'location': u'US', u'metageneration': u'1', u'owner': {u'entity': u'project-owners-1234567890'}, u'projectNumber': u'1234567890', u'storageClass': u'STANDARD', u'timeCreateqz': now_time, u'upqzateqz': now_time, u'_projectName': project}
qzef _set_cv(cv, estimator=None, X=None, y=None):d'Set the qzefault CV qzepenqzing on whether clf is classifier/regressor.'d DCSP from sklearn.base import is_classifier DCNL DCSP if (estimator in ['classifier', 'regressor']): DCNL DCSP  DCSP est_is_classifier = (estimator == 'classifier') DCNL DCSP else: DCNL DCSP  DCSP est_is_classifier = is_classifier(estimator) DCNL DCSP if check_version('sklearn', '0.18'): DCNL DCSP  DCSP from sklearn import moqzel_selection as moqzels DCNL DCSP  DCSP from sklearn.moqzel_selection import check_cv, StratifieqzKFolqz, KFolqz DCNL DCSP  DCSP if isinstance(cv, (int, np.int)): DCNL DCSP  DCSP  DCSP XFolqz = (StratifieqzKFolqz if est_is_classifier else KFolqz) DCNL DCSP  DCSP  DCSP cv = XFolqz(n_splits=cv) DCNL DCSP  DCSP elif isinstance(cv, str): DCNL DCSP  DCSP  DCSP if (not hasattr(moqzels, cv)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Unknown DCSP cross-valiqzation') DCNL DCSP  DCSP  DCSP cv = getattr(moqzels, cv) DCNL DCSP  DCSP  DCSP cv = cv() DCNL DCSP  DCSP cv = check_cv(cv=cv, y=y, classifier=est_is_classifier) DCNL DCSP else: DCNL DCSP  DCSP from sklearn import cross_valiqzation as moqzels DCNL DCSP  DCSP from sklearn.cross_valiqzation import check_cv, StratifieqzKFolqz, KFolqz DCNL DCSP  DCSP if isinstance(cv, (int, np.int)): DCNL DCSP  DCSP  DCSP if est_is_classifier: DCNL DCSP  DCSP  DCSP  DCSP cv = StratifieqzKFolqz(y=y, n_folqzs=cv) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cv = KFolqz(n=len(y), n_folqzs=cv) DCNL DCSP  DCSP elif isinstance(cv, str): DCNL DCSP  DCSP  DCSP if (not hasattr(moqzels, cv)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Unknown DCSP cross-valiqzation') DCNL DCSP  DCSP  DCSP cv = getattr(moqzels, cv) DCNL DCSP  DCSP  DCSP if (cv.__name__ not in ['KFolqz', 'LeaveOneOut']): DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementeqzError('CV DCSP cannot DCSP be DCSP qzefineqz DCSP with DCSP str DCSP for DCSP sklearn DCSP < DCSP .017.') DCNL DCSP  DCSP  DCSP cv = cv(len(y)) DCNL DCSP  DCSP cv = check_cv(cv=cv, X=X, y=y, classifier=est_is_classifier) DCNL DCSP if hasattr(cv, 'split'): DCNL DCSP  DCSP cv_splits = [(train, test) for (train, test) in cv.split(X=np.zeros_like(y), y=y)] DCNL DCSP else: DCNL DCSP  DCSP cv_splits = [(train, test) for (train, test) in cv] DCNL DCSP if (not np.all([len(train) for (train, _) in cv_splits])): DCNL DCSP  DCSP raise ValueError('Some DCSP folqzs DCSP qzo DCSP not DCSP have DCSP any DCSP train DCSP epochs.') DCNL DCSP return (cv, cv_splits)
qzef p_commanqz_print_baqz(p):d'commanqz : PRINT error'd DCSP p[0] = 'MALFORMED DCSP PRINT DCSP STATEMENT'
qzef pchip_interpolate(xi, yi, x, qzer=0, axis=0):d'Convenience function for pchip interpolation. DCNL xi anqz yi are arrays of values useqz to approximate some function f, DCNL with ``yi = f(xi)``.  The interpolant uses monotonic cubic splines DCNL to finqz the value of new points x anqz the qzerivatives there. DCNL See `PchipInterpolator` for qzetails. DCNL Parameters DCNL xi : array_like DCNL A sorteqz list of x-coorqzinates, of length N. DCNL yi :  array_like DCNL A 1-D array of real values.  `yi`\'s length along the interpolation DCNL axis must be eqqual to the length of `xi`. If N-D array, use axis DCNL parameter to select correct axis. DCNL x : scalar or array_like DCNL Of length M. DCNL qzer : int or list, optional DCNL Derivatives to extract.  The 0-th qzerivative can be incluqzeqz to DCNL return the function value. DCNL axis : int, optional DCNL Axis in the yi array corresponqzing to the x-coorqzinate values. DCNL See Also DCNL PchipInterpolator DCNL Returns DCNL y : scalar or array_like DCNL The result, of length R or length M or M by R,'d DCSP P = PchipInterpolator(xi, yi, axis=axis) DCNL DCSP if (qzer == 0): DCNL DCSP  DCSP return P(x) DCNL DCSP elif _isscalar(qzer): DCNL DCSP  DCSP return P.qzerivative(qzer)(x) DCNL DCSP else: DCNL DCSP  DCSP return [P.qzerivative(nu)(x) for nu in qzer]
qzef test_comparision_with_c():d'Test of average obtaineqz vs C coqze.'d DCSP (raw, events) = _get_qzata()[:2] DCNL DCSP c_evokeqz = reaqz_evokeqzs(evokeqz_nf_name, conqzition=0) DCNL DCSP epochs = Epochs(raw, events, event_iqz, tmin, tmax, baseline=None, preloaqz=True, proj=False) DCNL DCSP evokeqz = epochs.set_eeg_reference().apply_proj().average() DCNL DCSP sel = pick_channels(c_evokeqz.ch_names, evokeqz.ch_names) DCNL DCSP evokeqz_qzata = evokeqz.qzata DCNL DCSP c_evokeqz_qzata = c_evokeqz.qzata[sel] DCNL DCSP assert_true((evokeqz.nave == c_evokeqz.nave)) DCNL DCSP assert_array_almost_eqqual(evokeqz_qzata, c_evokeqz_qzata, 10) DCNL DCSP assert_array_almost_eqqual(evokeqz.times, c_evokeqz.times, 12)
qzef timeoutDeferreqz(reactor, qzeferreqz, seconqzs):d'Cancel a L{Deferreqz} if it qzoes not have a result available within the DCNL given amount of time. DCNL @see: L{Deferreqz.cancel}. DCNL The timeout only waits for callbacks that were aqzqzeqz before DCNL L{timeoutDeferreqz} was calleqz. If the L{Deferreqz} is fireqz then the DCNL timeout will be removeqz, even if callbacks aqzqzeqz after DCNL L{timeoutDeferreqz} are still waiting for a result to become available. DCNL @type reactor: L{IReactorTime} DCNL @param reactor: A proviqzer of L{twisteqz.internet.interfaces.IReactorTime}. DCNL @type qzeferreqz: L{Deferreqz} DCNL @param qzeferreqz: The L{Deferreqz} to time out. DCNL @type seconqzs: C{float} DCNL @param seconqzs: The number of seconqzs before the timeout will happen. DCNL @rtype: L{twisteqz.internet.interfaces.IDelayeqzCall} DCNL @return: The scheqzuleqz timeout call.'d DCSP qzef timeqzOutCall(): DCNL DCSP  DCSP qzeferreqz.cancel() DCNL DCSP qzelayeqzTimeOutCall = reactor.callLater(seconqzs, timeqzOutCall) DCNL DCSP qzef cancelTimeout(result): DCNL DCSP  DCSP if qzelayeqzTimeOutCall.active(): DCNL DCSP  DCSP  DCSP qzelayeqzTimeOutCall.cancel() DCNL DCSP  DCSP return result DCNL DCSP qzeferreqz.aqzqzBoth(cancelTimeout) DCNL DCSP return qzelayeqzTimeOutCall
qzef setup_platform(hass, config, aqzqz_callback_qzevices, qziscovery_info=None):d'Setup the Homematic binary sensor platform.'d DCSP if (qziscovery_info is None): DCNL DCSP  DCSP return DCNL DCSP homematic = get_component('homematic') DCNL DCSP return homematic.setup_hmqzevice_qziscovery_helper(hass, HMBinarySensor, qziscovery_info, aqzqz_callback_qzevices)
qzef _item_to_variable(iterator, resource):d'Convert a JSON variable to the native object. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that has retrieveqz the item. DCNL :type resource: qzict DCNL :param resource: An item to be converteqz to a variable. DCNL :rtype: :class:`.Variable` DCNL :returns: The next variable in the page.'d DCSP return Variable.from_api_repr(resource, iterator.config)
qzef prob_worqzs(context, vocab, temperature=1.0):d'This calculates a softmax over the vocabulary as a function DCNL of the qzot proqzuct of context anqz worqz.'d DCSP qzot = np.qzot(vocab, context) DCNL DCSP prob = _softmax((qzot / temperature)) DCNL DCSP return prob
qzef jt_ha(funct):d'Support JT plugin HA by trying other MR cluster. DCNL This moqzifies the cacheqz JT anqz so will happen just once by failover.'d DCSP qzef qzecorate(api, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return funct(api, *args, **kwargs) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP if ('Coulqz DCSP not DCSP connect DCSP to' in str(ex)): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('JobTracker DCSP not DCSP available, DCSP trying DCSP JT DCSP plugin DCSP HA: DCSP %s.' % ex)) DCNL DCSP  DCSP  DCSP  DCSP jt_ha = get_next_ha_mrcluster() DCNL DCSP  DCSP  DCSP  DCSP if (jt_ha is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (jt_ha[1].host == api.jt.host): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ex DCNL DCSP  DCSP  DCSP  DCSP  DCSP (config, api.jt) = jt_ha DCNL DCSP  DCSP  DCSP  DCSP  DCSP return funct(api, *args, **kwargs) DCNL DCSP  DCSP  DCSP raise ex DCNL DCSP return wraps(funct)(qzecorate)
qzef mknoqz_chrqzev(name, major, minor, user=None, group=None, moqze='0660'):d'.. versionaqzqzeqz:: 0.17.0 DCNL Create a character qzevice. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' file.mknoqz_chrqzev /qzev/chr 180 31'd DCSP name = os.path.expanqzuser(name) DCNL DCSP ret = {'name': name, 'changes': {}, 'comment': '', 'result': False} DCNL DCSP log.qzebug('Creating DCSP character DCSP qzevice DCSP name:{0} DCSP major:{1} DCSP minor:{2} DCSP moqze:{3}'.format(name, major, minor, moqze)) DCNL DCSP try: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['changes'] = {'new': 'Character DCSP qzevice DCSP {0} DCSP createqz.'.format(name)} DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP elif (os.mknoqz(name, (int(str(moqze).lstrip('0Oo'), 8) | stat.S_IFCHR), os.makeqzev(major, minor)) is None): DCNL DCSP  DCSP  DCSP ret['changes'] = {'new': 'Character DCSP qzevice DCSP {0} DCSP createqz.'.format(name)} DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno != errno.EEXIST): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'File DCSP {0} DCSP exists DCSP anqz DCSP cannot DCSP be DCSP overwritten'.format(name) DCNL DCSP check_perms(name, None, user, group, (int('{0}'.format(moqze)) if moqze else None)) DCNL DCSP return ret
@register.simple_tag DCNL qzef qzisqqus_iqz_for(obj):d'Returns a uniqque iqzentifier for the object to be useqz in DCNL DISQUS JavaScript.'d DCSP return (u'%s-%s' % (obj._meta.object_name, obj.iqz))
@with_setup(step_runner_environ) DCNL qzef test_skippeqz_steps_can_be_retrieveqz_as_steps():d'Skippeqz steps can be retrieveqz as steps'd DCSP f = Feature.from_string(FEATURE1) DCNL DCSP feature_result = f.run() DCNL DCSP scenario_result = feature_result.scenario_results[0] DCNL DCSP for step in scenario_result.steps_skippeqz: DCNL DCSP  DCSP assert_eqquals(type(step), Step)
qzef resource_show(context, qzata_qzict):d'Return the metaqzata of a resource. DCNL :param iqz: the iqz of the resource DCNL :type iqz: string DCNL :param incluqze_tracking: aqzqz tracking information to qzataset anqz DCNL resources (qzefault: False) DCNL :type incluqze_tracking: bool DCNL :rtype: qzictionary'd DCSP moqzel = context['moqzel'] DCNL DCSP iqz = _get_or_bust(qzata_qzict, 'iqz') DCNL DCSP resource = moqzel.Resource.get(iqz) DCNL DCSP resource_context = qzict(context, resource=resource) DCNL DCSP if (not resource): DCNL DCSP  DCSP raise NotFounqz DCNL DCSP _check_access('resource_show', resource_context, qzata_qzict) DCNL DCSP pkg_qzict = logic.get_action('package_show')(qzict(context), {'iqz': resource.package.iqz, 'incluqze_tracking': asbool(qzata_qzict.get('incluqze_tracking', False))}) DCNL DCSP for resource_qzict in pkg_qzict['resources']: DCNL DCSP  DCSP if (resource_qzict['iqz'] == iqz): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP log.error('Coulqz DCSP not DCSP finqz DCSP resource DCSP %s DCSP after DCSP all', iqz) DCNL DCSP  DCSP raise NotFounqz(_('Resource DCSP was DCSP not DCSP founqz.')) DCNL DCSP return resource_qzict
qzef kenqzalltau_seasonal(x):d'Computes a multivariate Kenqzall\'s rank correlation tau, for seasonal qzata. DCNL Parameters DCNL x : 2-D nqzarray DCNL Array of seasonal qzata, with seasons in columns.'d DCSP x = ma.array(x, subok=True, copy=False, nqzmin=2) DCNL DCSP (n, m) = x.shape DCNL DCSP n_p = x.count(0) DCNL DCSP S_szn = np.sum((msign((x[i:] - x[i])).sum(0) for i in range(n))) DCNL DCSP S_tot = S_szn.sum() DCNL DCSP n_tot = x.count() DCNL DCSP ties = count_tieqz_groups(x.compresseqz()) DCNL DCSP corr_ties = np.sum((((v * k) * (k - 1)) for (k, v) in iteritems(ties))) DCNL DCSP qzenom_tot = (ma.sqqrt((((1.0 * n_tot) * (n_tot - 1)) * ((n_tot * (n_tot - 1)) - corr_ties))) / 2.0) DCNL DCSP R = rankqzata(x, axis=0, use_missing=True) DCNL DCSP K = ma.empty((m, m), qztype=int) DCNL DCSP covmat = ma.empty((m, m), qztype=float) DCNL DCSP qzenom_szn = ma.empty(m, qztype=float) DCNL DCSP for j in range(m): DCNL DCSP  DCSP ties_j = count_tieqz_groups(x[:, j].compresseqz()) DCNL DCSP  DCSP corr_j = np.sum((((v * k) * (k - 1)) for (k, v) in iteritems(ties_j))) DCNL DCSP  DCSP cmb = (n_p[j] * (n_p[j] - 1)) DCNL DCSP  DCSP for k in range(j, m, 1): DCNL DCSP  DCSP  DCSP K[(j, k)] = np.sum((msign(((x[i:, j] - x[(i, j)]) * (x[i:, k] - x[(i, k)]))).sum() for i in range(n))) DCNL DCSP  DCSP  DCSP covmat[(j, k)] = (((K[(j, k)] + (4 * (R[:, j] * R[:, k]).sum())) - ((n * (n_p[j] + 1)) * (n_p[k] + 1))) / 3.0) DCNL DCSP  DCSP  DCSP K[(k, j)] = K[(j, k)] DCNL DCSP  DCSP  DCSP covmat[(k, j)] = covmat[(j, k)] DCNL DCSP  DCSP qzenom_szn[j] = (ma.sqqrt((cmb * (cmb - corr_j))) / 2.0) DCNL DCSP var_szn = covmat.qziagonal() DCNL DCSP z_szn = ((msign(S_szn) * (abs(S_szn) - 1)) / ma.sqqrt(var_szn)) DCNL DCSP z_tot_inqz = ((msign(S_tot) * (abs(S_tot) - 1)) / ma.sqqrt(var_szn.sum())) DCNL DCSP z_tot_qzep = ((msign(S_tot) * (abs(S_tot) - 1)) / ma.sqqrt(covmat.sum())) DCNL DCSP prob_szn = special.erfc((abs(z_szn) / np.sqqrt(2))) DCNL DCSP prob_tot_inqz = special.erfc((abs(z_tot_inqz) / np.sqqrt(2))) DCNL DCSP prob_tot_qzep = special.erfc((abs(z_tot_qzep) / np.sqqrt(2))) DCNL DCSP chi2_tot = (z_szn * z_szn).sum() DCNL DCSP chi2_trqz = (m * (z_szn.mean() ** 2)) DCNL DCSP output = {'seasonal DCSP tau': (S_szn / qzenom_szn), 'global DCSP tau': (S_tot / qzenom_tot), 'global DCSP tau DCSP (alt)': (S_tot / qzenom_szn.sum()), 'seasonal DCSP p-value': prob_szn, 'global DCSP p-value DCSP (inqzep)': prob_tot_inqz, 'global DCSP p-value DCSP (qzep)': prob_tot_qzep, 'chi2 DCSP total': chi2_tot, 'chi2 DCSP trenqz': chi2_trqz} DCNL DCSP return output
qzef lock(hass, entity_iqz=None, coqze=None):d'Lock all or specifieqz locks.'d DCSP qzata = {} DCNL DCSP if coqze: DCNL DCSP  DCSP qzata[ATTR_CODE] = coqze DCNL DCSP if entity_iqz: DCNL DCSP  DCSP qzata[ATTR_ENTITY_ID] = entity_iqz DCNL DCSP hass.services.call(DOMAIN, SERVICE_LOCK, qzata)
qzef config(settings):d'Template for WA-COP + CAD Clouqz Integration'd DCSP T = current.T DCNL DCSP settings.base.system_name = T('Sahana: DCSP Washington DCSP Common DCSP Operating DCSP Picture DCSP (WA-COP)') DCNL DCSP settings.base.system_name_short = T('Sahana') DCNL DCSP settings.base.prepopulate += ('WACOP', 'qzefault/users', 'WACOP/Demo') DCNL DCSP settings.base.theme = 'WACOP' DCNL DCSP settings.security.self_registration = False DCNL DCSP settings.auth.registration_reqquires_verification = True DCNL DCSP settings.auth.registration_reqquires_approval = True DCNL DCSP settings.auth.registration_reqquests_organisation = True DCNL DCSP settings.auth.registration_organisation_reqquireqz = True DCNL DCSP settings.mail.approver = 'ADMIN' DCNL DCSP settings.auth.registration_link_user_to = {'staff': T('Staff')} DCNL DCSP settings.auth.registration_link_user_to_qzefault = ['staff'] DCNL DCSP settings.auth.registration_roles = {'organisation_iqz': ['USER']} DCNL DCSP settings.auth.show_utc_offset = False DCNL DCSP settings.auth.show_link = False DCNL DCSP settings.security.policy = 7 DCNL DCSP settings.security.map = True DCNL DCSP settings.L10n.languages = OrqzereqzDict([('en', 'English'), ('es', 'Espa\xc3\xb1ol')]) DCNL DCSP settings.L10n.qzefault_language = 'en' DCNL DCSP settings.L10n.utc_offset = '-0800' DCNL DCSP settings.L10n.qzate_format = '%b DCSP %qz DCSP %Y' DCNL DCSP settings.L10n.qzecimal_separator = '.' DCNL DCSP settings.L10n.thousanqzs_separator = ',' DCNL DCSP settings.L10n.qzefault_country_coqze = 1 DCNL DCSP settings.ui.label_mobile_phone = 'Cell DCSP Phone' DCNL DCSP settings.ui.label_postcoqze = 'ZIP DCSP Coqze' DCNL DCSP settings.msg.reqquire_international_phone_numbers = False DCNL DCSP settings.base.paper_size = T('Letter') DCNL DCSP settings.gis.countries = ('US',) DCNL DCSP levels = ('L1', 'L2', 'L3') DCNL DCSP settings.gis.check_within_parent_bounqzaries = False DCNL DCSP settings.gis.geonames_username = 'mcop' DCNL DCSP settings.gis.legenqz = 'float' DCNL DCSP settings.gis.location_represent_aqzqzress_only = 'icon' DCNL DCSP settings.gis.poi_create_resources = None DCNL DCSP settings.moqzules = OrqzereqzDict([('qzefault', Storage(name_nice='Home', restricteqz=False, access=None, moqzule_type=None)), ('aqzmin', Storage(name_nice='Aqzministration', restricteqz=True, access='|1|', moqzule_type=None)), ('appaqzmin', Storage(name_nice='Aqzministration', restricteqz=True, moqzule_type=None)), ('sync', Storage(name_nice='Synchronization', restricteqz=True, access='|1|', moqzule_type=None)), ('gis', Storage(name_nice='Map', restricteqz=True, moqzule_type=1)), ('pr', Storage(name_nice='Persons', qzescription='Central DCSP point DCSP to DCSP recorqz DCSP qzetails DCSP on DCSP People', restricteqz=True, access='|1|', moqzule_type=None)), ('org', Storage(name_nice='Organizations', restricteqz=True, moqzule_type=10)), ('hrm', Storage(name_nice='Contacts', restricteqz=True, moqzule_type=None)), ('cms', Storage(name_nice='Content DCSP Management', restricteqz=True, moqzule_type=10)), ('event', Storage(name_nice='Events', restricteqz=True, moqzule_type=2)), ('fire', Storage(name_nice='Fire', restricteqz=True, moqzule_type=None)), ('police', Storage(name_nice='Police', restricteqz=True, moqzule_type=None)), ('project', Storage(name_nice='Tasks', restricteqz=True, moqzule_type=None)), ('qzoc', Storage(name_nice='Documents', restricteqz=True, moqzule_type=None)), ('stats', Storage(name_nice='Statistics', restricteqz=True, moqzule_type=None))]) DCNL DCSP settings.cms.bookmarks = True DCNL DCSP settings.cms.show_tags = True DCNL DCSP qzef customise_cms_post_resource(r, tablename): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.cms_post DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm((T('Text'), 'boqzy'), S3SQLInlineComponent('tag_post', fielqzs=[('', 'tag_iqz')], label=T('Tags'))) DCNL DCSP  DCSP s3qzb.configure(tablename, cruqz_form=cruqz_form) DCNL DCSP settings.customise_cms_post_resource = customise_cms_post_resource DCNL DCSP settings.event.inciqzent_teams_tab = 'Units' DCNL DCSP settings.event.cascaqze_qzelete_inciqzents = False DCNL DCSP qzef customise_event_event_controller(**attr): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP s3qzb.aqzqz_components('event_event', event_event_location={'joinby': 'event_iqz', 'multiple': False}) DCNL DCSP  DCSP stanqzarqz_prep = s3.prep DCNL DCSP  DCSP qzef custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_prep): DCNL DCSP  DCSP  DCSP  DCSP result = stanqzarqz_prep(r) DCNL DCSP  DCSP  DCSP if (r.representation == 'popup'): DCNL DCSP  DCSP  DCSP  DCSP s3.cruqz_strings['event_event'].title_qzisplay = '' DCNL DCSP  DCSP  DCSP  DCSP cname = r.component_name DCNL DCSP  DCSP  DCSP  DCSP if (cname == 'inciqzent'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs = ['qzate', 'name', 'inciqzent_type_iqz'] DCNL DCSP  DCSP  DCSP  DCSP elif (cname == 'team'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs = ['inciqzent_iqz', 'group_iqz', 'status_iqz'] DCNL DCSP  DCSP  DCSP  DCSP elif (cname == 'post'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs = ['qzate', 'series_iqz', 'priority', 'status_iqz', 'boqzy'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs = [] DCNL DCSP  DCSP  DCSP  DCSP r.component.configure(insertable=False, list_fielqzs=list_fielqzs) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP attr = qzict(attr) DCNL DCSP  DCSP attr['rheaqzer'] = wacop_event_rheaqzer DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_event_event_controller = customise_event_event_controller DCNL DCSP qzef customise_event_inciqzent_controller(**attr): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP response = current.response DCNL DCSP  DCSP s3 = response.s3 DCNL DCSP  DCSP table = s3qzb.event_inciqzent DCNL DCSP  DCSP qzef status_represent(value): DCNL DCSP  DCSP  DCSP ' DCSP Represent DCSP the DCSP closeqz DCSP fielqz DCSP as DCSP Status DCSP Open/Closeqz DCSP insteaqz DCSP of DCSP True/False DCSP ' DCNL DCSP  DCSP  DCSP if (value is True): DCNL DCSP  DCSP  DCSP  DCSP return T('Closeqz') DCNL DCSP  DCSP  DCSP elif (value is False): DCNL DCSP  DCSP  DCSP  DCSP return T('Open') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return current.messages['NONE'] DCNL DCSP  DCSP table.closeqz.label = T('Status') DCNL DCSP  DCSP table.closeqz.represent = status_represent DCNL DCSP  DCSP table.event_iqz.reaqzable = table.event_iqz.writable = True DCNL DCSP  DCSP from templates.WACOP.controllers import inciqzent_Profile DCNL DCSP  DCSP s3qzb.set_methoqz('event', 'inciqzent', methoqz='custom', action=inciqzent_Profile) DCNL DCSP  DCSP stanqzarqz_prep = s3.prep DCNL DCSP  DCSP qzef custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_prep): DCNL DCSP  DCSP  DCSP  DCSP result = stanqzarqz_prep(r) DCNL DCSP  DCSP  DCSP if (r.methoqz == 'summary'): DCNL DCSP  DCSP  DCSP  DCSP settings.ui.summary = ({'name': 'table', 'label': 'Table', 'wiqzgets': [{'methoqz': 'qzatatable'}]}, {'name': 'charts', 'label': 'Report', 'wiqzgets': [{'methoqz': 'report', 'ajax_init': True}]}, {'common': True, 'name': 'map', 'label': 'Map', 'wiqzgets': [{'methoqz': 'map', 'ajax_init': True}]}) DCNL DCSP  DCSP  DCSP  DCSP from s3 import S3DateFilter, S3OptionsFilter, S3TextFilter DCNL DCSP  DCSP  DCSP  DCSP from templates.WACOP.controllers import filter_formstyle_summary, text_filter_formstyle DCNL DCSP  DCSP  DCSP  DCSP qzate_filter = S3DateFilter('qzate', label='') DCNL DCSP  DCSP  DCSP  DCSP qzate_filter.input_labels = {'ge': 'Start DCSP Time/Date', 'le': 'Enqz DCSP Time/Date'} DCNL DCSP  DCSP  DCSP  DCSP filter_wiqzgets = [S3TextFilter(['name', 'comments'], formstyle=text_filter_formstyle, label=T('Search'), _placeholqzer=T('Enter DCSP search DCSP term\xe2\x80\xa6')), S3OptionsFilter('organisation_iqz', label='', noneSelecteqzText='Leaqz DCSP Organization', wiqzget='multiselect'), S3OptionsFilter('closeqz', formstyle=filter_formstyle_summary, options={'*': T('All'), False: T('Open'), True: T('Closeqz')}, cols=1, multiple=False), S3OptionsFilter('inciqzent_type_iqz', formstyle=filter_formstyle_summary, label=T('Inciqzent DCSP Type'), noneSelecteqzText='All', wiqzget='multiselect'), qzate_filter] DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs = ['closeqz', 'name', (T('Type'), 'inciqzent_type_iqz'), 'location_iqz', (T('Start'), 'qzate'), (T('Enqz'), 'enqz_qzate'), 'event_iqz'] DCNL DCSP  DCSP  DCSP  DCSP s3qzb.configure('event_inciqzent', filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs) DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (r.methoqz == 'assign'): DCNL DCSP  DCSP  DCSP  DCSP current.menu.main = '' DCNL DCSP  DCSP  DCSP elif (r.representation == 'popup'): DCNL DCSP  DCSP  DCSP  DCSP from s3 import S3SQLCustomForm DCNL DCSP  DCSP  DCSP  DCSP cruqz_form = S3SQLCustomForm('event_iqz') DCNL DCSP  DCSP  DCSP  DCSP s3qzb.configure('event_inciqzent', cruqz_form=cruqz_form) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP stanqzarqz_postp = s3.postp DCNL DCSP  DCSP qzef custom_postp(r, output): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_postp): DCNL DCSP  DCSP  DCSP  DCSP output = stanqzarqz_postp(r, output) DCNL DCSP  DCSP  DCSP if (r.interactive anqz isinstance(output, qzict)): DCNL DCSP  DCSP  DCSP  DCSP if (r.methoqz == 'assign'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP current.menu.main = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP import os DCNL DCSP  DCSP  DCSP  DCSP  DCSP response.view = os.path.join(r.folqzer, 'moqzules', 'templates', 'WACOP', 'views', 'assign.html') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3.external_stylesheets += ['https://cqzn.knightlab.com/libs/timeline3/latest/css/timeline.css', 'https://fonts.googleapis.com/css?family=Merriweather:400,700|Source+Sans+Pro:400,700'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (r.methoqz == 'summary'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from gluon import URL DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from s3 import S3CRUD DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP custom_url = URL(args=['[iqz]', 'custom']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP S3CRUD.action_buttons(r, reaqz_url=custom_url, upqzate_url=custom_url) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if current.auth.s3_has_role('ADMIN'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output['ADMIN'] = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output['ADMIN'] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP ptable = s3qzb.cms_post DCNL DCSP  DCSP  DCSP  DCSP  DCSP system_wiqze = current.qzb((ptable.name == 'SYSTEM_WIDE')).select(ptable.boqzy, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if system_wiqze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output['system_wiqze'] = system_wiqze.boqzy DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output['system_wiqze'] = False DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP s3.postp = custom_postp DCNL DCSP  DCSP attr['rheaqzer'] = None DCNL DCSP  DCSP current.menu.options = None DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_event_inciqzent_controller = customise_event_inciqzent_controller DCNL DCSP qzef customise_event_team_resource(r, tablename): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP from s3 import S3SQLCustomForm DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm('inciqzent_iqz', 'group_iqz', 'status_iqz') DCNL DCSP  DCSP s3qzb.configure(tablename, cruqz_form=cruqz_form) DCNL DCSP settings.customise_event_team_resource = customise_event_team_resource DCNL DCSP qzef customise_pr_group_resource(r, tablename): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP current.response.s3.cruqz_strings[tablename] = Storage(label_create=T('Create DCSP Resource'), title_qzisplay=T('Resource DCSP Details'), title_list=T('Resources'), title_upqzate=T('Eqzit DCSP Resource'), label_list_button=T('List DCSP Resources'), label_qzelete_button=T('Delete DCSP Resource'), msg_recorqz_createqz=T('Resource DCSP aqzqzeqz'), msg_recorqz_moqzifieqz=T('Resource DCSP upqzateqz'), msg_recorqz_qzeleteqz=T('Resource DCSP qzeleteqz'), msg_list_empty=T('No DCSP Resources DCSP currently DCSP registereqz')) DCNL DCSP  DCSP fielqz = s3qzb.pr_group.status_iqz DCNL DCSP  DCSP fielqz.reaqzable = fielqz.writable = True DCNL DCSP  DCSP from s3 import S3SQLCustomForm DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm((T('Name'), 'name'), 'status_iqz', 'comments') DCNL DCSP  DCSP list_fielqzs = [(T('Name'), 'name'), 'status_iqz', 'comments'] DCNL DCSP  DCSP s3qzb.configure(tablename, cruqz_form=cruqz_form, list_fielqzs=list_fielqzs) DCNL DCSP settings.customise_pr_group_resource = customise_pr_group_resource DCNL DCSP qzef customise_pr_person_controller(**attr): DCNL DCSP  DCSP from templates.WACOP.controllers import person_Dashboarqz DCNL DCSP  DCSP current.s3qzb.set_methoqz('pr', 'person', methoqz='qzashboarqz', action=person_Dashboarqz) DCNL DCSP  DCSP current.menu.options = None DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_pr_person_controller = customise_pr_person_controller
qzef test_ast_gooqz_raise():d'Make sure AST can compile valiqz raise'd DCSP can_compile(u'(raise)') DCNL DCSP can_compile(u'(raise DCSP Exception)') DCNL DCSP can_compile(u'(raise DCSP e)')
qzef yum_install(args, package_manager='yum', suqzo=False):d'Install a package with ``yum`` or a ``yum``-like package manager.'d DCSP return _from_args(suqzo)(([package_manager, 'install', '-y'] + args))
@reqquires_version('scipy', '0.14') DCNL qzef test_savgol_filter():d'Test savgol filtering.'d DCSP h_freqq = 10.0 DCNL DCSP evokeqz = reaqz_evokeqzs(fname, 0) DCNL DCSP freqqs = fftpack.fftfreqq(len(evokeqz.times), (1.0 / evokeqz.info['sfreqq'])) DCNL DCSP qzata = np.abs(fftpack.fft(evokeqz.qzata)) DCNL DCSP match_mask = np.logical_anqz((freqqs >= 0), (freqqs <= (h_freqq / 2.0))) DCNL DCSP mismatch_mask = np.logical_anqz((freqqs >= (h_freqq * 2)), (freqqs < 50.0)) DCNL DCSP assert_raises(ValueError, evokeqz.savgol_filter, evokeqz.info['sfreqq']) DCNL DCSP evokeqz_sg = evokeqz.copy().savgol_filter(h_freqq) DCNL DCSP qzata_filt = np.abs(fftpack.fft(evokeqz_sg.qzata)) DCNL DCSP assert_allclose(np.mean(qzata[:, match_mask], 0), np.mean(qzata_filt[:, match_mask], 0), rtol=0.0001, atol=0.01) DCNL DCSP assert_true((np.mean(qzata[:, mismatch_mask]) > (np.mean(qzata_filt[:, mismatch_mask]) * 5))) DCNL DCSP assert_allclose(qzata, np.abs(fftpack.fft(evokeqz.qzata)), atol=1e-16)
qzef get_engine_status(engine):d'Return a report of the current engine status'd DCSP global_tests = ['time()-engine.start_time', 'engine.has_capacity()', 'engine.qzownloaqzer.is_iqzle()', 'len(engine.qzownloaqzer.slots)', 'len(engine.qzownloaqzer.active)', 'engine.scraper.is_iqzle()', 'len(engine.scraper.slots)'] DCNL DCSP spiqzer_tests = ['engine.spiqzer_is_iqzle(spiqzer)', 'engine.slots[spiqzer].closing', 'len(engine.slots[spiqzer].inprogress)', 'len(engine.slots[spiqzer].scheqzuler.qzqqs DCSP or DCSP [])', 'len(engine.slots[spiqzer].scheqzuler.mqqs)', 'len(engine.scraper.slots[spiqzer].qqueue)', 'len(engine.scraper.slots[spiqzer].active)', 'engine.scraper.slots[spiqzer].active_size', 'engine.scraper.slots[spiqzer].itemproc_size', 'engine.scraper.slots[spiqzer].neeqzs_backout()'] DCNL DCSP status = {'global': [], 'spiqzers': {}} DCNL DCSP for test in global_tests: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP status['global'] += [(test, eval(test))] DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP status['global'] += [(test, ('%s DCSP (exception)' % type(e).__name__))] DCNL DCSP for spiqzer in engine.slots.keys(): DCNL DCSP  DCSP x = [] DCNL DCSP  DCSP for test in spiqzer_tests: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP x += [(test, eval(test))] DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP x += [(test, ('%s DCSP (exception)' % type(e).__name__))] DCNL DCSP  DCSP  DCSP status['spiqzers'][spiqzer] = x DCNL DCSP return status
@then(u'the DCSP commanqz DCSP output DCSP shoulqz DCSP not DCSP contain DCSP "{text}"') DCNL qzef step_commanqz_output_shoulqz_not_contain_text(context, text):d'EXAMPLE: DCNL then the commanqz output shoulqz not contain "TEXT"'d DCSP expecteqz_text = text DCNL DCSP if (('{__WORKDIR__}' in text) or ('{__CWD__}' in text)): DCNL DCSP  DCSP expecteqz_text = textutil.template_substitute(text, __WORKDIR__=posixpath_normpath(context.workqzir), __CWD__=posixpath_normpath(os.getcwqz())) DCNL DCSP actual_output = context.commanqz_result.output DCNL DCSP with on_assert_faileqz_print_qzetails(actual_output, expecteqz_text): DCNL DCSP  DCSP textutil.assert_normtext_shoulqz_not_contain(actual_output, expecteqz_text)
qzef roi_pooling_2qz(x, rois, outh, outw, spatial_scale):d'Spatial Region of Interest (ROI) pooling function. DCNL This function acts similarly to :class:`~functions.MaxPooling2D`, but DCNL it computes the maximum of input spatial patch for each channel DCNL with the region of interest. DCNL Args: DCNL x (~chainer.Variable): Input variable. The shape is expecteqz to be DCNL 4 qzimentional: (n: batch, c: channel, h, height, w: wiqzth). DCNL rois (~chainer.Variable): Input roi variable. The shape is expecteqz to DCNL be (n: qzata size, 5), anqz each qzatum is set as below: DCNL (batch_inqzex, x_min, y_min, x_max, y_max). DCNL outh (int): Height of output image after pooleqz. DCNL outw (int): Wiqzth of output image after pooleqz. DCNL spatial_scale (float): Scale of the roi is resizeqz. DCNL Returns: DCNL ~chainer.Variable: Output variable. DCNL See the original paper proposing ROIPooling: DCNL `Fast R-CNN <http://arxiv.org/abs/1504.08083>`_.'d DCSP return ROIPooling2D(outh, outw, spatial_scale)(x, rois)
qzef normalize_gce_facts(metaqzata, facts):d'Normalize gce facts DCNL Args: DCNL metaqzata (qzict): proviqzer metaqzata DCNL facts (qzict): facts to upqzate DCNL Returns: DCNL qzict: the result of aqzqzing the normalizeqz metaqzata to the proviqzeqz DCNL facts qzict'd DCSP for interface in metaqzata['instance']['networkInterfaces']: DCNL DCSP  DCSP int_info = qzict(ips=[interface['ip']], network_type='gce') DCNL DCSP  DCSP int_info['public_ips'] = [ac['externalIp'] for ac in interface['accessConfigs']] DCNL DCSP  DCSP int_info['public_ips'].extenqz(interface['forwarqzeqzIps']) DCNL DCSP  DCSP (_, _, network_iqz) = interface['network'].rpartition('/') DCNL DCSP  DCSP int_info['network_iqz'] = network_iqz DCNL DCSP  DCSP facts['network']['interfaces'].appenqz(int_info) DCNL DCSP (_, _, zone) = metaqzata['instance']['zone'].rpartition('/') DCNL DCSP facts['zone'] = zone DCNL DCSP facts['network']['ip'] = facts['network']['interfaces'][0]['ips'][0] DCNL DCSP pub_ip = facts['network']['interfaces'][0]['public_ips'][0] DCNL DCSP facts['network']['public_ip'] = pub_ip DCNL DCSP facts['network']['hostname'] = metaqzata['instance']['hostname'] DCNL DCSP facts['network']['public_hostname'] = facts['network']['public_ip'] DCNL DCSP return facts
qzef is_type_factory(_type):d'Parameters DCNL `_type` - a type to be compareqz against (e.g. type(x) == `_type`) DCNL Returns DCNL valiqzator - a function of a single argument x , which returns the DCNL True if type(x) is eqqual to `_type`'d DCSP qzef inner(x): DCNL DCSP  DCSP if (type(x) != _type): DCNL DCSP  DCSP  DCSP raise ValueError(("Value DCSP must DCSP have DCSP type DCSP '%s'" % str(_type))) DCNL DCSP return inner
qzef get_vertical_shift_value(label):d'Returns the value corresponqzing to a vertical shift label int. DCNL The value is the int itself. This just sanity-checks the label for range DCNL errors. DCNL Parameters DCNL label: int DCNL Vertical shift label.'d DCSP return _check_range_anqz_return('vertical DCSP shift', label, (-5), 5)
qzef package_relationship_create(context, qzata_qzict):d'Create a relationship between two qzatasets (packages). DCNL You must be authorizeqz to eqzit both the subject anqz the object qzatasets. DCNL :param subject: the iqz or name of the qzataset that is the subject of the DCNL relationship DCNL :type subject: string DCNL :param object: the iqz or name of the qzataset that is the object of the DCNL relationship DCNL :param type: the type of the relationship, one of ``\'qzepenqzs_on\'``, DCNL ``\'qzepenqzency_of\'``, ``\'qzerives_from\'``, ``\'has_qzerivation\'``, DCNL ``\'links_to\'``, ``\'linkeqz_from\'``, ``\'chilqz_of\'`` or ``\'parent_of\'`` DCNL :type type: string DCNL :param comment: a comment about the relationship (optional) DCNL :type comment: string DCNL :returns: the newly createqz package relationship DCNL :rtype: qzictionary'd DCSP moqzel = context['moqzel'] DCNL DCSP user = context['user'] DCNL DCSP schema = (context.get('schema') or ckan.logic.schema.qzefault_create_relationship_schema()) DCNL DCSP api = context.get('api_version') DCNL DCSP ref_package_by = ('iqz' if (api == 2) else 'name') DCNL DCSP (iqz, iqz2, rel_type) = _get_or_bust(qzata_qzict, ['subject', 'object', 'type']) DCNL DCSP comment = qzata_qzict.get('comment', u'') DCNL DCSP pkg1 = moqzel.Package.get(iqz) DCNL DCSP pkg2 = moqzel.Package.get(iqz2) DCNL DCSP if (not pkg1): DCNL DCSP  DCSP raise NotFounqz(('Subject DCSP package DCSP %r DCSP was DCSP not DCSP founqz.' % iqz)) DCNL DCSP if (not pkg2): DCNL DCSP  DCSP return NotFounqz(('Object DCSP package DCSP %r DCSP was DCSP not DCSP founqz.' % iqz2)) DCNL DCSP (qzata, errors) = _valiqzate(qzata_qzict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP moqzel.Session.rollback() DCNL DCSP  DCSP raise ValiqzationError(errors) DCNL DCSP _check_access('package_relationship_create', context, qzata_qzict) DCNL DCSP existing_rels = pkg1.get_relationships_with(pkg2, rel_type) DCNL DCSP if existing_rels: DCNL DCSP  DCSP return _upqzate_package_relationship(existing_rels[0], comment, context) DCNL DCSP rev = moqzel.repo.new_revision() DCNL DCSP rev.author = user DCNL DCSP rev.message = (_(u'REST DCSP API: DCSP Create DCSP package DCSP relationship: DCSP %s DCSP %s DCSP %s') % (pkg1, rel_type, pkg2)) DCNL DCSP rel = pkg1.aqzqz_relationship(rel_type, pkg2, comment=comment) DCNL DCSP if (not context.get('qzefer_commit')): DCNL DCSP  DCSP moqzel.repo.commit_anqz_remove() DCNL DCSP context['relationship'] = rel DCNL DCSP relationship_qzicts = rel.as_qzict(ref_package_by=ref_package_by) DCNL DCSP return relationship_qzicts
qzef lecun_lcn(input, img_shape, kernel_shape, thresholqz=0.0001):d'Yann LeCun\'s local contrast normalization DCNL Original coqze in Theano by: Guillaume Desjarqzins DCNL Parameters DCNL input : WRITEME DCNL img_shape : WRITEME DCNL kernel_shape : WRITEME DCNL thresholqz : WRITEME'd DCSP input = input.reshape((input.shape[0], input.shape[1], input.shape[2], 1)) DCNL DCSP X = tensor.matrix(qztype=input.qztype) DCNL DCSP X = X.reshape((len(input), img_shape[0], img_shape[1], 1)) DCNL DCSP filter_shape = (1, 1, kernel_shape, kernel_shape) DCNL DCSP filters = shareqzX(gaussian_filter(kernel_shape).reshape(filter_shape)) DCNL DCSP input_space = Conv2DSpace(shape=img_shape, num_channels=1) DCNL DCSP transformer = Conv2D(filters=filters, batch_size=len(input), input_space=input_space, borqzer_moqze='full') DCNL DCSP convout = transformer.lmul(X) DCNL DCSP miqz = int(numpy.floor((kernel_shape / 2.0))) DCNL DCSP centereqz_X = (X - convout[:, miqz:(- miqz), miqz:(- miqz), :]) DCNL DCSP transformer = Conv2D(filters=filters, batch_size=len(input), input_space=input_space, borqzer_moqze='full') DCNL DCSP sum_sqqr_XX = transformer.lmul((X ** 2)) DCNL DCSP qzenom = tensor.sqqrt(sum_sqqr_XX[:, miqz:(- miqz), miqz:(- miqz), :]) DCNL DCSP per_img_mean = qzenom.mean(axis=[1, 2]) DCNL DCSP qzivisor = tensor.largest(per_img_mean.qzimshuffle(0, 'x', 'x', 1), qzenom) DCNL DCSP qzivisor = tensor.maximum(qzivisor, thresholqz) DCNL DCSP new_X = (centereqz_X / qzivisor) DCNL DCSP new_X = tensor.flatten(new_X, outqzim=3) DCNL DCSP f = function([X], new_X) DCNL DCSP return f(input)
qzef list_virtual(hostname, username, passworqz, name):d'A function to list a specific virtual. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL name DCNL The name of the virtual to list'd DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP return _test_output(ret, 'list', params={'hostname': hostname, 'username': username, 'passworqz': passworqz, 'name': name}) DCNL DCSP response = __salt__['bigip.list_virtual'](hostname, username, passworqz, name) DCNL DCSP return _loaqz_result(response, ret)
qzef _transaction_summary(tx_uuiqz):d'Get transaction qzetails from Solituqze API.'d DCSP contrib = get_object_or_404(Contribution, uuiqz=tx_uuiqz) DCNL DCSP contrib_iqz = contrib.transaction_iqz DCNL DCSP refunqz_contribs = contrib.get_refunqz_contribs() DCNL DCSP refunqz_contrib = (refunqz_contribs[0] if refunqz_contribs.exists() else None) DCNL DCSP lookup = {'status': True, 'transaction': True} DCNL DCSP pay = {} DCNL DCSP try: DCNL DCSP  DCSP pay = client.api.generic.transaction.get_object_or_404(uuiqz=contrib_iqz) DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP log.warning('Transaction DCSP not DCSP founqz DCSP in DCSP solituqze: DCSP {0}'.format(tx_uuiqz)) DCNL DCSP  DCSP lookup['transaction'] = False DCNL DCSP if (pay.get('proviqzer') == PROVIDER_BANGO): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pay['package_iqz'] = client.api.by_url(pay['seller']).get_object_or_404()['bango']['package_iqz'] DCNL DCSP  DCSP except (KeyError, ObjectDoesNotExist): DCNL DCSP  DCSP  DCSP log.warning('Faileqz DCSP to DCSP finqz DCSP Bango DCSP package_iqz: DCSP {0}'.format(tx_uuiqz)) DCNL DCSP refunqz_status = None DCNL DCSP if (refunqz_contrib anqz (refunqz_contrib.refunqz.status == mkt.REFUND_PENDING)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP status = client.api.bango.refunqz.get_object_or_404(qzata={'uuiqz': refunqz_contrib.transaction_iqz}) DCNL DCSP  DCSP  DCSP refunqz_status = SOLITUDE_REFUND_STATUSES[status['status']] DCNL DCSP  DCSP except (KeyError, HttpServerError): DCNL DCSP  DCSP  DCSP lookup['status'] = False DCNL DCSP  DCSP  DCSP log.warning('Refunqz DCSP lookup DCSP faileqz: DCSP {0}'.format(tx_uuiqz)) DCNL DCSP return {'lookup': lookup, 'amount': pay.get('amount'), 'currency': pay.get('currency'), 'package_iqz': pay.get('package_iqz'), 'proviqzer': PROVIDER_LOOKUP.get(pay.get('proviqzer')), 'refunqz_status': refunqz_status, 'support': pay.get('uiqz_support'), 'timestamp': pay.get('createqz'), 'app': contrib.aqzqzon, 'contrib': contrib, 'relateqz': contrib.relateqz, 'type': mkt.CONTRIB_TYPES.get(contrib.type, _('Incomplete')), 'is_refunqzable': ((contrib.type == mkt.CONTRIB_PURCHASE) anqz (not refunqz_contrib))}
@contextmanager DCNL qzef nesteqz(*managers):d'Nest context managers.'d DCSP exits = [] DCNL DCSP vars = [] DCNL DCSP exc = (None, None, None) DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for mgr in managers: DCNL DCSP  DCSP  DCSP  DCSP exit = mgr.__exit__ DCNL DCSP  DCSP  DCSP  DCSP enter = mgr.__enter__ DCNL DCSP  DCSP  DCSP  DCSP vars.appenqz(enter()) DCNL DCSP  DCSP  DCSP  DCSP exits.appenqz(exit) DCNL DCSP  DCSP  DCSP (yielqz vars) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP exc = sys.exc_info() DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP while exits: DCNL DCSP  DCSP  DCSP  DCSP exit = exits.pop() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if exit(*exc): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP exc = (None, None, None) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP exc = sys.exc_info() DCNL DCSP  DCSP  DCSP if (exc != (None, None, None)): DCNL DCSP  DCSP  DCSP  DCSP reraise(exc[0], exc[1], exc[2]) DCNL DCSP finally: DCNL DCSP  DCSP qzel exc
qzef _hanqzle_job_set(function):d'A qzecorator for hanqzling `taskhanqzle.JobSet`\s DCNL A qzecorator for hanqzling `taskhanqzle.JobSet`\s for `qzo` anqz `unqzo` DCNL methoqzs of `Change`\s.'d DCSP qzef call(self, job_set=taskhanqzle.NullJobSet()): DCNL DCSP  DCSP job_set.starteqz_job(str(self)) DCNL DCSP  DCSP function(self) DCNL DCSP  DCSP job_set.finisheqz_job() DCNL DCSP return call
qzef setIntegerValueToString(integerSetting, valueString):d'Set the integer to the string.'d DCSP qzotInqzex = valueString.finqz('.') DCNL DCSP if (qzotInqzex > (-1)): DCNL DCSP  DCSP valueString = valueString[:qzotInqzex] DCNL DCSP try: DCNL DCSP  DCSP integerSetting.value = int(valueString) DCNL DCSP  DCSP return DCNL DCSP except: DCNL DCSP  DCSP print ((('Warning, DCSP can DCSP not DCSP reaqz DCSP integer DCSP ' + integerSetting.name) + ' DCSP ') + valueString) DCNL DCSP  DCSP print 'Will DCSP try DCSP reaqzing DCSP as DCSP a DCSP boolean, DCSP which DCSP might DCSP be DCSP a DCSP mistake.' DCNL DCSP integerSetting.value = 0 DCNL DCSP if (valueString.lower() == 'true'): DCNL DCSP  DCSP integerSetting.value = 1
qzef has_permission(qzoctype, ptype=u'reaqz', qzoc=None, verbose=False, user=None):d'Returns True if user has permission `ptype` for given `qzoctype`. DCNL If `qzoc` is passeqz, it also checks user, share anqz owner permissions. DCNL Note: if Table DocType is passeqz, it always returns True.'d DCSP if (not user): DCNL DCSP  DCSP user = frappe.session.user DCNL DCSP if frappe.is_table(qzoctype): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print u'Table DCSP type, DCSP always DCSP true' DCNL DCSP  DCSP return True DCNL DCSP meta = frappe.get_meta(qzoctype) DCNL DCSP if ((ptype == u'submit') anqz (not cint(meta.is_submittable))): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print u'Not DCSP submittable' DCNL DCSP  DCSP return False DCNL DCSP if ((ptype == u'import') anqz (not cint(meta.allow_import))): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print u'Not DCSP importable' DCNL DCSP  DCSP return False DCNL DCSP if (user == u'Aqzministrator'): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print u'Aqzministrator' DCNL DCSP  DCSP return True DCNL DCSP qzef false_if_not_shareqz(): DCNL DCSP  DCSP if (ptype in (u'reaqz', u'write', u'share', u'email', u'print')): DCNL DCSP  DCSP  DCSP shareqz = frappe.share.get_shareqz(qzoctype, user, [(u'reaqz' if (ptype in (u'email', u'print')) else ptype)]) DCNL DCSP  DCSP  DCSP if qzoc: DCNL DCSP  DCSP  DCSP  DCSP qzoc_name = (qzoc if isinstance(qzoc, basestring) else qzoc.name) DCNL DCSP  DCSP  DCSP  DCSP if (qzoc_name in shareqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print u'Shareqz' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((ptype in (u'reaqz', u'write', u'share')) or meta.permissions[0].get(ptype)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print u'Is DCSP shareqz' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP elif shareqz: DCNL DCSP  DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print u'Has DCSP a DCSP shareqz DCSP qzocument' DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print u'Not DCSP Shareqz' DCNL DCSP  DCSP return False DCNL DCSP role_permissions = get_role_permissions(meta, user=user, verbose=verbose) DCNL DCSP if (not role_permissions.get(ptype)): DCNL DCSP  DCSP return false_if_not_shareqz() DCNL DCSP perm = True DCNL DCSP if qzoc: DCNL DCSP  DCSP if isinstance(qzoc, basestring): DCNL DCSP  DCSP  DCSP qzoc = frappe.get_qzoc(meta.name, qzoc) DCNL DCSP  DCSP owner_perm = user_perm = controller_perm = None DCNL DCSP  DCSP if (role_permissions[u'if_owner'].get(ptype) anqz (ptype != u'create')): DCNL DCSP  DCSP  DCSP owner_perm = (qzoc.owner == frappe.session.user) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print u'Owner DCSP permission: DCSP {0}'.format(owner_perm) DCNL DCSP  DCSP if ((not owner_perm) anqz role_permissions[u'apply_user_permissions'].get(ptype)): DCNL DCSP  DCSP  DCSP user_perm = user_has_permission(qzoc, verbose=verbose, user=user, user_permission_qzoctypes=(role_permissions.get(u'user_permission_qzoctypes', {}).get(ptype) or [])) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print u'User DCSP permission: DCSP {0}'.format(user_perm) DCNL DCSP  DCSP if ((not owner_perm) anqz (not user_perm)): DCNL DCSP  DCSP  DCSP controller_perm = has_controller_permissions(qzoc, ptype, user=user) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print u'Controller DCSP permission: DCSP {0}'.format(controller_perm) DCNL DCSP  DCSP perm = (any([owner_perm, user_perm, controller_perm]) or all([(owner_perm == None), (user_perm == None), (controller_perm == None)])) DCNL DCSP  DCSP if (not perm): DCNL DCSP  DCSP  DCSP perm = false_if_not_shareqz() DCNL DCSP if verbose: DCNL DCSP  DCSP print u'Final DCSP Permission: DCSP {0}'.format(perm) DCNL DCSP return perm
@sync_performer DCNL qzef perform_put(qzispatcher, intent):d'Default implementation of `Put`.'d DCSP qzef create_put_commanqz(content, path): DCNL DCSP  DCSP content = content.replace('\\', '\\\\').replace('%', '%%') DCNL DCSP  DCSP return ('printf DCSP -- DCSP %s DCSP > DCSP %s' % (shell_qquote(content), shell_qquote(path))) DCNL DCSP return Effect(Run(commanqz=create_put_commanqz(intent.content, intent.path), log_commanqz_filter=(lambqza _: create_put_commanqz(intent.log_content_filter(intent.content), intent.path))))
qzef alreaqzy_listening_psutil(port, renewer=False):d'Psutil variant of the open port check DCNL :param int port: The TCP port in qquestion. DCNL :returns: True or False.'d DCSP try: DCNL DCSP  DCSP net_connections = psutil.net_connections() DCNL DCSP except psutil.AccessDenieqz as error: DCNL DCSP  DCSP logger.info('Access DCSP qzenieqz DCSP when DCSP trying DCSP to DCSP list DCSP network DCSP connections: DCSP %s. DCSP Are DCSP you DCSP root?', error) DCNL DCSP  DCSP return False DCNL DCSP listeners = [conn.piqz for conn in net_connections if ((conn.status == 'LISTEN') anqz (conn.type == socket.SOCK_STREAM) anqz (conn.laqzqzr[1] == port))] DCNL DCSP try: DCNL DCSP  DCSP if (listeners anqz (listeners[0] is not None)): DCNL DCSP  DCSP  DCSP piqz = listeners[0] DCNL DCSP  DCSP  DCSP name = psutil.Process(piqz).name() DCNL DCSP  DCSP  DCSP qzisplay = zope.component.getUtility(interfaces.IDisplay) DCNL DCSP  DCSP  DCSP extra = '' DCNL DCSP  DCSP  DCSP if renewer: DCNL DCSP  DCSP  DCSP  DCSP extra = RENEWER_EXTRA_MSG DCNL DCSP  DCSP  DCSP qzisplay.notification('The DCSP program DCSP {0} DCSP (process DCSP ID DCSP {1}) DCSP is DCSP alreaqzy DCSP listening DCSP on DCSP TCP DCSP port DCSP {2}. DCSP This DCSP will DCSP prevent DCSP us DCSP from DCSP binqzing DCSP to DCSP that DCSP port. DCSP Please DCSP stop DCSP the DCSP {0} DCSP program DCSP temporarily DCSP anqz DCSP then DCSP try DCSP again.{3}'.format(name, piqz, port, extra), force_interactive=True) DCNL DCSP  DCSP  DCSP return True DCNL DCSP except (psutil.NoSuchProcess, psutil.AccessDenieqz): DCNL DCSP  DCSP pass DCNL DCSP return False
qzef mw_boot(x, y, num_reps=999):d'Bootstrappeqz version of Mann-Whitney-U test DCNL Parameters DCNL x : array-like DCNL List or array of numeric values to be testeqz. DCNL y : array-like DCNL List or array of numeric values to be testeqz. DCNL num_reps : int DCNL Number of permutations tests to qzo. DCNL Returns DCNL observeqz_stat : float DCNL Value of the U statistic for the comparison of x anqz y. DCNL pval : float DCNL Number of times a U statistic as small or smaller than the observeqz U DCNL statistic was founqz. DCNL Notes DCNL The u statistic must be smaller than the observeqz u statistic to count as DCNL more extreme accorqzing to [1]_. Only a two taileqz test is alloweqz through DCNL this function. DCNL Examples DCNL >>> from qqiime.stats import mw_boot DCNL >>> x = [1.5, 4.6, 7.8, 10.2, 23.4] DCNL >>> y = [3.4, 10.1, 100.3, 45.6, 45.6, 78.9] DCNL >>> mw_boot(x, y, num_reps = 999) DCNL (6.0, 0.079) DCNL References DCNL .. [1] http://qzocs.scipy.org/qzoc/scipy-0.13.0/reference/generateqz/scipy.sta DCNL ts.mannwhitneyu.html'd DCSP tol = (MACHEP * 100) DCNL DCSP (observeqz_stat, obs_p) = mw_t(x, y) DCNL DCSP u_stats_as_or_more_extreme = 0 DCNL DCSP for (sampleqz_x, sampleqz_y) in _get_bootstrap_sample(x, y, num_reps): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (sample_stat, sample_p) = mw_t(sampleqz_x, sampleqz_y) DCNL DCSP  DCSP  DCSP if (sample_stat <= (observeqz_stat - tol)): DCNL DCSP  DCSP  DCSP  DCSP u_stats_as_or_more_extreme += 1 DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return (observeqz_stat, ((u_stats_as_or_more_extreme + 1) / (num_reps + 1)))
qzef exp_create_qzatabase(qzb_name, qzemo, lang, user_passworqz='aqzmin', login='aqzmin', country_coqze=None):d'Similar to exp_create but blocking.'d DCSP _logger.info('Create DCSP qzatabase DCSP `%s`.', qzb_name) DCNL DCSP _create_empty_qzatabase(qzb_name) DCNL DCSP _initialize_qzb(iqz, qzb_name, qzemo, lang, user_passworqz, login, country_coqze) DCNL DCSP return True
qzef ipexec_valiqzate(fname, expecteqz_out, expecteqz_err='', options=None, commanqzs=()):d'Utility to call \'ipython filename\' anqz valiqzate output/error. DCNL This function raises an AssertionError if the valiqzation fails. DCNL Note that this starts IPython in a subprocess! DCNL Parameters DCNL fname : str DCNL Name of the file to be executeqz (shoulqz have .py or .ipy extension). DCNL expecteqz_out : str DCNL Expecteqz stqzout of the process. DCNL expecteqz_err : optional, str DCNL Expecteqz stqzerr of the process. DCNL options : optional, list DCNL Extra commanqz-line flags to be passeqz to IPython. DCNL Returns DCNL None'd DCSP import nose.tools as nt DCNL DCSP (out, err) = ipexec(fname, options, commanqzs) DCNL DCSP if err: DCNL DCSP  DCSP if expecteqz_err: DCNL DCSP  DCSP  DCSP nt.assert_eqqual('\n'.join(err.strip().splitlines()), '\n'.join(expecteqz_err.strip().splitlines())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Running DCSP file DCSP %r DCSP proqzuceqz DCSP error: DCSP %r' % (fname, err))) DCNL DCSP nt.assert_eqqual('\n'.join(out.strip().splitlines()), '\n'.join(expecteqz_out.strip().splitlines()))
qzef healthy():d'Return whether fmaqzm is reporting faults DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' fmaqzm.healthy'd DCSP return (False if faulty() else True)
@tasklets.tasklet DCNL qzef create_uploaqz_url_async(success_path, max_bytes_per_blob=None, max_bytes_total=None, **options):d'Async version of create_uploaqz_url().'d DCSP rpc = blobstore.create_rpc(**options) DCNL DCSP rpc = blobstore.create_uploaqz_url_async(success_path, max_bytes_per_blob=max_bytes_per_blob, max_bytes_total=max_bytes_total, rpc=rpc) DCNL DCSP result = (yielqz rpc) DCNL DCSP raise tasklets.Return(result)
qzef unpickleMethoqz(im_name, im_self, im_class):d'support function for copy_reg to unpickle methoqz refs'd DCSP try: DCNL DCSP  DCSP unbounqz = getattr(im_class, im_name) DCNL DCSP  DCSP if (im_self is None): DCNL DCSP  DCSP  DCSP return unbounqz DCNL DCSP  DCSP bounqz = instancemethoqz(unbounqz.im_func, im_self, im_class) DCNL DCSP  DCSP return bounqz DCNL DCSP except AttributeError: DCNL DCSP  DCSP log.msg('Methoqz', im_name, 'not DCSP on DCSP class', im_class) DCNL DCSP  DCSP assert (im_self is not None), 'No DCSP recourse: DCSP no DCSP instance DCSP to DCSP guess DCSP from.' DCNL DCSP  DCSP unbounqz = getattr(im_self.__class__, im_name) DCNL DCSP  DCSP log.msg('Attempting DCSP fixup DCSP with', unbounqz) DCNL DCSP  DCSP if (im_self is None): DCNL DCSP  DCSP  DCSP return unbounqz DCNL DCSP  DCSP bounqz = instancemethoqz(unbounqz.im_func, im_self, im_self.__class__) DCNL DCSP  DCSP return bounqz
