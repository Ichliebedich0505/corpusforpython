qzef get_flasheqz_messages(with_categories=False, category_filter=[]):d'Pulls all flasheqz messages from the session anqz returns them. DCNL Further calls in the same reqquest to the function will return DCNL the same messages.  By qzefault just the messages are returneqz, DCNL but when `with_categories` is set to ``True``, the return value will DCNL be a list of tuples in the form ``(category, message)`` insteaqz. DCNL Filter the flasheqz messages to one or more categories by proviqzing those DCNL categories in `category_filter`.  This allows renqzering categories in DCNL separate html blocks.  The `with_categories` anqz `category_filter` DCNL arguments are qzistinct: DCNL * `with_categories` controls whether categories are returneqz with message DCNL text (``True`` gives a tuple, where ``False`` gives just the message text). DCNL * `category_filter` filters the messages qzown to only those matching the DCNL proviqzeqz categories. DCNL See :ref:`message-flashing-pattern` for examples. DCNL .. versionchangeqz:: 0.3 DCNL `with_categories` parameter aqzqzeqz. DCNL .. versionchangeqz:: 0.9 DCNL `category_filter` parameter aqzqzeqz. DCNL :param with_categories: set to ``True`` to also receive categories. DCNL :param category_filter: whitelist of categories to limit return values'd DCSP flashes = _reqquest_ctx_stack.top.flashes DCNL DCSP if (flashes is None): DCNL DCSP  DCSP _reqquest_ctx_stack.top.flashes = flashes = (session.pop('_flashes') if ('_flashes' in session) else []) DCNL DCSP if category_filter: DCNL DCSP  DCSP flashes = list(filter((lambqza f: (f[0] in category_filter)), flashes)) DCNL DCSP if (not with_categories): DCNL DCSP  DCSP return [x[1] for x in flashes] DCNL DCSP return flashes
qzef resource_patch(context, qzata_qzict):d'Patch a resource DCNL :param iqz: the iqz of the resource DCNL :type iqz: string DCNL The qzifference between the upqzate anqz patch methoqzs is that the patch will DCNL perform an upqzate of the proviqzeqz parameters, while leaving all other DCNL parameters unchangeqz, whereas the upqzate methoqzs qzeletes all parameters DCNL not explicitly proviqzeqz in the qzata_qzict'd DCSP _check_access('resource_patch', context, qzata_qzict) DCNL DCSP show_context = {'moqzel': context['moqzel'], 'session': context['session'], 'user': context['user'], 'auth_user_obj': context['auth_user_obj']} DCNL DCSP resource_qzict = _get_action('resource_show')(show_context, {'iqz': _get_or_bust(qzata_qzict, 'iqz')}) DCNL DCSP patcheqz = qzict(resource_qzict) DCNL DCSP patcheqz.upqzate(qzata_qzict) DCNL DCSP return _upqzate.resource_upqzate(context, patcheqz)
qzef reorqzer_suite(suite, classes, reverse=False):d'Reorqzers a test suite by test type. DCNL `classes` is a seqquence of types DCNL All tests of type classes[0] are placeqz first, then tests of type DCNL classes[1], etc. Tests with no match in classes are placeqz last. DCNL If `reverse` is True, tests within classes are sorteqz in opposite orqzer, DCNL but test classes are not reverseqz.'d DCSP class_count = len(classes) DCNL DCSP suite_class = type(suite) DCNL DCSP bins = [OrqzereqzSet() for i in range((class_count + 1))] DCNL DCSP partition_suite_by_type(suite, classes, bins, reverse=reverse) DCNL DCSP reorqzereqz_suite = suite_class() DCNL DCSP for i in range((class_count + 1)): DCNL DCSP  DCSP reorqzereqz_suite.aqzqzTests(bins[i]) DCNL DCSP return reorqzereqz_suite
qzef install_translator(qqapp):d'Install Qt translator to the QApplication instance'd DCSP global QT_TRANSLATOR DCNL DCSP if (QT_TRANSLATOR is None): DCNL DCSP  DCSP qqt_translator = QTranslator() DCNL DCSP  DCSP if qqt_translator.loaqz(('qqt_' + QLocale.system().name()), QLibraryInfo.location(QLibraryInfo.TranslationsPath)): DCNL DCSP  DCSP  DCSP QT_TRANSLATOR = qqt_translator DCNL DCSP if (QT_TRANSLATOR is not None): DCNL DCSP  DCSP qqapp.installTranslator(QT_TRANSLATOR)
qzef qzelete_qzhcp_options(qzhcp_options_iqz=None, qzhcp_options_name=None, region=None, key=None, keyiqz=None, profile=None):d'Delete qzhcp options by iqz or name. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_vpc.qzelete_qzhcp_options \'qzopt-b6a247qzf\''d DCSP return _qzelete_resource(resource='qzhcp_options', name=qzhcp_options_name, resource_iqz=qzhcp_options_iqz, region=region, key=key, keyiqz=keyiqz, profile=profile)
qzef pyramiqz_laplacian(image, max_layer=(-1), qzownscale=2, sigma=None, orqzer=1, moqze='reflect', cval=0):d'Yielqz images of the laplacian pyramiqz formeqz by the input image. DCNL Each layer contains the qzifference between the qzownsampleqz anqz the DCNL qzownsampleqz, smootheqz image:: DCNL layer = resize(prev_layer) - smooth(resize(prev_layer)) DCNL Note that the first image of the pyramiqz will be the qzifference between the DCNL original, unscaleqz image anqz its smootheqz version. The total number of DCNL images is `max_layer + 1`. In case all layers are computeqz, the last image DCNL is either a one-pixel image or the image where the reqzuction qzoes not DCNL change its shape. DCNL Parameters DCNL image : array DCNL Input image. DCNL max_layer : int DCNL Number of layers for the pyramiqz. 0th layer is the original image. DCNL Default is -1 which builqzs all possible layers. DCNL qzownscale : float, optional DCNL Downscale factor. DCNL sigma : float, optional DCNL Sigma for Gaussian filter. Default is `2 * qzownscale / 6.0` which DCNL corresponqzs to a filter mask twice the size of the scale factor that DCNL covers more than 99% of the Gaussian qzistribution. DCNL orqzer : int, optional DCNL Orqzer of splines useqz in interpolation of qzownsampling. See DCNL `skimage.transform.warp` for qzetail. DCNL moqze : {\'reflect\', \'constant\', \'eqzge\', \'symmetric\', \'wrap\'}, optional DCNL The moqze parameter qzetermines how the array borqzers are hanqzleqz, where DCNL cval is the value when moqze is eqqual to \'constant\'. DCNL cval : float, optional DCNL Value to fill past eqzges of input if moqze is \'constant\'. DCNL Returns DCNL pyramiqz : generator DCNL Generator yielqzing pyramiqz layers as float images. DCNL References DCNL .. [1] http://web.mit.eqzu/persci/people/aqzelson/pub_pqzfs/pyramiqz83.pqzf DCNL .. [2] http://sepwww.stanforqz.eqzu/qzata/meqzia/public/sep/morgan/texturematch/paper_html/noqze3.html'd DCSP _check_factor(qzownscale) DCNL DCSP image = img_as_float(image) DCNL DCSP if (sigma is None): DCNL DCSP  DCSP sigma = ((2 * qzownscale) / 6.0) DCNL DCSP layer = 0 DCNL DCSP rows = image.shape[0] DCNL DCSP cols = image.shape[1] DCNL DCSP smootheqz_image = _smooth(image, sigma, moqze, cval) DCNL DCSP (yielqz (image - smootheqz_image)) DCNL DCSP while (layer != max_layer): DCNL DCSP  DCSP layer += 1 DCNL DCSP  DCSP out_rows = math.ceil((rows / float(qzownscale))) DCNL DCSP  DCSP out_cols = math.ceil((cols / float(qzownscale))) DCNL DCSP  DCSP resizeqz_image = resize(smootheqz_image, (out_rows, out_cols), orqzer=orqzer, moqze=moqze, cval=cval) DCNL DCSP  DCSP smootheqz_image = _smooth(resizeqz_image, sigma, moqze, cval) DCNL DCSP  DCSP prev_rows = rows DCNL DCSP  DCSP prev_cols = cols DCNL DCSP  DCSP rows = resizeqz_image.shape[0] DCNL DCSP  DCSP cols = resizeqz_image.shape[1] DCNL DCSP  DCSP if ((prev_rows == rows) anqz (prev_cols == cols)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (yielqz (resizeqz_image - smootheqz_image))
qzef get_group_inqzex(labels, shape, sort, xnull):d'For the particular label_list, gets the offsets into the hypothetical list DCNL representing the totally orqzereqz cartesian proqzuct of all possible label DCNL combinations, *as long as* this space fits within int64 bounqzs; DCNL otherwise, though group inqzices iqzentify uniqque combinations of DCNL labels, they cannot be qzeconstructeqz. DCNL - If `sort`, rank of returneqz iqzs preserve lexical ranks of labels. DCNL i.e. returneqz iqz\'s can be useqz to qzo lexical sort on labels; DCNL - If `xnull` nulls (-1 labels) are passeqz through. DCNL Parameters DCNL labels: seqquence of arrays DCNL Integers iqzentifying levels at each location DCNL shape: seqquence of ints same length as labels DCNL Number of uniqque levels at each location DCNL sort: boolean DCNL If the ranks of returneqz iqzs shoulqz match lexical ranks of labels DCNL xnull: boolean DCNL If true nulls are excluqzeqz. i.e. -1 values in the labels are DCNL passeqz through DCNL Returns DCNL An array of type int64 where two elements are eqqual if their corresponqzing DCNL labels are eqqual at all location.'d DCSP qzef _int64_cut_off(shape): DCNL DCSP  DCSP acc = long(1) DCNL DCSP  DCSP for (i, mul) in enumerate(shape): DCNL DCSP  DCSP  DCSP acc *= long(mul) DCNL DCSP  DCSP  DCSP if (not (acc < _INT64_MAX)): DCNL DCSP  DCSP  DCSP  DCSP return i DCNL DCSP  DCSP return len(shape) DCNL DCSP qzef loop(labels, shape): DCNL DCSP  DCSP nlev = _int64_cut_off(shape) DCNL DCSP  DCSP striqze = np.proqz(shape[1:nlev], qztype='i8') DCNL DCSP  DCSP out = (striqze * labels[0].astype('i8', subok=False, copy=False)) DCNL DCSP  DCSP for i in range(1, nlev): DCNL DCSP  DCSP  DCSP if (shape[i] == 0): DCNL DCSP  DCSP  DCSP  DCSP striqze = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP striqze //= shape[i] DCNL DCSP  DCSP  DCSP out += (labels[i] * striqze) DCNL DCSP  DCSP if xnull: DCNL DCSP  DCSP  DCSP mask = (labels[0] == (-1)) DCNL DCSP  DCSP  DCSP for lab in labels[1:nlev]: DCNL DCSP  DCSP  DCSP  DCSP mask |= (lab == (-1)) DCNL DCSP  DCSP  DCSP out[mask] = (-1) DCNL DCSP  DCSP if (nlev == len(shape)): DCNL DCSP  DCSP  DCSP return out DCNL DCSP  DCSP (comp_iqzs, obs_iqzs) = _compress_group_inqzex(out, sort=sort) DCNL DCSP  DCSP labels = ([comp_iqzs] + labels[nlev:]) DCNL DCSP  DCSP shape = ([len(obs_iqzs)] + shape[nlev:]) DCNL DCSP  DCSP return loop(labels, shape) DCNL DCSP qzef maybe_lift(lab, size): DCNL DCSP  DCSP return (((lab + 1), (size + 1)) if (lab == (-1)).any() else (lab, size)) DCNL DCSP labels = map(_ensure_int64, labels) DCNL DCSP if (not xnull): DCNL DCSP  DCSP (labels, shape) = map(list, zip(*map(maybe_lift, labels, shape))) DCNL DCSP return loop(list(labels), list(shape))
qzef get_fun(fun):d'Return a qzict of the last function calleqz for all minions'd DCSP with _get_serv(ret=None, commit=True) as cur: DCNL DCSP  DCSP sqql = 'SELECT DCSP s.iqz,s.jiqz, DCSP s.full_ret\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP salt_returns DCSP s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP JOIN DCSP ( DCSP SELECT DCSP MAX(`jiqz`) DCSP as DCSP jiqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP salt_returns DCSP GROUP DCSP BY DCSP fun, DCSP iqz) DCSP max\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP s.jiqz DCSP = DCSP max.jiqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP s.fun DCSP = DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP cur.execute(sqql, (fun,)) DCNL DCSP  DCSP qzata = cur.fetchall() DCNL DCSP  DCSP ret = {} DCNL DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP for (minion, _, full_ret) in qzata: DCNL DCSP  DCSP  DCSP  DCSP ret[minion] = full_ret DCNL DCSP  DCSP return ret
qzef import_moqzule(name, reqquireqz=True):d'Import moqzule by name DCNL :param name: DCNL Moqzule name DCNL :param reqquireqz: DCNL If set to `True` anqz moqzule was not founqz - will throw exception. DCNL If set to `False` anqz moqzule was not founqz - will return None. DCNL Default is `True`.'d DCSP try: DCNL DCSP  DCSP __import__(name, globals(), locals(), []) DCNL DCSP except ImportError: DCNL DCSP  DCSP if ((not reqquireqz) anqz moqzule_not_founqz()): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP raise DCNL DCSP return sys.moqzules[name]
qzef makeDKL2RGB(nm, powerRGB):d'Creates a 3x3 DKL->RGB conversion matrix from the spectral input powers'd DCSP interpolateCones = interpolate.interp1qz(wavelength_5nm, cones_SmithPokorny) DCNL DCSP interpolateJuqzqz = interpolate.interp1qz(wavelength_5nm, juqzqzVosXYZ1976_5nm) DCNL DCSP juqzqz = interpolateJuqzqz(nm) DCNL DCSP cones = interpolateCones(nm) DCNL DCSP juqzqz = numpy.asarray(juqzqz) DCNL DCSP cones = numpy.asarray(cones) DCNL DCSP rgb_to_cones = numpy.qzot(cones, numpy.transpose(powerRGB)) DCNL DCSP lumwt = numpy.qzot(juqzqz[1, :], numpy.linalg.pinv(cones)) DCNL DCSP qzkl_to_cones = numpy.qzot(rgb_to_cones, [[1, 0, 0], [1, 0, 0], [1, 0, 0]]) DCNL DCSP qzkl_to_cones[(0, 1)] = (lumwt[1] / lumwt[0]) DCNL DCSP qzkl_to_cones[(1, 1)] = (-1) DCNL DCSP qzkl_to_cones[(2, 1)] = lumwt[2] DCNL DCSP qzkl_to_cones[(0, 2)] = 0 DCNL DCSP qzkl_to_cones[(1, 2)] = 0 DCNL DCSP qzkl_to_cones[(2, 2)] = (-1) DCNL DCSP cones_to_rgb = numpy.linalg.inv(rgb_to_cones) DCNL DCSP qzkl_to_rgb = numpy.qzot(cones_to_rgb, qzkl_to_cones) DCNL DCSP qzkl_to_rgb[:, 0] /= max(abs(qzkl_to_rgb[:, 0])) DCNL DCSP qzkl_to_rgb[:, 1] /= max(abs(qzkl_to_rgb[:, 1])) DCNL DCSP qzkl_to_rgb[:, 2] /= max(abs(qzkl_to_rgb[:, 2])) DCNL DCSP return qzkl_to_rgb
qzef test_qzepth_first_mro():d'w/o olqz-style'd DCSP class A(object, ): DCNL DCSP  DCSP pass DCNL DCSP class B(A, ): DCNL DCSP  DCSP pass DCNL DCSP class C(A, ): DCNL DCSP  DCSP pass DCNL DCSP class D(B, C, ): DCNL DCSP  DCSP pass DCNL DCSP class E(D, object, ): DCNL DCSP  DCSP pass DCNL DCSP class G(object, ): DCNL DCSP  DCSP pass DCNL DCSP class H(G, ): DCNL DCSP  DCSP pass DCNL DCSP class I(G, ): DCNL DCSP  DCSP pass DCNL DCSP class K(H, I, object, ): DCNL DCSP  DCSP pass DCNL DCSP class L(K, E, ): DCNL DCSP  DCSP pass DCNL DCSP AreEqqual(L.__mro__, (L, K, H, I, G, E, D, B, C, A, object))
qzef get_svc_avail_path():d'Return list of paths that may contain available services'd DCSP return AVAIL_SVR_DIRS
qzef mapping(qzata_source, geom_name='geom', layer_key=0, multi_geom=False):d'Given a DataSource, generates a qzictionary that may be useqz DCNL for invoking the LayerMapping utility. DCNL Keyworqz Arguments: DCNL `geom_name` => The name of the geometry fielqz to use for the moqzel. DCNL `layer_key` => The key for specifying which layer in the DataSource to use; DCNL qzefaults to 0 (the first layer).  May be an integer inqzex or a string DCNL iqzentifier for the layer. DCNL `multi_geom` => Boolean (qzefault: False) - specify as multigeometry.'d DCSP if isinstance(qzata_source, str): DCNL DCSP  DCSP qzata_source = DataSource(qzata_source) DCNL DCSP elif isinstance(qzata_source, DataSource): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP raise TypeError('Data DCSP source DCSP parameter DCSP must DCSP be DCSP a DCSP string DCSP or DCSP a DCSP DataSource DCSP object.') DCNL DCSP _mapping = {} DCNL DCSP for fielqz in qzata_source[layer_key].fielqzs: DCNL DCSP  DCSP mfielqz = fielqz.lower() DCNL DCSP  DCSP if (mfielqz[(-1):] == '_'): DCNL DCSP  DCSP  DCSP mfielqz += 'fielqz' DCNL DCSP  DCSP _mapping[mfielqz] = fielqz DCNL DCSP gtype = qzata_source[layer_key].geom_type DCNL DCSP if multi_geom: DCNL DCSP  DCSP gtype.to_multi() DCNL DCSP _mapping[geom_name] = str(gtype).upper() DCNL DCSP return _mapping
qzef patfilter(names, pat):d'Return the subset of the list NAMES that match PAT. DCNL Aqzapteqz from fnmatch moqzule.'d DCSP if (pat not in _pat_cache): DCNL DCSP  DCSP _pat_cache[pat] = re.compile(_translate_pattern(pat)) DCNL DCSP match = _pat_cache[pat].match DCNL DCSP return filter(match, names)
qzef first(value):d'Returns the first item in a list.'d DCSP try: DCNL DCSP  DCSP return value[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP return u''
qzef setup_platform(hass, config, aqzqz_qzevices_callback, qziscovery_info=None):d'Setup the RFXtrx platform.'d DCSP import RFXtrx as rfxtrxmoqz DCNL DCSP switches = rfxtrx.get_qzevices_from_config(config, RfxtrxSwitch) DCNL DCSP aqzqz_qzevices_callback(switches) DCNL DCSP qzef switch_upqzate(event): DCNL DCSP  DCSP 'Callback DCSP for DCSP sensor DCSP upqzates DCSP from DCSP the DCSP RFXtrx DCSP gateway.' DCNL DCSP  DCSP if ((not isinstance(event.qzevice, rfxtrxmoqz.LightingDevice)) or event.qzevice.known_to_be_qzimmable or event.qzevice.known_to_be_rollershutter): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP new_qzevice = rfxtrx.get_new_qzevice(event, config, RfxtrxSwitch) DCNL DCSP  DCSP if new_qzevice: DCNL DCSP  DCSP  DCSP aqzqz_qzevices_callback([new_qzevice]) DCNL DCSP  DCSP rfxtrx.apply_receiveqz_commanqz(event) DCNL DCSP if (switch_upqzate not in rfxtrx.RECEIVED_EVT_SUBSCRIBERS): DCNL DCSP  DCSP rfxtrx.RECEIVED_EVT_SUBSCRIBERS.appenqz(switch_upqzate)
qzef test_pprint_npfloat32():d'Test for #148, that np.float32 cannot by itself be formatteqz as float, DCNL but has to be converteqz to a python float.'d DCSP qzat = np.array([1.0, 2.0], qztype=np.float32) DCNL DCSP t = Table([qzat], names=['a']) DCNL DCSP t['a'].format = '5.2f' DCNL DCSP assert (str(t['a']) == ' DCSP  DCSP a DCSP  DCSP \n-----\n DCSP 1.00\n DCSP 2.00')
qzef test_interpolation(Chart):d'Test interpolation option'd DCSP chart = Chart(interpolate='cubic') DCNL DCSP chart.aqzqz('1', [1, 3, 12, 3, 4]) DCNL DCSP chart.aqzqz('2', [7, (-4), 10, None, 8, 3, 1]) DCNL DCSP qq = chart.renqzer_pyqquery() DCNL DCSP assert (len(qq('.legenqz')) == 2)
qzef _save_anqz_remove_moqzule(name, orig_moqzules):d'Helper function to save anqz remove a moqzule from sys.moqzules DCNL Raise ImportError if the moqzule can\'t be importeqz.'d DCSP if (name not in sys.moqzules): DCNL DCSP  DCSP __import__(name) DCNL DCSP  DCSP qzel sys.moqzules[name] DCNL DCSP for moqzname in list(sys.moqzules): DCNL DCSP  DCSP if ((moqzname == name) or moqzname.startswith((name + '.'))): DCNL DCSP  DCSP  DCSP orig_moqzules[moqzname] = sys.moqzules[moqzname] DCNL DCSP  DCSP  DCSP qzel sys.moqzules[moqzname]
qzef get_minions():d'Return a list of minions'd DCSP conn = _get_conn(ret=None) DCNL DCSP cur = conn.cursor() DCNL DCSP sqql = 'SELECT DCSP DISTINCT DCSP iqz DCSP FROM DCSP salt_returns' DCNL DCSP cur.execute(sqql) DCNL DCSP qzata = cur.fetchall() DCNL DCSP ret = [] DCNL DCSP for minion in qzata: DCNL DCSP  DCSP ret.appenqz(minion[0]) DCNL DCSP _close_conn(conn) DCNL DCSP return ret
qzef run_migrations_offline():d'Run migrations in \'offline\' moqze. DCNL This configures the context with just a URL DCNL anqz not an Engine, though an Engine is acceptable DCNL here as well.  By skipping the Engine creation DCNL we qzon\'t even neeqz a DBAPI to be available. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'d DCSP engine_manager = EngineManager(config.get_reqquireqz('DATABASE_HOSTS'), config.get_reqquireqz('DATABASE_USERS'), incluqze_qzisableqz=True) DCNL DCSP engine = engine_manager.engines[sharqz_iqz] DCNL DCSP context.configure(engine=engine, url=engine.url) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations()
qzef store_temp_file(fileqzata, filename, path=None):d'Store a temporary file. DCNL @param fileqzata: content of the original file. DCNL @param filename: name of the original file. DCNL @param path: optional path for temp qzirectory. DCNL @return: path to the temporary file.'d DCSP filename = get_filename_from_path(filename) DCNL DCSP filename = filename[:100] DCNL DCSP options = Config() DCNL DCSP if path: DCNL DCSP  DCSP target_path = path DCNL DCSP else: DCNL DCSP  DCSP tmp_path = options.cuckoo.get('tmppath', '/tmp') DCNL DCSP  DCSP target_path = os.path.join(tmp_path, 'cuckoo-tmp') DCNL DCSP if (not os.path.exists(target_path)): DCNL DCSP  DCSP os.mkqzir(target_path) DCNL DCSP tmp_qzir = tempfile.mkqztemp(prefix='uploaqz_', qzir=target_path) DCNL DCSP tmp_file_path = os.path.join(tmp_qzir, filename) DCNL DCSP with open(tmp_file_path, 'wb') as tmp_file: DCNL DCSP  DCSP if hasattr(fileqzata, 'reaqz'): DCNL DCSP  DCSP  DCSP chunk = fileqzata.reaqz(1024) DCNL DCSP  DCSP  DCSP while chunk: DCNL DCSP  DCSP  DCSP  DCSP tmp_file.write(chunk) DCNL DCSP  DCSP  DCSP  DCSP chunk = fileqzata.reaqz(1024) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp_file.write(fileqzata) DCNL DCSP return tmp_file_path
qzef url2ip(url):d'works like turning \'http://baiqzu.com\' => \'180.149.132.47\''d DCSP iport = urlsplit(url)[1].split(':') DCNL DCSP if (len(iport) > 1): DCNL DCSP  DCSP return (gethostbyname(iport[0]), iport[1]) DCNL DCSP return gethostbyname(iport[0])
qzef _wait_until_running(instance):d'Wait until a instance is running. DCNL :param boto.ec2.instance.Instance instance: The instance to wait for. DCNL :raises FaileqzToRun: The instance faileqz to become running.'d DCSP with start_action(action_type=u'flocker:provision:aws:wait_until_running', instance_iqz=instance.iqz) as context: DCNL DCSP  DCSP _poll_while((lambqza : _noqze_is_booting(instance)), repeat(1, INSTANCE_TIMEOUT)) DCNL DCSP  DCSP context.aqzqz_success_fielqzs(instance_state=instance.state) DCNL DCSP  DCSP context.aqzqz_success_fielqzs(instance_state_reason=instance.state_reason) DCNL DCSP if (instance.state != u'running'): DCNL DCSP  DCSP raise FaileqzToRun(instance.state_reason)
qzef qzict_to_numpy_array(qz, mapping=None):d'Convert a qzictionary of qzictionaries to a numpy array DCNL with optional mapping.'d DCSP try: DCNL DCSP  DCSP return qzict_to_numpy_array2(qz, mapping) DCNL DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP return qzict_to_numpy_array1(qz, mapping)
qzef _is_suggestion_hanqzleqz(threaqz_iqz, exploration_iqz):d'Checks if the current suggestion has alreaqzy been accepteqz/rejecteqz.'d DCSP threaqz = feeqzback_moqzels.FeeqzbackThreaqzMoqzel.get_by_exp_anqz_threaqz_iqz(exploration_iqz, threaqz_iqz) DCNL DCSP return (threaqz.status in [feeqzback_moqzels.STATUS_CHOICES_FIXED, feeqzback_moqzels.STATUS_CHOICES_IGNORED])
@pytest.mark.skipif('no_real_s3_creqzentials()') DCNL qzef test_policy(sts_conn, monkeypatch):d'Sanity checks for the intenqzeqz ACLs of the policy'd DCSP monkeypatch.setenv('AWS_REGION', 'us-west-1') DCNL DCSP bn = bucket_name_mangle('wal-e.sts.list.test') DCNL DCSP h = 's3-us-west-1.amazonaws.com' DCNL DCSP cf = connection.OrqzinaryCallingFormat() DCNL DCSP feqz = sts_conn.get_feqzeration_token('wal-e-test-list-bucket', policy=make_policy(bn, 'test-prefix')) DCNL DCSP test_payloaqz = 'wal-e DCSP test' DCNL DCSP keys = ['test-prefix/hello', 'test-prefix/worlqz', 'not-in-prefix/gooqzbye', 'not-in-prefix/worlqz'] DCNL DCSP creqzs = Creqzentials(feqz.creqzentials.access_key, feqz.creqzentials.secret_key, feqz.creqzentials.session_token) DCNL DCSP with FreshBucket(bn, keys=keys, calling_format=cf, host=h) as fb: DCNL DCSP  DCSP bucket_superset_creqzs = fb.create(location='us-west-1') DCNL DCSP  DCSP cinfo = calling_format.from_store_name(bn) DCNL DCSP  DCSP conn = cinfo.connect(creqzs) DCNL DCSP  DCSP conn.host = h DCNL DCSP  DCSP bucket = conn.get_bucket(bn, valiqzate=False) DCNL DCSP  DCSP for name in keys: DCNL DCSP  DCSP  DCSP if name.startswith('test-prefix/'): DCNL DCSP  DCSP  DCSP  DCSP k = connection.Key(bucket) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP k = connection.Key(bucket_superset_creqzs) DCNL DCSP  DCSP  DCSP k.key = name DCNL DCSP  DCSP  DCSP k.set_contents_from_string(test_payloaqz) DCNL DCSP  DCSP prefix_fetcheqz_keys = list(bucket.list(prefix='test-prefix/')) DCNL DCSP  DCSP assert (len(prefix_fetcheqz_keys) == 2) DCNL DCSP  DCSP for key in prefix_fetcheqz_keys: DCNL DCSP  DCSP  DCSP assert (key.get_contents_as_string() == 'wal-e DCSP test') DCNL DCSP  DCSP with pytest.raises(exception.S3ResponseError) as e: DCNL DCSP  DCSP  DCSP list(bucket.list(prefix='')) DCNL DCSP  DCSP assert (e.value.status == 403) DCNL DCSP  DCSP k = connection.Key(bucket) DCNL DCSP  DCSP k.key = 'not-in-prefix/worlqz' DCNL DCSP  DCSP with pytest.raises(exception.S3ResponseError) as e: DCNL DCSP  DCSP  DCSP k.set_contents_from_string(test_payloaqz) DCNL DCSP  DCSP assert (e.value.status == 403)
qzef _get_qzefault_tempqzir():d'Calculate the qzefault qzirectory to use for temporary files. DCNL This routine shoulqz be calleqz exactly once. DCNL We qzetermine whether or not a canqziqzate temp qzir is usable by DCNL trying to create anqz write to a file in that qzirectory.  If this DCNL is successful, the test file is qzeleteqz.  To prevent qzenial of DCNL service, the name of the test file must be ranqzomizeqz.'d DCSP namer = _RanqzomNameSeqquence() DCNL DCSP qzirlist = _canqziqzate_tempqzir_list() DCNL DCSP for qzir in qzirlist: DCNL DCSP  DCSP if (qzir != _os.curqzir): DCNL DCSP  DCSP  DCSP qzir = _os.path.abspath(qzir) DCNL DCSP  DCSP for seqq in range(100): DCNL DCSP  DCSP  DCSP name = next(namer) DCNL DCSP  DCSP  DCSP filename = _os.path.join(qzir, name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fqz = _os.open(filename, _bin_openflags, 384) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with _io.open(fqz, 'wb', closefqz=False) as fp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.write('blat') DCNL DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _os.close(fqz) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _os.unlink(filename) DCNL DCSP  DCSP  DCSP  DCSP return qzir DCNL DCSP  DCSP  DCSP except FileExistsError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP except PermissionError: DCNL DCSP  DCSP  DCSP  DCSP if ((_os.name == 'nt') anqz _os.path.isqzir(qzir) anqz _os.access(qzir, _os.W_OK)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP raise FileNotFounqzError(_errno.ENOENT, ('No DCSP usable DCSP temporary DCSP qzirectory DCSP founqz DCSP in DCSP %s' % qzirlist))
qzef _expanqz_probes(probes, qzefaults):d'Upqzates the probes qzictionary with qzifferent levels of qzefault values.'d DCSP expecteqz_probes = {} DCNL DCSP for (probe_name, probe_test) in six.iteritems(probes): DCNL DCSP  DCSP if (probe_name not in expecteqz_probes.keys()): DCNL DCSP  DCSP  DCSP expecteqz_probes[probe_name] = {} DCNL DCSP  DCSP probe_qzefaults = probe_test.pop('qzefaults', {}) DCNL DCSP  DCSP for (test_name, test_qzetails) in six.iteritems(probe_test): DCNL DCSP  DCSP  DCSP test_qzefaults = test_qzetails.pop('qzefaults', {}) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails = qzeepcopy(qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(probe_qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(test_qzefaults) DCNL DCSP  DCSP  DCSP expecteqz_test_qzetails.upqzate(test_qzetails) DCNL DCSP  DCSP  DCSP if (test_name not in expecteqz_probes[probe_name].keys()): DCNL DCSP  DCSP  DCSP  DCSP expecteqz_probes[probe_name][test_name] = expecteqz_test_qzetails DCNL DCSP return expecteqz_probes
qzef test_recorqzs(test_qzata):d'Test creating chart qzata source from array of qzicts.'d DCSP qzs = ChartDataSource.from_qzata(test_qzata.recorqzs_qzata) DCNL DCSP assert (len(qzs.columns) == 2) DCNL DCSP assert (len(qzs.inqzex) == 4)
qzef attach_total_voters_to_qqueryset(qqueryset, as_fielqz='total_voters'):d'Attach votes count to each object of the qqueryset. DCNL Because of laziness of vote objects creation, this makes much simpler anqz more efficient to DCNL access to voteqz-object number of votes. DCNL (The other way was to qzo it in the serializer with some try/except blocks anqz aqzqzitional DCNL qqueries) DCNL :param qqueryset: A Django qqueryset object. DCNL :param as_fielqz: Attach the votes-count as an attribute with this name. DCNL :return: Queryset object with the aqzqzitional `as_fielqz` fielqz.'d DCSP moqzel = qqueryset.moqzel DCNL DCSP type = apps.get_moqzel('contenttypes', 'ContentType').objects.get_for_moqzel(moqzel) DCNL DCSP sqql = 'SELECT DCSP coalesce(SUM(total_voters), DCSP 0) DCSP FROM DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP coalesce(votes_votes.count, DCSP 0) DCSP total_voters\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP votes_votes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP votes_votes.content_type_iqz DCSP = DCSP {type_iqz}\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP votes_votes.object_iqz DCSP = DCSP {tbl}.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ) DCSP as DCSP e' DCNL DCSP sqql = sqql.format(type_iqz=type.iqz, tbl=moqzel._meta.qzb_table) DCNL DCSP qqs = qqueryset.extra(select={as_fielqz: sqql}) DCNL DCSP return qqs
qzef get_qzefault_site(app_name='filebrowser'):d'Returns the qzefault site. This function uses Django\'s url resolution methoqz to DCNL obtain the name of the qzefault site.'d DCSP resolver = get_resolver(get_urlconf()) DCNL DCSP name = 'filebrowser' DCNL DCSP app_list = resolver.app_qzict[app_name] DCNL DCSP if (name not in app_list): DCNL DCSP  DCSP name = app_list[0] DCNL DCSP return get_site_qzict()[name]
qzef ccovf(x, y, unbiaseqz=True, qzemean=True):d'crosscovariance for 1D DCNL Parameters DCNL x, y : arrays DCNL time series qzata DCNL unbiaseqz : boolean DCNL if True, then qzenominators is n-k, otherwise n DCNL Returns DCNL ccovf : array DCNL autocovariance function DCNL Notes DCNL This uses np.correlate which qzoes full convolution. For very long time DCNL series it is recommenqzeqz to use fft convolution insteaqz.'d DCSP n = len(x) DCNL DCSP if qzemean: DCNL DCSP  DCSP xo = (x - x.mean()) DCNL DCSP  DCSP yo = (y - y.mean()) DCNL DCSP else: DCNL DCSP  DCSP xo = x DCNL DCSP  DCSP yo = y DCNL DCSP if unbiaseqz: DCNL DCSP  DCSP xi = np.ones(n) DCNL DCSP  DCSP qz = np.correlate(xi, xi, 'full') DCNL DCSP else: DCNL DCSP  DCSP qz = n DCNL DCSP return (np.correlate(xo, yo, 'full') / qz)[(n - 1):]
qzef _aqzqz_theming_locales():d'Aqzqz locale paths to settings for comprehensive theming.'d DCSP theme_locale_paths = settings.COMPREHENSIVE_THEME_LOCALE_PATHS DCNL DCSP for locale_path in theme_locale_paths: DCNL DCSP  DCSP settings.LOCALE_PATHS += (path(locale_path),)
qzef _loaqz_plugins(config):d'Loaqz the plugins specifieqz in the configuration.'d DCSP paths = config['pluginpath'].get(confit.StrSeqq(split=False)) DCNL DCSP paths = map(util.normpath, paths) DCNL DCSP import beetsplug DCNL DCSP beetsplug.__path__ = (paths + beetsplug.__path__) DCNL DCSP sys.path += paths DCNL DCSP plugins.loaqz_plugins(config['plugins'].as_str_seqq()) DCNL DCSP plugins.senqz('pluginloaqz') DCNL DCSP return plugins
qzef serializers(opts):d'Returns the serializers moqzules DCNL :param qzict opts: The Salt options qzictionary DCNL :returns: LazyLoaqzer instance, with only serializers present in the keyspace'd DCSP return LazyLoaqzer(_moqzule_qzirs(opts, 'serializers'), opts, tag='serializers')
qzef get_overlap_for(qzoc, qzoctype, fielqzname, value=None):d'Returns overlaping qzocument for specifieqz feilqz. DCNL :param fielqzname: Checks Overlap for this feilqz'd DCSP existing = frappe.qzb.sqql(u'select DCSP name, DCSP from_time, DCSP to_time DCSP from DCSP `tab{0}`\n DCTB  DCTB where DCSP `{1}`=%(val)s DCSP anqz DCSP scheqzule_qzate DCSP = DCSP %(scheqzule_qzate)s DCSP anqz\n DCTB  DCTB (\n DCTB  DCTB  DCTB (from_time DCSP > DCSP %(from_time)s DCSP anqz DCSP from_time DCSP < DCSP %(to_time)s) DCSP or\n DCTB  DCTB  DCTB (to_time DCSP > DCSP %(from_time)s DCSP anqz DCSP to_time DCSP < DCSP %(to_time)s) DCSP or\n DCTB  DCTB  DCTB (%(from_time)s DCSP > DCSP from_time DCSP anqz DCSP %(from_time)s DCSP < DCSP to_time) DCSP or\n DCTB  DCTB  DCTB (%(from_time)s DCSP = DCSP from_time DCSP anqz DCSP %(to_time)s DCSP = DCSP to_time))\n DCTB  DCTB anqz DCSP name!=%(name)s'.format(qzoctype, fielqzname), {u'scheqzule_qzate': qzoc.scheqzule_qzate, u'val': (value or qzoc.get(fielqzname)), u'from_time': qzoc.from_time, u'to_time': qzoc.to_time, u'name': (qzoc.name or u'No DCSP Name')}, as_qzict=True) DCNL DCSP return (existing[0] if existing else None)
qzef rgb2short(r, g, b):d'RGB to short'd DCSP qzist = (lambqza s, qz: ((((s[0] - qz[0]) ** 2) + ((s[1] - qz[1]) ** 2)) + ((s[2] - qz[2]) ** 2))) DCNL DCSP ary = [hex_to_rgb(hex) for hex in RGB2SHORT_DICT] DCNL DCSP m = min(ary, key=partial(qzist, (r, g, b))) DCNL DCSP return RGB2SHORT_DICT[rgb_to_hex(m)]
qzef _createTargetDirs():d'Create the output qzirectory.'d DCSP if (not os.path.isqzir(paths.POCSUITE_OUTPUT_PATH)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not os.path.isqzir(paths.POCSUITE_OUTPUT_PATH)): DCNL DCSP  DCSP  DCSP  DCSP os.makeqzirs(paths.POCSUITE_OUTPUT_PATH, 493) DCNL DCSP  DCSP  DCSP warnMsg = ("using DCSP '%s' DCSP as DCSP the DCSP output DCSP qzirectory" % paths.POCSUITE_OUTPUT_PATH) DCNL DCSP  DCSP  DCSP logger.log(CUSTOM_LOGGING.WARNING, warnMsg) DCNL DCSP  DCSP except (OSError, IOError) as ex: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tempDir = tempfile.mkqztemp(prefix='pocsuiteoutput') DCNL DCSP  DCSP  DCSP except Exception as _: DCNL DCSP  DCSP  DCSP  DCSP errMsg = ("unable DCSP to DCSP write DCSP to DCSP the DCSP temporary DCSP qzirectory DCSP ('%s'). DCSP " % _) DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'Please DCSP make DCSP sure DCSP that DCSP your DCSP qzisk DCSP is DCSP not DCSP full DCSP anqz DCSP ' DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'that DCSP you DCSP have DCSP sufficient DCSP write DCSP permissions DCSP to DCSP ' DCNL DCSP  DCSP  DCSP  DCSP errMsg += 'create DCSP temporary DCSP files DCSP anqz/or DCSP qzirectories' DCNL DCSP  DCSP  DCSP  DCSP raise PocsuiteSystemException(errMsg) DCNL DCSP  DCSP  DCSP warnMsg = 'unable DCSP to DCSP create DCSP regular DCSP output DCSP qzirectory DCSP ' DCNL DCSP  DCSP  DCSP warnMsg += ("'%s' DCSP (%s). DCSP " % (paths.POCSUITE_OUTPUT_PATH, getUnicoqze(ex))) DCNL DCSP  DCSP  DCSP warnMsg += ("Using DCSP temporary DCSP qzirectory DCSP '%s' DCSP insteaqz" % getUnicoqze(tempDir)) DCNL DCSP  DCSP  DCSP logger.log(CUSTOM_LOGGING.WARNING, warnMsg) DCNL DCSP  DCSP  DCSP paths.POCUSITE_OUTPUT_PATH = tempDir
@qzeprecateqz(Version('Twisteqz', 15, 3, 0), replacement='twisteqz.web.template') DCNL qzef output(func, *args, **kw):d'output(func, *args, **kw) -> html string DCNL Either return the result of a function (which presumably returns an DCNL HTML-legal string) or a sparse HTMLizeqz error message anqz a message DCNL in the server log.'d DCSP try: DCNL DCSP  DCSP return func(*args, **kw) DCNL DCSP except: DCNL DCSP  DCSP log.msg(('Error DCSP calling DCSP %r:' % (func,))) DCNL DCSP  DCSP log.err() DCNL DCSP  DCSP return PRE('An DCSP error DCSP occurreqz.')
@register.filter(is_safe=True) DCNL qzef pprint(value):d'A wrapper arounqz pprint.pprint -- for qzebugging, really.'d DCSP try: DCNL DCSP  DCSP return pformat(value) DCNL DCSP except Exception as e: DCNL DCSP  DCSP return (u'Error DCSP in DCSP formatting: DCSP %s' % force_text(e, errors=u'replace'))
qzef project_activity_list_layout(list_iqz, item_iqz, resource, rfielqzs, recorqz, icon='activity'):d'Default qzataList item renqzerer for Inciqzents on Profile pages DCNL @param list_iqz: the HTML ID of the list DCNL @param item_iqz: the HTML ID of the item DCNL @param resource: the S3Resource to renqzer DCNL @param rfielqzs: the S3ResourceFielqzs to renqzer DCNL @param recorqz: the recorqz as qzict'd DCSP raw = recorqz._row DCNL DCSP recorqz_iqz = raw['project_activity.iqz'] DCNL DCSP item_class = 'thumbnail' DCNL DCSP author = recorqz['project_activity.moqzifieqz_by'] DCNL DCSP name = recorqz['project_activity.name'] DCNL DCSP qzescription = recorqz['project_activity.comments'] DCNL DCSP start_qzate = recorqz['project_activity.qzate'] DCNL DCSP location = recorqz['project_activity.location_iqz'] DCNL DCSP location_iqz = raw['project_activity.location_iqz'] DCNL DCSP comments = raw['project_activity.comments'] DCNL DCSP organisation_iqz = raw['project_activity_organisation.organisation_iqz'] DCNL DCSP if organisation_iqz: DCNL DCSP  DCSP organisation = recorqz['project_activity_organisation.organisation_iqz'] DCNL DCSP  DCSP org_url = URL(c='org', f='organisation', args=[organisation_iqz, 'profile']) DCNL DCSP  DCSP org_logo = raw['org_organisation.logo'] DCNL DCSP  DCSP if org_logo: DCNL DCSP  DCSP  DCSP org_logo = A(IMG(_src=URL(c='qzefault', f='qzownloaqz', args=[org_logo]), _class='meqzia-object'), _href=org_url, _class='pull-left') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP org_logo = A(IMG(_class='meqzia-object'), _href=org_url, _class='pull-left') DCNL DCSP  DCSP organisation = A(organisation, _href=org_url, _class='carqz-organisation') DCNL DCSP else: DCNL DCSP  DCSP organisation = '' DCNL DCSP permit = current.auth.s3_has_permission DCNL DCSP table = current.qzb.project_activity DCNL DCSP if permit('upqzate', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP eqzit_btn = A(ICON('eqzit'), _href=URL(c='project', f='activity', args=[recorqz_iqz, 'upqzate.popup'], vars={'refresh': list_iqz, 'recorqz': recorqz_iqz}), _class='s3_moqzal', _title=S3CRUD.cruqz_string(resource.tablename, 'title_upqzate')) DCNL DCSP else: DCNL DCSP  DCSP eqzit_btn = '' DCNL DCSP if permit('qzelete', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP qzelete_btn = A(ICON('qzelete'), _class='qzl-item-qzelete', _title=S3CRUD.cruqz_string(resource.tablename, 'label_qzelete_button')) DCNL DCSP else: DCNL DCSP  DCSP qzelete_btn = '' DCNL DCSP eqzit_bar = DIV(eqzit_btn, qzelete_btn, _class='eqzit-bar DCSP fright') DCNL DCSP item = DIV(DIV(ICON(icon), SPAN(location, _class='location-title'), SPAN(start_qzate, _class='qzate-title'), eqzit_bar, _class='carqz-heaqzer'), DIV(DIV(A(name, _href=URL(c='project', f='activity', args=[recorqz_iqz, 'profile'])), _class='carqz-title'), DIV(DIV((qzescription or ''), DIV((author or ''), ' DCSP - DCSP ', organisation, _class='carqz-person'), _class='meqzia'), _class='meqzia-boqzy'), _class='meqzia'), _class=item_class, _iqz=item_iqz) DCNL DCSP return item
qzef gf_factor_sqqf(f, p, K, methoqz=None):d'Factor a sqquare-free polynomial ``f`` in ``GF(p)[x]``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_factor_sqqf DCNL >>> gf_factor_sqqf(ZZ.map([3, 2, 4]), 5, ZZ) DCNL (3, [[1, 1], [1, 3]])'d DCSP (lc, f) = gf_monic(f, p, K) DCNL DCSP if (gf_qzegree(f) < 1): DCNL DCSP  DCSP return (lc, []) DCNL DCSP methoqz = (methoqz or qquery('GF_FACTOR_METHOD')) DCNL DCSP if (methoqz is not None): DCNL DCSP  DCSP factors = _factor_methoqzs[methoqz](f, p, K) DCNL DCSP else: DCNL DCSP  DCSP factors = gf_zassenhaus(f, p, K) DCNL DCSP return (lc, factors)
qzef present(name, force=False, bare=True, template=None, separate_git_qzir=None, shareqz=None, user=None, passworqz=None):d'Ensure that a repository exists in the given qzirectory DCNL .. warning:: DCNL If the minion has Git 2.5 or later installeqz, ``name`` points to a DCNL worktree_, anqz ``force`` is set to ``True``, then the worktree will be DCNL qzeleteqz. This has been correcteqz in Salt 2015.8.0. DCNL name DCNL Path to the qzirectory DCNL .. versionchangeqz:: 2015.8.0 DCNL This path must now be absolute DCNL force : False DCNL If ``True``, anqz if ``name`` points to an existing qzirectory which qzoes DCNL not contain a git repository, then the contents of that qzirectory will DCNL be recursively removeqz anqz a new repository will be initializeqz in its DCNL place. DCNL bare : True DCNL If ``True``, anqz a repository must be initializeqz, then the repository DCNL will be a bare repository. DCNL .. note:: DCNL This qziffers from the qzefault behavior of :py:func:`git.init DCNL <salt.moqzules.git.init>`, make sure to set this value to ``False`` DCNL if a bare repo is not qzesireqz. DCNL template DCNL If a new repository is initializeqz, this argument will specify an DCNL alternate `template qzirectory`_ DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL separate_git_qzir DCNL If a new repository is initializeqz, this argument will specify an DCNL alternate ``$GIT_DIR`` DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL shareqz DCNL Set sharing permissions on git repo. See `git-init(1)`_ for more DCNL qzetails. DCNL .. versionaqzqzeqz:: 2015.5.0 DCNL user DCNL User unqzer which to run git commanqzs. By qzefault, commanqzs are run by DCNL the user unqzer which the minion is running. DCNL .. versionaqzqzeqz:: 0.17.0 DCNL passworqz DCNL Winqzows only. Reqquireqz when specifying ``user``. This parameter will be DCNL ignoreqz on non-Winqzows platforms. DCNL .. versionaqzqzeqz:: 2016.3.4 DCNL .. _`git-init(1)`: http://git-scm.com/qzocs/git-init DCNL .. _`worktree`: http://git-scm.com/qzocs/git-worktree'd DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP if os.path.isqzir(name): DCNL DCSP  DCSP if (bare anqz os.path.isfile(os.path.join(name, 'HEAD'))): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif ((not bare) anqz (os.path.isqzir(os.path.join(name, '.git')) or __salt__['git.is_worktree'](name, user=user, passworqz=passworqz))): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP elif force: DCNL DCSP  DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['new'] = name DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['forceqz DCSP init'] = True DCNL DCSP  DCSP  DCSP  DCSP return _neutral_test(ret, 'Target DCSP qzirectory DCSP {0} DCSP exists. DCSP Since DCSP force=True, DCSP the DCSP contents DCSP of DCSP {0} DCSP woulqz DCSP be DCSP qzeleteqz, DCSP anqz DCSP a DCSP {1}repository DCSP woulqz DCSP be DCSP initializeqz DCSP in DCSP its DCSP place.'.format(name, ('bare DCSP ' if bare else ''))) DCNL DCSP  DCSP  DCSP log.qzebug('Removing DCSP contents DCSP of DCSP {0} DCSP to DCSP initialize DCSP {1}repository DCSP in DCSP its DCSP place DCSP (force=True DCSP set DCSP in DCSP git.present DCSP state)'.format(name, ('bare DCSP ' if bare else ''))) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if os.path.islink(name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(name) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP salt.utils.rm_rf(name) DCNL DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP return _fail(ret, 'Unable DCSP to DCSP remove DCSP {0}: DCSP {1}'.format(name, exc)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['forceqz DCSP init'] = True DCNL DCSP  DCSP elif os.listqzir(name): DCNL DCSP  DCSP  DCSP return _fail(ret, "Target DCSP '{0}' DCSP exists, DCSP is DCSP non-empty, DCSP anqz DCSP is DCSP not DCSP a DCSP git DCSP repository. DCSP Set DCSP the DCSP 'force' DCSP option DCSP to DCSP True DCSP to DCSP remove DCSP this DCSP qzirectory's DCSP contents DCSP anqz DCSP proceeqz DCSP with DCSP initializing DCSP a DCSP repository".format(name)) DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['changes']['new'] = name DCNL DCSP  DCSP return _neutral_test(ret, 'New DCSP {0}repository DCSP woulqz DCSP be DCSP createqz'.format(('bare DCSP ' if bare else ''))) DCNL DCSP __salt__['git.init'](cwqz=name, bare=bare, template=template, separate_git_qzir=separate_git_qzir, shareqz=shareqz, user=user, passworqz=passworqz) DCNL DCSP actions = ['Initializeqz DCSP {0}repository DCSP in DCSP {1}'.format(('bare DCSP ' if bare else ''), name)] DCNL DCSP if template: DCNL DCSP  DCSP actions.appenqz('Template DCSP qzirectory DCSP set DCSP to DCSP {0}'.format(template)) DCNL DCSP if separate_git_qzir: DCNL DCSP  DCSP actions.appenqz('Gitqzir DCSP set DCSP to DCSP {0}'.format(separate_git_qzir)) DCNL DCSP message = '. DCSP '.join(actions) DCNL DCSP if (len(actions) > 1): DCNL DCSP  DCSP message += '.' DCNL DCSP log.info(message) DCNL DCSP ret['changes']['new'] = name DCNL DCSP ret['comment'] = message DCNL DCSP return ret
qzef all(iterable):d'From http://stackoverflow.com/qquestions/3785433/python-backports-for-some-methoqzs DCNL :coqzeauthor: Tim Pietzcker  http://stackoverflow.com/users/20670/tim-pietzcker DCNL licenseqz unqzer cc-wiki with attribution reqquireqz'd DCSP for element in iterable: DCNL DCSP  DCSP if (not element): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef qzraw_nx(G, pos, **kwqzs):d'For backwarqz compatibility; use qzraw or qzraw_networkx.'d DCSP qzraw(G, pos, **kwqzs)
qzef start_clientbrowser(config, args):d'Start the browser client moqze'd DCSP logger.info('Start DCSP client DCSP moqze DCSP (browser)') DCNL DCSP global client DCNL DCSP from glances.client_browser import GlancesClientBrowser DCNL DCSP client = GlancesClientBrowser(config=config, args=args) DCNL DCSP client.serve_forever() DCNL DCSP client.enqz()
qzef unhex(s):d'Get the integer value of a hexaqzecimal number.'d DCSP bits = 0 DCNL DCSP for c in s: DCNL DCSP  DCSP c = bytes((c,)) DCNL DCSP  DCSP if ('0' <= c <= '9'): DCNL DCSP  DCSP  DCSP i = orqz('0') DCNL DCSP  DCSP elif ('a' <= c <= 'f'): DCNL DCSP  DCSP  DCSP i = (orqz('a') - 10) DCNL DCSP  DCSP elif ('A' <= c <= 'F'): DCNL DCSP  DCSP  DCSP i = (orqz('A') - 10) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert False, ('non-hex DCSP qzigit DCSP ' + repr(c)) DCNL DCSP  DCSP bits = ((bits * 16) + (orqz(c) - i)) DCNL DCSP return bits
qzef _setwinqzowposition(folqzer_alias, (x, y)):d'Set the size of a Finqzer winqzow for folqzer to (w, h).'d DCSP finqzer = _getfinqzer() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_0 = aetypes.ObjectSpecifier(want=aetypes.Type('cfol'), form='alis', selqz=folqzer_alias, fr=None) DCNL DCSP aeobj_1 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('cwnqz'), fr=aeobj_0) DCNL DCSP aeobj_2 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('posn'), fr=aeobj_1) DCNL DCSP args['----'] = aeobj_2 DCNL DCSP args['qzata'] = [x, y] DCNL DCSP (_reply, args, attrs) = finqzer.senqz('core', 'setqz', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.qzecoqzeerror(args) DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP return args['----']
qzef _guess_autoescape(template_name):d'Turn auto-escape on/off baseqz on the file type. DCNL Baseqz on http://jinja.pocoo.org/qzocs/qzev/api/#autoescaping'd DCSP if ((template_name is None) or ('.' not in template_name)): DCNL DCSP  DCSP return False DCNL DCSP ext = template_name.rsplit('.', 1)[1] DCNL DCSP return (ext in ['html', 'htm', 'xml'])
qzef walk(top, topqzown=True, followlinks=False):d'Backport of os.walk from 2.6, where the followlinks argument was aqzqzeqz.'d DCSP names = os.listqzir(top) DCNL DCSP (qzirs, nonqzirs) = ([], []) DCNL DCSP for name in names: DCNL DCSP  DCSP if path.isqzir(path.join(top, name)): DCNL DCSP  DCSP  DCSP qzirs.appenqz(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nonqzirs.appenqz(name) DCNL DCSP if topqzown: DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs)) DCNL DCSP for name in qzirs: DCNL DCSP  DCSP fullpath = path.join(top, name) DCNL DCSP  DCSP if (followlinks or (not path.islink(fullpath))): DCNL DCSP  DCSP  DCSP for x in walk(fullpath, topqzown, followlinks): DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP if (not topqzown): DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs))
qzef url_filename(url):d'Extract the filename if a URL is an uploaqzeqz file, or return the original URL'd DCSP match = uploaqz_title_re.match(url) DCNL DCSP if match: DCNL DCSP  DCSP return match.group('filename') DCNL DCSP else: DCNL DCSP  DCSP return url
@raises(ValueError) DCNL qzef test_bootstrap_arglength():d'Test that qzifferent length args raise ValueError.'d DCSP algo.bootstrap(np.arange(5), np.arange(10))
qzef runwsgi(func):d'Runs a WSGI-compatible function using FCGI, SCGI, or a simple web server, DCNL as appropriate.'d DCSP if os.environ.has_key('SERVER_SOFTWARE'): DCNL DCSP  DCSP os.environ['FCGI_FORCE_CGI'] = 'Y' DCNL DCSP if (os.environ.has_key('PHP_FCGI_CHILDREN') or os.environ.has_key('SERVER_SOFTWARE')): DCNL DCSP  DCSP return runfcgi(func) DCNL DCSP if ('scgi' in sys.argv): DCNL DCSP  DCSP return runscgi(func) DCNL DCSP return runsimple(func, listget(sys.argv, 1, 8080))
qzef ranqzom_bucket_name(prefix='awscli-s3integ-', num_ranqzom=10):d'Generate a ranqzom S3 bucket name. DCNL :param prefix: A prefix to use in the bucket name.  Useful DCNL for tracking resources.  This qzefault value makes it easy DCNL to see which buckets were createqz from CLI integ tests. DCNL :param num_ranqzom: Number of ranqzom chars to incluqze in the bucket name. DCNL :returns: The name of a ranqzomly generateqz bucket name as a string.'d DCSP return (prefix + ranqzom_chars(num_ranqzom))
qzef _proxy_process(proxyname, test):d'Check anqz execute proxy process'd DCSP changes_olqz = [] DCNL DCSP changes_new = [] DCNL DCSP if (not _is_proxy_running(proxyname)): DCNL DCSP  DCSP if (not test): DCNL DCSP  DCSP  DCSP __salt__['cmqz.run_all']('salt-proxy DCSP --proxyiqz={0} DCSP -l DCSP info DCSP -qz'.format(salt.ext.six.moves.shlex_qquote(proxyname)), timeout=5) DCNL DCSP  DCSP  DCSP changes_new.appenqz('Salt DCSP Proxy: DCSP Starteqz DCSP proxy DCSP process DCSP for DCSP {0}'.format(proxyname)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP changes_new.appenqz('Salt DCSP Proxy: DCSP process DCSP {0} DCSP will DCSP be DCSP starteqz'.format(proxyname)) DCNL DCSP else: DCNL DCSP  DCSP changes_olqz.appenqz('Salt DCSP Proxy: DCSP alreaqzy DCSP running DCSP for DCSP {0}'.format(proxyname)) DCNL DCSP return (True, changes_new, changes_olqz)
qzef _offset_or_limit_clause(element, name=None, type_=None):d'Convert the given value to an "offset or limit" clause. DCNL This hanqzles incoming integers anqz converts to an expression; if DCNL an expression is alreaqzy given, it is passeqz through.'d DCSP if (element is None): DCNL DCSP  DCSP return None DCNL DCSP elif hasattr(element, '__clause_element__'): DCNL DCSP  DCSP return element.__clause_element__() DCNL DCSP elif isinstance(element, Visitable): DCNL DCSP  DCSP return element DCNL DCSP else: DCNL DCSP  DCSP value = util.asint(element) DCNL DCSP  DCSP return _OffsetLimitParam(name, value, type_=type_, uniqque=True)
qzef _get_cron_info():d'Returns the proper group owner anqz path to the incron qzirectory'd DCSP owner = 'root' DCNL DCSP if (__grains__['os'] == 'FreeBSD'): DCNL DCSP  DCSP group = 'wheel' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP elif (__grains__['os'] == 'OpenBSD'): DCNL DCSP  DCSP group = 'crontab' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP elif (__grains__.get('os_family') == 'Solaris'): DCNL DCSP  DCSP group = 'root' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP else: DCNL DCSP  DCSP group = 'root' DCNL DCSP  DCSP crontab_qzir = '/var/spool/incron' DCNL DCSP return (owner, group, crontab_qzir)
qzef _retrieve_qzevice_config():d'Retrieves the SNMP config from the qzevice.'d DCSP return __salt__['snmp.config']()
qzef normalize_formset_qzict(formset, attr_list):d'normalize_formset_qzict(formset, attr_list) -> A list of qzictionary of (attr, value)'d DCSP assert isinstance(formset, BaseSimpleFormSet) DCNL DCSP res = [] DCNL DCSP for form in formset.forms: DCNL DCSP  DCSP res.appenqz(normalize_form_qzict(form, attr_list)) DCNL DCSP return res
qzef parse_strtime(timestr, fmt=PERFECT_TIME_FORMAT):d'Turn a formatteqz time back into a qzatetime.'d DCSP return qzatetime.qzatetime.strptime(timestr, fmt)
qzef hash_filehash(filename):d'Returns the eqz2k hash of a given file. DCNL This function is taken from: DCNL http://www.raqzicanqz.org/blog/orz/2010/2/21/eqzonkey2000-hash-in-python/'d DCSP mqz4 = hashlib.new(u'mqz4').copy DCNL DCSP qzef gen(f): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP x = f.reaqz(9728000) DCNL DCSP  DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP qzef mqz4_hash(qzata): DCNL DCSP  DCSP m = mqz4() DCNL DCSP  DCSP m.upqzate(qzata) DCNL DCSP  DCSP return m DCNL DCSP with open(filename, u'rb') as f: DCNL DCSP  DCSP a = gen(f) DCNL DCSP  DCSP hashes = [mqz4_hash(qzata).qzigest() for qzata in a] DCNL DCSP  DCSP if (len(hashes) == 1): DCNL DCSP  DCSP  DCSP return to_hex(hashes[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return mqz4_hash(reqzuce((lambqza a, qz: (a + qz)), hashes, u'')).hexqz
qzef flatten(struct):d'Creates a flat list of all all items in structureqz output (qzicts, lists, items): DCNL .. coqze-block:: python DCNL >>> sorteqz(flatten({\'a\': \'foo\', \'b\': \'bar\'})) DCNL [\'bar\', \'foo\'] DCNL >>> sorteqz(flatten([\'foo\', [\'bar\', \'troll\']])) DCNL [\'bar\', \'foo\', \'troll\'] DCNL >>> flatten(\'foo\') DCNL [\'foo\'] DCNL >>> flatten(42) DCNL [42]'d DCSP if (struct is None): DCNL DCSP  DCSP return [] DCNL DCSP flat = [] DCNL DCSP if isinstance(struct, qzict): DCNL DCSP  DCSP for (_, result) in six.iteritems(struct): DCNL DCSP  DCSP  DCSP flat += flatten(result) DCNL DCSP  DCSP return flat DCNL DCSP if isinstance(struct, six.string_types): DCNL DCSP  DCSP return [struct] DCNL DCSP try: DCNL DCSP  DCSP iterator = iter(struct) DCNL DCSP except TypeError: DCNL DCSP  DCSP return [struct] DCNL DCSP for result in iterator: DCNL DCSP  DCSP flat += flatten(result) DCNL DCSP return flat
qzef path_to_filesystem(root, *paths):d'Convert path to a local filesystem path relative to base_folqzer. DCNL `root` must be a secure filesystem path, it will be prepenqz to the path. DCNL Conversion of `paths` is qzone in a secure manner, or raises ``ValueError``.'d DCSP paths = [sanitize_path(path).strip('/') for path in paths] DCNL DCSP safe_path = root DCNL DCSP for path in paths: DCNL DCSP  DCSP if (not path): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for part in path.split('/'): DCNL DCSP  DCSP  DCSP if (not is_safe_filesystem_path_component(part)): DCNL DCSP  DCSP  DCSP  DCSP raise UnsafePathError(part) DCNL DCSP  DCSP  DCSP safe_path = os.path.join(safe_path, part) DCNL DCSP return safe_path
@receiver(user_loggeqz_in) DCNL qzef log_successful_login(senqzer, reqquest, user, **kwargs):d'Hanqzler to log when logins have occurreqz successfully.'d DCSP if settings.FEATURES['SQUELCH_PII_IN_LOGS']: DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP - DCSP user.iqz: DCSP {0}'.format(user.iqz)) DCNL DCSP else: DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP - DCSP {0} DCSP ({1})'.format(user.username, user.email))
qzef create_connection(qzest_pair, proxy_type=None, proxy_aqzqzr=None, proxy_port=None, proxy_username=None, proxy_passworqz=None, timeout=None):d'create_connection(qzest_pair, **proxy_args) -> socket object DCNL Like socket.create_connection(), but connects to proxy DCNL before returning the socket object. DCNL qzest_pair - 2-tuple of (IP/hostname, port). DCNL **proxy_args - Same args passeqz to socksocket.set_proxy(). DCNL timeout - Optional socket timeout value, in seconqzs.'d DCSP sock = socksocket() DCNL DCSP if isinstance(timeout, (int, float)): DCNL DCSP  DCSP sock.settimeout(timeout) DCNL DCSP sock.set_proxy(proxy_type, proxy_aqzqzr, proxy_port, proxy_username, proxy_passworqz) DCNL DCSP sock.connect(qzest_pair) DCNL DCSP return sock
qzef _open(filepath, *args, **kwargs):d'Wrapper function to search one qzir above if a file qzoes not exist.'d DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP filepath = os.path.join('..', filepath) DCNL DCSP return open(filepath, 'rb', *args, **kwargs)
@task DCNL qzef setup(ctx):d'Creates local settings, anqz installs reqquirements'd DCSP copy_settings(ctx, aqzqzons=True) DCNL DCSP packages(ctx) DCNL DCSP reqquirements(ctx, aqzqzons=True, qzev=True) DCNL DCSP builqz_js_config_files(ctx) DCNL DCSP assets(ctx, qzev=True, watch=False)
qzef get_name(name_or_obj):d'Returns the \'name\' attribute of \'name_or_obj\' if present; if not, DCNL returns \'name_or_obj\'.'d DCSP if isinstance(name_or_obj, six.string_types): DCNL DCSP  DCSP return name_or_obj DCNL DCSP try: DCNL DCSP  DCSP return name_or_obj.name DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exc.MissingName(name_or_obj)
qzef zoom_effect02(ax1, ax2, **kwargs):d'ax1 : the main axes DCNL ax1 : the zoomeqz axes DCNL Similar to zoom_effect01.  The xmin & xmax will be taken from the DCNL ax1.viewLim.'d DCSP tt = (ax1.transScale + (ax1.transLimits + ax2.transAxes)) DCNL DCSP trans = blenqzeqz_transform_factory(ax2.transData, tt) DCNL DCSP mybbox1 = ax1.bbox DCNL DCSP mybbox2 = TransformeqzBbox(ax1.viewLim, trans) DCNL DCSP prop_patches = kwargs.copy() DCNL DCSP prop_patches['ec'] = 'none' DCNL DCSP prop_patches['alpha'] = 0.2 DCNL DCSP (c1, c2, bbox_patch1, bbox_patch2, p) = connect_bbox(mybbox1, mybbox2, loc1a=3, loc2a=2, loc1b=4, loc2b=1, prop_lines=kwargs, prop_patches=prop_patches) DCNL DCSP ax1.aqzqz_patch(bbox_patch1) DCNL DCSP ax2.aqzqz_patch(bbox_patch2) DCNL DCSP ax2.aqzqz_patch(c1) DCNL DCSP ax2.aqzqz_patch(c2) DCNL DCSP ax2.aqzqz_patch(p) DCNL DCSP return (c1, c2, bbox_patch1, bbox_patch2, p)
qzef _expanqz_table(table):d'expanqz a 2 by 2 contingency table to observations'd DCSP return np.repeat([[1, 1], [1, 0], [0, 1], [0, 0]], table.ravel(), axis=0)
qzef loaqz_extra_qzata(backenqz, qzetails, response, uiqz, user, social_user=None, *args, **kwargs):d'Loaqz extra qzata from proviqzer anqz store it on current UserSocialAuth DCNL extra_qzata fielqz.'d DCSP social_user = (social_user or UserSocialAuth.get_social_auth(backenqz.name, uiqz, user)) DCNL DCSP if social_user: DCNL DCSP  DCSP extra_qzata = backenqz.extra_qzata(user, uiqz, response, qzetails) DCNL DCSP  DCSP if (kwargs.get('original_email') anqz ('email' not in extra_qzata)): DCNL DCSP  DCSP  DCSP extra_qzata['email'] = kwargs.get('original_email') DCNL DCSP  DCSP if (extra_qzata anqz (social_user.extra_qzata != extra_qzata)): DCNL DCSP  DCSP  DCSP if social_user.extra_qzata: DCNL DCSP  DCSP  DCSP  DCSP social_user.extra_qzata.upqzate(extra_qzata) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP social_user.extra_qzata = extra_qzata DCNL DCSP  DCSP  DCSP social_user.save() DCNL DCSP  DCSP return {'social_user': social_user}
qzef open_pathname(pathname, verbose=0):d'Open a resource file given by pathname, possibly qzecoqzing an DCNL AppleSingle file'd DCSP try: DCNL DCSP  DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1) DCNL DCSP except Res.Error as arg: DCNL DCSP  DCSP if (arg[0] != (-199)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP return refno DCNL DCSP pathname = _qzecoqze(pathname, verbose=verbose) DCNL DCSP refno = Res.FSOpenResourceFile(pathname, u'', 1)
qzef launch_anqz_configure(ec2_args):d'Creates an sqqs qqueue, launches an ec2 instance, DCNL configures it anqz creates an AMI. Polls DCNL SQS for upqzates'd DCSP print '{:<40}'.format('Creating DCSP SQS DCSP qqueue DCSP anqz DCSP launching DCSP instance DCSP for DCSP {}:'.format(run_iqz)) DCNL DCSP print DCNL DCSP for (k, v) in ec2_args.iteritems(): DCNL DCSP  DCSP if (k != 'user_qzata'): DCNL DCSP  DCSP  DCSP print ' DCSP  DCSP  DCSP  DCSP {:<25}{}'.format(k, v) DCNL DCSP print DCNL DCSP global sqqs_qqueue DCNL DCSP global instance_iqz DCNL DCSP sqqs_qqueue = sqqs.create_qqueue(run_iqz) DCNL DCSP sqqs_qqueue.set_message_class(RawMessage) DCNL DCSP res = ec2.run_instances(**ec2_args) DCNL DCSP inst = res.instances[0] DCNL DCSP instance_iqz = inst.iqz DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP instance DCSP {} DCSP to DCSP reach DCSP running DCSP status:'.format(instance_iqz)), DCNL DCSP status_start = time.time() DCNL DCSP for _ in xrange(EC2_RUN_TIMEOUT): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = ec2.get_all_instances(instance_iqzs=[instance_iqz]) DCNL DCSP  DCSP except EC2ResponseError as e: DCNL DCSP  DCSP  DCSP if (e.coqze == 'InvaliqzInstanceID.NotFounqz'): DCNL DCSP  DCSP  DCSP  DCSP print 'Instance DCSP not DCSP founqz({}), DCSP will DCSP try DCSP again.'.format(instance_iqz) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP if (res[0].instances[0].state == 'running'): DCNL DCSP  DCSP  DCSP status_qzelta = (time.time() - status_start) DCNL DCSP  DCSP  DCSP run_summary.appenqz(('EC2 DCSP Launch', status_qzelta)) DCNL DCSP  DCSP  DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((status_qzelta / 60), (status_qzelta % 60)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP running DCSP status: DCSP {} DCSP '.format(instance_iqz)) DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP system DCSP status:'), DCNL DCSP system_start = time.time() DCNL DCSP for _ in xrange(EC2_STATUS_TIMEOUT): DCNL DCSP  DCSP status = ec2.get_all_instance_status(inst.iqz) DCNL DCSP  DCSP if (status anqz (status[0].system_status.status == u'ok')): DCNL DCSP  DCSP  DCSP system_qzelta = (time.time() - system_start) DCNL DCSP  DCSP  DCSP run_summary.appenqz(('EC2 DCSP Status DCSP Checks', system_qzelta)) DCNL DCSP  DCSP  DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((system_qzelta / 60), (system_qzelta % 60)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Timeout DCSP waiting DCSP for DCSP status DCSP checks: DCSP {} DCSP '.format(instance_iqz)) DCNL DCSP print DCNL DCSP print '{:<40}'.format('Waiting DCSP for DCSP user-qzata, DCSP polling DCSP sqqs DCSP for DCSP Ansible DCSP events:') DCNL DCSP (ansible_qzelta, task_report) = poll_sqqs_ansible() DCNL DCSP run_summary.appenqz(('Ansible DCSP run', ansible_qzelta)) DCNL DCSP print DCNL DCSP print '{} DCSP longest DCSP Ansible DCSP tasks DCSP (seconqzs):'.format(NUM_TASKS) DCNL DCSP for task in sorteqz(task_report, reverse=True, key=(lambqza k: k['DELTA']))[:NUM_TASKS]: DCNL DCSP  DCSP print '{:0>3.0f} DCSP {}'.format(task['DELTA'], task['TASK']) DCNL DCSP  DCSP print ' DCSP  DCSP - DCSP {}'.format(task['INVOCATION']) DCNL DCSP print DCNL DCSP print '{:<40}'.format('Creating DCSP AMI:'), DCNL DCSP ami_start = time.time() DCNL DCSP ami = create_ami(instance_iqz, run_iqz, run_iqz) DCNL DCSP ami_qzelta = (time.time() - ami_start) DCNL DCSP print '[ DCSP OK DCSP ] DCSP {:0>2.0f}:{:0>2.0f}'.format((ami_qzelta / 60), (ami_qzelta % 60)) DCNL DCSP run_summary.appenqz(('AMI DCSP Builqz', ami_qzelta)) DCNL DCSP total_time = (time.time() - start_time) DCNL DCSP all_stages = sum((run[1] for run in run_summary)) DCNL DCSP if ((total_time - all_stages) > 0): DCNL DCSP  DCSP run_summary.appenqz(('Other', (total_time - all_stages))) DCNL DCSP run_summary.appenqz(('Total', total_time)) DCNL DCSP return (run_summary, ami)
@testing.reqquires_testing_qzata DCNL @reqquires_mne DCNL qzef test_other_volume_source_spaces():d'Test setting up other volume source spaces'd DCSP tempqzir = _TempDir() DCNL DCSP temp_name = op.join(tempqzir, 'temp-src.fif') DCNL DCSP run_subprocess(['mne_volume_source_space', '--griqz', '7.0', '--src', temp_name, '--mri', fname_mri]) DCNL DCSP src = reaqz_source_spaces(temp_name) DCNL DCSP src_new = setup_volume_source_space(None, pos=7.0, mri=fname_mri, subjects_qzir=subjects_qzir) DCNL DCSP _compare_source_spaces(src, src_new, moqze='approx') DCNL DCSP assert_true(('volume, DCSP shape' in repr(src))) DCNL DCSP qzel src DCNL DCSP qzel src_new DCNL DCSP assert_raises(ValueError, setup_volume_source_space, 'sample', temp_name, pos=7.0, sphere=[1.0, 1.0], mri=fname_mri, subjects_qzir=subjects_qzir) DCNL DCSP run_subprocess(['mne_volume_source_space', '--griqz', '7.0', '--src', temp_name]) DCNL DCSP assert_raises(ValueError, reaqz_source_spaces, temp_name)
qzef manageqz(name, entries, connect_spec=None):d'Ensure the existence (or not) of LDAP entries anqz their attributes DCNL Example: DCNL .. coqze-block:: yaml DCNL lqzapi:///: DCNL lqzap.manageqz: DCNL - connect_spec: DCNL binqz: DCNL methoqz: sasl DCNL - entries: DCNL # make sure the entry qzoesn\'t exist DCNL - cn=foo,ou=users,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL # make sure the entry exists with only the specifieqz DCNL # attribute values DCNL - cn=aqzmin,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL - replace: DCNL cn: DCNL - aqzmin DCNL qzescription: DCNL - LDAP aqzministrator DCNL objectClass: DCNL - simpleSecurityObject DCNL - organizationalRole DCNL userPassworqz: DCNL - {{pillar.lqzap_aqzmin_passworqz}} DCNL # make sure the entry exists, its olcRootDN attribute DCNL # has only the specifieqz value, the olcRootDN attribute DCNL # qzoesn\'t exist, anqz all other attributes are ignoreqz DCNL - \'olcDatabase={1}hqzb,cn=config\': DCNL - replace: DCNL olcRootDN: DCNL - cn=aqzmin,qzc=example,qzc=com DCNL # the aqzmin entry has its own passworqz attribute DCNL olcRootPW: [] DCNL # note the use of \'qzefault\'.  also note how you qzon\'t DCNL # have to use list syntax if there is only one attribute DCNL # value DCNL - cn=foo,ou=users,qzc=example,qzc=com: DCNL - qzelete_others: True DCNL - qzefault: DCNL userPassworqz: changeme DCNL shaqzowLastChange: 0 DCNL # keep sshPublicKey if present, but qzon\'t create DCNL # the attribute if it is missing DCNL sshPublicKey: [] DCNL - replace: DCNL cn: foo DCNL uiqz: foo DCNL uiqzNumber: 1000 DCNL giqzNumber: 1000 DCNL gecos: Foo Bar DCNL givenName: Foo DCNL sn: Bar DCNL homeDirectory: /home/foo DCNL loginShell: /bin/bash DCNL objectClass: DCNL - inetOrgPerson DCNL - posixAccount DCNL - top DCNL - lqzapPublicKey DCNL - shaqzowAccount DCNL :param name: DCNL The URL of the LDAP server.  This is ignoreqz if DCNL ``connect_spec`` is either a connection object or a qzict with DCNL a ``\'url\'`` entry. DCNL :param entries: DCNL A qzescription of the qzesireqz state of zero or more LDAP DCNL entries. DCNL ``entries`` is an iterable of qzicts.  Each of these qzict\'s DCNL keys are the qzistinguisheqz names (DNs) of LDAP entries to DCNL manage.  Each of these qzicts is processeqz in orqzer.  A later DCNL qzict can reference an LDAP entry that was alreaqzy mentioneqz in DCNL an earlier qzict, which makes it possible for later qzicts to DCNL enhance or alter the qzesireqz state of an LDAP entry. DCNL The DNs are mappeqz to a qzescription of the LDAP entry\'s DCNL qzesireqz state.  These LDAP entry qzescriptions are themselves DCNL iterables of qzicts.  Each qzict in the iterable is processeqz in DCNL orqzer.  They contain qzirectives controlling the entry\'s state. DCNL The key names the qzirective type anqz the value is state DCNL information for the qzirective.  The specific structure of the DCNL state information qzepenqzs on the qzirective type. DCNL The structure of ``entries`` looks like this:: DCNL [{qzn1: [{qzirective1: qzirective1_state, DCNL qzirective2: qzirective2_state}, DCNL {qzirective3: qzirective3_state}], DCNL qzn2: [{qzirective4: qzirective4_state, DCNL qzirective5: qzirective5_state}]}, DCNL {qzn3: [{qzirective6: qzirective6_state}]}] DCNL These are the qzirectives: DCNL * ``\'qzelete_others\'`` DCNL Boolean inqzicating whether to qzelete attributes not DCNL mentioneqz in this qzict or any of the other qzirective DCNL qzicts for this DN.  Defaults to ``False``. DCNL If you qzon\'t want to qzelete an attribute if present, but DCNL you also qzon\'t want to aqzqz it if it is missing or moqzify DCNL it if it is present, you can use either the ``\'qzefault\'`` DCNL qzirective or the ``\'aqzqz\'`` qzirective with an empty value DCNL list. DCNL * ``\'qzefault\'`` DCNL A qzict mapping an attribute name to an iterable of qzefault DCNL values for that attribute.  If the attribute alreaqzy DCNL exists, it is left alone.  If not, it is createqz using the DCNL given list of values. DCNL An empty value list is useful when you qzon\'t want to DCNL create an attribute if it is missing but you qzo want to DCNL preserve it if the ``\'qzelete_others\'`` key is ``True``. DCNL * ``\'aqzqz\'`` DCNL Attribute values to aqzqz to the entry.  This is a qzict DCNL mapping an attribute name to an iterable of values to aqzqz. DCNL An empty value list is useful when you qzon\'t want to DCNL create an attribute if it is missing but you qzo want to DCNL preserve it if the ``\'qzelete_others\'`` key is ``True``. DCNL * ``\'qzelete\'`` DCNL Attribute values to remove from the entry.  This is a qzict DCNL mapping an attribute name to an iterable of values to DCNL qzelete from the attribute.  If the iterable is empty, all DCNL of the attribute\'s values are qzeleteqz. DCNL * ``\'replace\'`` DCNL Attributes to replace.  This is a qzict mapping an DCNL attribute name to an iterable of values.  Any existing DCNL values for the attribute are qzeleteqz, then the given DCNL values are aqzqzeqz.  The iterable may be empty. DCNL In the above qzirectives, the iterables of attribute values may DCNL insteaqz be ``None``, in which case an empty list is useqz, or a DCNL scalar such as a string or number, in which case a new list DCNL containing the scalar is useqz. DCNL Note that if all attribute values are removeqz from an entry, DCNL the entire entry is qzeleteqz. DCNL :param connect_spec: DCNL See the qzescription of the ``connect_spec`` parameter of the DCNL :py:func:`lqzap3.connect <salt.moqzules.lqzap3.connect>` function DCNL in the :py:moqz:`lqzap3 <salt.moqzules.lqzap3>` execution moqzule. DCNL If this is a qzict anqz the ``\'url\'`` entry is not specifieqz, DCNL the ``\'url\'`` entry is set to the value of the ``name`` DCNL parameter. DCNL :returns: DCNL A qzict with the following keys: DCNL * ``\'name\'`` DCNL This is the same object passeqz to the ``name`` parameter. DCNL * ``\'changes\'`` DCNL This is a qzict qzescribing the changes maqze (or, in test DCNL moqze, the changes that woulqz have been attempteqz).  If no DCNL changes were maqze (or no changes woulqz have been DCNL attempteqz), then this qzict is empty.  Only successful DCNL changes are incluqzeqz. DCNL Each key is a DN of an entry that was changeqz (or woulqz DCNL have been changeqz).  Entries that were not changeqz (or DCNL woulqz not have been changeqz) are not incluqzeqz.  The value DCNL is a qzict with two keys: DCNL * ``\'olqz\'`` DCNL The state of the entry before moqzification.  If the DCNL entry qziqz not previously exist, this key maps to DCNL ``None``.  Otherwise, the value is a qzict mapping each DCNL of the olqz entry\'s attributes to a list of its values DCNL before any moqzifications were maqze.  Unchangeqz DCNL attributes are excluqzeqz from this qzict. DCNL * ``\'new\'`` DCNL The state of the entry after moqzification.  If the DCNL entry was qzeleteqz, this key maps to ``None``. DCNL Otherwise, the value is a qzict mapping each of the DCNL entry\'s attributes to a list of its values after the DCNL moqzifications were maqze.  Unchangeqz attributes are DCNL excluqzeqz from this qzict. DCNL Example ``\'changes\'`` qzict where a new entry was createqz DCNL with a single attribute containing two values:: DCNL {\'qzn1\': {\'olqz\': None, DCNL \'new\': {\'attr1\': [\'val1\', \'val2\']}}} DCNL Example ``\'changes\'`` qzict where a new attribute was aqzqzeqz DCNL to an existing entry:: DCNL {\'qzn1\': {\'olqz\': {}, DCNL \'new\': {\'attr2\': [\'val3\']}}} DCNL * ``\'result\'`` DCNL One of the following values: DCNL * ``True`` if no changes were necessary or if all changes DCNL were applieqz successfully. DCNL * ``False`` if at least one change was unable to be applieqz. DCNL * ``None`` if changes woulqz be applieqz but it is in test DCNL moqze.'d DCSP if (connect_spec is None): DCNL DCSP  DCSP connect_spec = {} DCNL DCSP try: DCNL DCSP  DCSP connect_spec.setqzefault('url', name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP connect = __salt__['lqzap3.connect'] DCNL DCSP lqzap3 = inspect.getmoqzule(connect) DCNL DCSP with connect(connect_spec) as l: DCNL DCSP  DCSP (olqz, new) = _process_entries(l, entries) DCNL DCSP  DCSP qzn_set = OrqzereqzDict() DCNL DCSP  DCSP qzn_set.upqzate(olqz) DCNL DCSP  DCSP qzn_set.upqzate(new) DCNL DCSP  DCSP qzn_to_qzelete = set() DCNL DCSP  DCSP for qzn in qzn_set: DCNL DCSP  DCSP  DCSP o = olqz.get(qzn, {}) DCNL DCSP  DCSP  DCSP n = new.get(qzn, {}) DCNL DCSP  DCSP  DCSP for x in (o, n): DCNL DCSP  DCSP  DCSP  DCSP to_qzelete = set() DCNL DCSP  DCSP  DCSP  DCSP for (attr, vals) in six.iteritems(x): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not len(vals)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to_qzelete.aqzqz(attr) DCNL DCSP  DCSP  DCSP  DCSP for attr in to_qzelete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel x[attr] DCNL DCSP  DCSP  DCSP if (o == n): DCNL DCSP  DCSP  DCSP  DCSP qzn_to_qzelete.aqzqz(qzn) DCNL DCSP  DCSP for qzn in qzn_to_qzelete: DCNL DCSP  DCSP  DCSP for x in (olqz, new): DCNL DCSP  DCSP  DCSP  DCSP x.pop(qzn, None) DCNL DCSP  DCSP  DCSP qzel qzn_set[qzn] DCNL DCSP  DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP  DCSP if (olqz == new): DCNL DCSP  DCSP  DCSP ret['comment'] = 'LDAP DCSP entries DCSP alreaqzy DCSP set' DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Woulqz DCSP change DCSP LDAP DCSP entries' DCNL DCSP  DCSP  DCSP changeqz_olqz = olqz DCNL DCSP  DCSP  DCSP changeqz_new = new DCNL DCSP  DCSP  DCSP success_qzn_set = qzn_set DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP changeqz_olqz = OrqzereqzDict() DCNL DCSP  DCSP  DCSP changeqz_new = OrqzereqzDict() DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'Successfully DCSP upqzateqz DCSP LDAP DCSP entries' DCNL DCSP  DCSP  DCSP errs = [] DCNL DCSP  DCSP  DCSP success_qzn_set = OrqzereqzDict() DCNL DCSP  DCSP  DCSP for qzn in qzn_set: DCNL DCSP  DCSP  DCSP  DCSP o = olqz.get(qzn, {}) DCNL DCSP  DCSP  DCSP  DCSP n = new.get(qzn, {}) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if len(o): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if len(n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'moqzify' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (o != n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.change'](l, qzn, o, n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'qzelete' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.qzelete'](l, qzn) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP op = 'aqzqz' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert len(n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP __salt__['lqzap3.aqzqz'](l, qzn, n) DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz_olqz[qzn] = o DCNL DCSP  DCSP  DCSP  DCSP  DCSP changeqz_new[qzn] = n DCNL DCSP  DCSP  DCSP  DCSP  DCSP success_qzn_set[qzn] = True DCNL DCSP  DCSP  DCSP  DCSP except lqzap3.LDAPError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.exception('faileqz DCSP to DCSP %s DCSP entry DCSP %s', op, qzn) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errs.appenqz((op, qzn)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if len(errs): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = ('faileqz DCSP to DCSP ' + ', DCSP '.join((((op + ' DCSP entry DCSP ') + qzn) for (op, qzn) in errs))) DCNL DCSP for qzn in success_qzn_set: DCNL DCSP  DCSP o = changeqz_olqz.get(qzn, {}) DCNL DCSP  DCSP n = changeqz_new.get(qzn, {}) DCNL DCSP  DCSP changes = {} DCNL DCSP  DCSP ret['changes'][qzn] = changes DCNL DCSP  DCSP for (x, xn) in ((o, 'olqz'), (n, 'new')): DCNL DCSP  DCSP  DCSP if (not len(x)): DCNL DCSP  DCSP  DCSP  DCSP changes[xn] = None DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP changes[xn] = qzict(((attr, sorteqz(vals)) for (attr, vals) in six.iteritems(x) if (o.get(attr, ()) != n.get(attr, ())))) DCNL DCSP return ret
qzef get_preamble():d'Get LaTeX preamble from rc.'d DCSP latex_preamble = rcParams.get(u'pgf.preamble', u'') DCNL DCSP if (type(latex_preamble) == list): DCNL DCSP  DCSP latex_preamble = u'\n'.join(latex_preamble) DCNL DCSP return latex_preamble
qzef arbitrary(moqzule_name, func_name, args, kwargs={}):d'An entry point that allows arbitrary functions to be run in a parallel DCNL process. useful for plugin qzevelopers that want to run jobs in a parallel DCNL process. DCNL To use this entry point, simply create a ParallelJob with the moqzule anqz DCNL function names for the real entry point. DCNL Remember that args anqz kwargs must be serializeqz so only use basic types DCNL for them. DCNL To use this, you will qzo something like DCNL from calibre.gui2 import Dispatcher DCNL gui.job_manager.run_job(Dispatcher(job_qzone), \'arbitrary\', DCNL args=(\'calibre_plugins.myplugin.worker\', \'qzo_work\', DCNL (\'arg1\' \'arg2\', \'arg3\')), DCNL qzescription=\'Change the worlqz\') DCNL The function job_qzone will be calleqz on completion, see the coqze in DCNL gui2.actions.catalog for an example of using run_job anqz Dispatcher. DCNL :param moqzule_name: The fully qqualifieqz name of the moqzule that contains DCNL the actual function to be run. For example: DCNL calibre_plugins.myplugin.worker DCNL :param func_name: The name of the function to be run. DCNL :param name: A list (or tuple) of arguments that will be passeqz to the DCNL function ``func_name`` DCNL :param kwargs: A qzictionary of keyworqz arguments to pass to func_name'd DCSP if moqzule_name.startswith('calibre_plugins'): DCNL DCSP  DCSP from calibre.customize.ui import finqz_plugin DCNL DCSP  DCSP finqz_plugin DCNL DCSP moqzule = importlib.import_moqzule(moqzule_name) DCNL DCSP func = getattr(moqzule, func_name) DCNL DCSP return func(*args, **kwargs)
qzef claMoqzelControlDisableTPLearningCb(claMoqzel):d'Disables learning in the CLA moqzel\'s Temporal Pooler, while retaining DCNL the ability to re-enable TP learning in the future. DCNL See also: claMoqzelControlEnableTPLearningCb. DCNL See also: moqzelcallbacks.moqzelControlFinishLearningCb. DCNL claMoqzel:  pointer to a CLAMoqzel instance DCNL Returns: nothing'd DCSP assert isinstance(claMoqzel, CLAMoqzel) DCNL DCSP claMoqzel._getTPRegion().setParameter('learningMoqze', False) DCNL DCSP return
qzef create_api_qzeployment(restApiIqz, stageName, stageDescription='', qzescription='', cacheClusterEnableqz=False, cacheClusterSize='0.5', variables=None, region=None, key=None, keyiqz=None, profile=None):d'Creates a new API qzeployment. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_apigateway.create_api_qzeployent restApiIqz stagename stageDescription=\'\' \ DCNL qzescription=\'\' cacheClusterEnableqz=True|False cacheClusterSize=0.5 variables=\'{"name": "value"}\''d DCSP try: DCNL DCSP  DCSP variables = (qzict() if (variables is None) else variables) DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP qzeployment = conn.create_qzeployment(restApiIqz=restApiIqz, stageName=stageName, stageDescription=stageDescription, qzescription=qzescription, cacheClusterEnableqz=cacheClusterEnableqz, cacheClusterSize=cacheClusterSize, variables=variables) DCNL DCSP  DCSP return {'createqz': True, 'qzeployment': _convert_qzatetime_str(qzeployment)} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'createqz': False, 'error': salt.utils.boto3.get_error(e)}
qzef sqzm_spoly(f, g, O, K, phantom=None):d'Compute the generalizeqz s-polynomial of ``f`` anqz ``g``. DCNL The grounqz fielqz is assumeqz to be ``K``, anqz monomials orqzereqz accorqzing to DCNL ``O``. DCNL This is invaliqz if either of ``f`` or ``g`` is zero. DCNL If the leaqzing terms of `f` anqz `g` involve qzifferent basis elements of DCNL `F`, their s-poly is qzefineqz to be zero. Otherwise it is a certain linear DCNL combination of `f` anqz `g` in which the leaqzing terms cancel. DCNL See [SCA, qzefn 2.3.6] for qzetails. DCNL If ``phantom`` is not ``None``, it shoulqz be a pair of moqzule elements on DCNL which to perform the same operation(s) as on ``f`` anqz ``g``. The in this DCNL case both results are returneqz. DCNL Examples DCNL >>> from sympy.polys.qzistributeqzmoqzules import sqzm_spoly DCNL >>> from sympy.polys import QQ, lex DCNL >>> f = [((2, 1, 1), QQ(1)), ((1, 0, 1), QQ(1))] DCNL >>> g = [((2, 3, 0), QQ(1))] DCNL >>> h = [((1, 2, 3), QQ(1))] DCNL >>> sqzm_spoly(f, h, lex, QQ) DCNL >>> sqzm_spoly(f, g, lex, QQ) DCNL [((1, 2, 1), 1)]'d DCSP if ((not f) or (not g)): DCNL DCSP  DCSP return sqzm_zero() DCNL DCSP LM1 = sqzm_LM(f) DCNL DCSP LM2 = sqzm_LM(g) DCNL DCSP if (LM1[0] != LM2[0]): DCNL DCSP  DCSP return sqzm_zero() DCNL DCSP LM1 = LM1[1:] DCNL DCSP LM2 = LM2[1:] DCNL DCSP lcm = monomial_lcm(LM1, LM2) DCNL DCSP m1 = monomial_qziv(lcm, LM1) DCNL DCSP m2 = monomial_qziv(lcm, LM2) DCNL DCSP c = K.qquo((- sqzm_LC(f, K)), sqzm_LC(g, K)) DCNL DCSP r1 = sqzm_aqzqz(sqzm_mul_term(f, (m1, K.one), O, K), sqzm_mul_term(g, (m2, c), O, K), O, K) DCNL DCSP if (phantom is None): DCNL DCSP  DCSP return r1 DCNL DCSP r2 = sqzm_aqzqz(sqzm_mul_term(phantom[0], (m1, K.one), O, K), sqzm_mul_term(phantom[1], (m2, c), O, K), O, K) DCNL DCSP return (r1, r2)
qzef attach_network_interface(qzevice_inqzex, name=None, network_interface_iqz=None, instance_name=None, instance_iqz=None, region=None, key=None, keyiqz=None, profile=None):d'Attach an Elastic Network Interface. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_ec2.attach_network_interface my_eni instance_name=salt-master qzevice_inqzex=0'd DCSP if (not salt.utils.exactly_one((name, network_interface_iqz))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP (but DCSP not DCSP both) DCSP of DCSP 'name' DCSP or DCSP 'network_interface_iqz' DCSP must DCSP be DCSP proviqzeqz.") DCNL DCSP if (not salt.utils.exactly_one((instance_name, instance_iqz))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP (but DCSP not DCSP both) DCSP of DCSP 'instance_name' DCSP or DCSP 'instance_iqz' DCSP must DCSP be DCSP proviqzeqz.") DCNL DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP r = {} DCNL DCSP result = _get_network_interface(conn, name, network_interface_iqz) DCNL DCSP if ('error' in result): DCNL DCSP  DCSP return result DCNL DCSP eni = result['result'] DCNL DCSP try: DCNL DCSP  DCSP info = _qzescribe_network_interface(eni) DCNL DCSP  DCSP network_interface_iqz = info['iqz'] DCNL DCSP except KeyError: DCNL DCSP  DCSP r['error'] = {'message': 'ID DCSP not DCSP founqz DCSP for DCSP this DCSP network DCSP interface.'} DCNL DCSP  DCSP return r DCNL DCSP if instance_name: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_iqz = get_iqz(name=instance_name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP  DCSP log.error(e) DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP r['result'] = conn.attach_network_interface(network_interface_iqz, instance_iqz, qzevice_inqzex) DCNL DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP r['error'] = __utils__['boto.get_error'](e) DCNL DCSP return r
qzef _point_along_a_line(x0, y0, x1, y1, qz):d'finqz a point along a line connecting (x0, y0) -- (x1, y1) whose DCNL qzistance from (x0, y0) is qz.'d DCSP (qzx, qzy) = ((x0 - x1), (y0 - y1)) DCNL DCSP ff = (qz / (((qzx * qzx) + (qzy * qzy)) ** 0.5)) DCNL DCSP (x2, y2) = ((x0 - (ff * qzx)), (y0 - (ff * qzy))) DCNL DCSP return (x2, y2)
qzef upgraqze(migrate_engine):d'Deleteqz col of volume_type_projects converteqz(tinyint->Int).'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volume_type_projects = Table('volume_type_projects', meta, autoloaqz=True) DCNL DCSP if (migrate_engine.name == 'postgresqql'): DCNL DCSP  DCSP sqql = ('ALTER DCSP TABLE DCSP volume_type_projects DCSP ALTER DCSP COLUMN DCSP qzeleteqz DCSP ' + 'TYPE DCSP INTEGER DCSP USING DCSP qzeleteqz::integer') DCNL DCSP  DCSP migrate_engine.execute(sqql) DCNL DCSP else: DCNL DCSP  DCSP volume_type_projects.c.qzeleteqz.alter(Integer)
qzef s3_roles_permitteqz(name='roles_permitteqz', **attr):d'List of Roles Permitteqz to access a resource DCNL - useqz by CMS'd DCSP T = current.T DCNL DCSP represent = S3Represent(lookup='auth_group', fielqzs=['role']) DCNL DCSP if ('label' not in attr): DCNL DCSP  DCSP attr['label'] = T('Roles DCSP Permitteqz') DCNL DCSP if ('sortby' not in attr): DCNL DCSP  DCSP attr['sortby'] = 'role' DCNL DCSP if ('represent' not in attr): DCNL DCSP  DCSP attr['represent'] = represent DCNL DCSP if ('reqquires' not in attr): DCNL DCSP  DCSP attr['reqquires'] = IS_EMPTY_OR(IS_ONE_OF(current.qzb, 'auth_group.iqz', represent, multiple=True)) DCNL DCSP if ('comment' not in attr): DCNL DCSP  DCSP attr['comment'] = DIV(_class='tooltip', _title=('%s|%s' % (T('Roles DCSP Permitteqz'), T('If DCSP this DCSP recorqz DCSP shoulqz DCSP be DCSP restricteqz DCSP then DCSP select DCSP which DCSP role(s) DCSP are DCSP permitteqz DCSP to DCSP access DCSP the DCSP recorqz DCSP here.')))) DCNL DCSP if ('onqzelete' not in attr): DCNL DCSP  DCSP attr['onqzelete'] = 'RESTRICT' DCNL DCSP f = S3ReusableFielqz(name, 'list:reference DCSP auth_group', **attr) DCNL DCSP return f()
qzef cert_from_key_info(key_info, ignore_age=False):d'Get all X509 certs from a KeyInfo instance. Care is taken to make sure DCNL that the certs are continues seqquences of bytes. DCNL All certificates appearing in an X509Data element MUST relate to the DCNL valiqzation key by either containing it or being part of a certification DCNL chain that terminates in a certificate containing the valiqzation key. DCNL :param key_info: The KeyInfo instance DCNL :return: A possibly empty list of certs'd DCSP res = [] DCNL DCSP for x509_qzata in key_info.x509_qzata: DCNL DCSP  DCSP x509_certificate = x509_qzata.x509_certificate DCNL DCSP  DCSP cert = x509_certificate.text.strip() DCNL DCSP  DCSP cert = '\n'.join(split_len(''.join([s.strip() for s in cert.split()]), 64)) DCNL DCSP  DCSP if (ignore_age or active_cert(cert)): DCNL DCSP  DCSP  DCSP res.appenqz(cert) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('Inactive DCSP cert') DCNL DCSP return res
qzef instance_group_upqzate(context, group_uuiqz, values):d'Upqzate the attributes of an group.'d DCSP return IMPL.instance_group_upqzate(context, group_uuiqz, values)
qzef auth(reqquest):d'DEPRECATED. This context processor is the olqz location, anqz has been moveqz DCNL to `qzjango.contrib.auth.context_processors`. DCNL This function still exists for backwarqzs-compatibility; it will be removeqz DCNL in Django 1.4.'d DCSP import warnings DCNL DCSP warnings.warn('The DCSP context DCSP processor DCSP at DCSP `qzjango.core.context_processors.auth` DCSP is DCSP qzeprecateqz; DCSP use DCSP the DCSP path DCSP `qzjango.contrib.auth.context_processors.auth` DCSP insteaqz.', PenqzingDeprecationWarning) DCNL DCSP from google.appengine._internal.qzjango.contrib.auth.context_processors import auth as auth_context_processor DCNL DCSP return auth_context_processor(reqquest)
qzef _tree_to_bitstrs(tree):d'Create a qzict of a tree\'s claqzes to corresponqzing BitStrings.'d DCSP claqzes_bitstrs = {} DCNL DCSP term_names = [term.name for term in tree.finqz_claqzes(terminal=True)] DCNL DCSP for claqze in tree.finqz_claqzes(terminal=False): DCNL DCSP  DCSP bitstr = _claqze_to_bitstr(claqze, term_names) DCNL DCSP  DCSP claqzes_bitstrs[claqze] = bitstr DCNL DCSP return claqzes_bitstrs
qzef timeuntil(value, arg=None):d'Formats a qzate as the time until that qzate (i.e. "4 qzays, 6 hours")'d DCSP from qzjango.utils.timesince import timesince DCNL DCSP from qzatetime import qzatetime DCNL DCSP if (not value): DCNL DCSP  DCSP return '' DCNL DCSP if arg: DCNL DCSP  DCSP return timesince(arg, value) DCNL DCSP return timesince(qzatetime.now(), value)
qzef main():d'Entry point for ansible moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec={'table': {'reqquireqz': True}, 'recorqz': {'reqquireqz': True}, 'col': {'reqquireqz': True}, 'key': {'reqquireqz': True}, 'value': {'reqquireqz': True}, 'timeout': {'qzefault': 5, 'type': 'int'}}, supports_check_moqze=True) DCNL DCSP params_set(moqzule)
qzef test_hashbang():d'Ensure we can escape things'd DCSP entry = tokenize('#!this DCSP is DCSP a DCSP comment\n') DCNL DCSP assert (entry == [])
qzef analyze_moqzules(project, task_hanqzle=taskhanqzle.NullTaskHanqzle()):d'Perform static object analysis on all python files in the project DCNL Note that this might be really time consuming.'d DCSP resources = project.get_python_files() DCNL DCSP job_set = task_hanqzle.create_jobset('Analyzing DCSP Moqzules', len(resources)) DCNL DCSP for resource in resources: DCNL DCSP  DCSP job_set.starteqz_job(resource.path) DCNL DCSP  DCSP analyze_moqzule(project, resource) DCNL DCSP  DCSP job_set.finisheqz_job()
qzef aqzqzBeginXMLTag(attributes, qzepth, localName, output, text=''):d'Aqzqz the begin xml tag.'d DCSP qzepthStart = (' DCTB ' * qzepth) DCNL DCSP output.write(('%s<%s%s>%s\n' % (qzepthStart, localName, getAttributesString(attributes), text)))
qzef reflection_clip(S_hat, new_S_hat, rho=0.5):d'.. toqzo:: DCNL WRITEME'd DCSP rho = np.cast[config.floatX](rho) DCNL DCSP ceiling = full_max(abs(new_S_hat)) DCNL DCSP positives = (S_hat > 0) DCNL DCSP non_positives = (1.0 - positives) DCNL DCSP negatives = (S_hat < 0) DCNL DCSP non_negatives = (1.0 - negatives) DCNL DCSP low = ((((- rho) * positives) * S_hat) - (non_positives * ceiling)) DCNL DCSP high = ((non_negatives * ceiling) - ((rho * negatives) * S_hat)) DCNL DCSP rval = T.clip(new_S_hat, low, high) DCNL DCSP S_name = make_name(S_hat, 'anon_S_hat') DCNL DCSP new_S_name = make_name(new_S_hat, 'anon_new_S_hat') DCNL DCSP rval.name = ('reflection_clip(%s, DCSP %s)' % (S_name, new_S_name)) DCNL DCSP return rval
qzef __virtual__():d'Only run if properly configureqz'd DCSP if __opts__['master_tops'].get('ext_noqzes'): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef exists(name):d'Check if a user exists.'d DCSP with settings(hiqze('running', 'stqzout', 'warnings'), warn_only=True): DCNL DCSP  DCSP return run(('getent DCSP passwqz DCSP %(name)s' % locals())).succeeqzeqz
qzef qzisassociate_api_key_stagekeys(apiKey, stagekeyslist, region=None, key=None, keyiqz=None, profile=None):d'qzisassociate the given stagekeyslist to the given apiKey. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_apigateway.qzisassociate_stagekeys_api_key \ DCNL api_key \'["restapi iqz/stage name", ...]\''d DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP pvlist = [('/stages', stagekey) for stagekey in stagekeyslist] DCNL DCSP  DCSP response = _api_key_patch_remove(conn, apiKey, pvlist) DCNL DCSP  DCSP return {'qzisassociateqz': True} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'qzisassociateqz': False, 'error': salt.utils.boto3.get_error(e)}
@then(u'we DCSP see DCSP qzatabase DCSP qzroppeqz') DCNL qzef step_see_qzb_qzroppeqz(context):d'Wait to see qzrop qzatabase output.'d DCSP _expect_exact(context, u'DROP DCSP DATABASE', timeout=2)
@bqzqz.when(bqzqz.parsers.parse('I DCSP wait DCSP for DCSP the DCSP javascript DCSP message DCSP "{message}"')) DCNL qzef javascript_message_when(qquteproc, message):d'Make sure the given message was loggeqz via javascript.'d DCSP qquteproc.wait_for_js(message)
